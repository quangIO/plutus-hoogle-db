-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Language library for Plutus Core
--   
--   Pretty-printer, parser, and typechecker for Plutus Core.
@package plutus-core
@version 0.1.0.0

module Crypto
verifySignature :: Alternative f => ByteString -> ByteString -> ByteString -> f Bool


-- | Hash functions for lazy [[Data.ByteString.ByteString]]s
module Data.ByteString.Hash

-- | Hash a [[BSL.ByteString]] using the SHA-256 hash function.
sha2 :: ByteString -> ByteString

-- | Hash a [[BSL.ByteString]] using the SHA3-256 hash function.
sha3 :: ByteString -> ByteString

module Data.RandomAccessList.SkewBinary

-- | A strict list of complete binary trees accompanied by their size. The
--   trees appear in &gt;=-size order. Note: this list is strict in its
--   spine, unlike the Prelude list
data RAList a
Nil :: RAList a
pattern Cons :: a -> RAList a -> RAList a
index :: RAList a -> Word -> a
null :: RAList a -> Bool
head :: RAList a -> a
tail :: RAList a -> RAList a
uncons :: RAList a -> Maybe (a, RAList a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RandomAccessList.SkewBinary.Tree a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RandomAccessList.SkewBinary.Tree a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RandomAccessList.SkewBinary.RAList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RandomAccessList.SkewBinary.RAList a)
instance GHC.Exts.IsList (Data.RandomAccessList.SkewBinary.RAList a)


-- | Adapted from <a>SafeInt</a> to perform saturating arithmetic (i.e.
--   returning max or min bounds) instead of throwing on overflow.
--   
--   This is not quite as fast as using <a>Int</a> or <tt>Int64</tt>
--   directly, but we need the safety.
module Data.SatInt
data SatInt
instance Data.Csv.Conversion.FromField Data.SatInt.SatInt
instance Data.Aeson.Types.ToJSON.ToJSON Data.SatInt.SatInt
instance Data.Aeson.Types.FromJSON.FromJSON Data.SatInt.SatInt
instance Language.Haskell.TH.Syntax.Lift Data.SatInt.SatInt
instance Data.Primitive.Types.Prim Data.SatInt.SatInt
instance Data.Bits.FiniteBits Data.SatInt.SatInt
instance Data.Bits.Bits Data.SatInt.SatInt
instance Control.DeepSeq.NFData Data.SatInt.SatInt
instance GHC.Show.Show Data.SatInt.SatInt
instance GHC.Read.Read Data.SatInt.SatInt
instance GHC.Classes.Eq Data.SatInt.SatInt
instance GHC.Classes.Ord Data.SatInt.SatInt
instance GHC.Num.Num Data.SatInt.SatInt
instance GHC.Enum.Bounded Data.SatInt.SatInt
instance GHC.Enum.Enum Data.SatInt.SatInt
instance GHC.Real.Real Data.SatInt.SatInt
instance GHC.Real.Integral Data.SatInt.SatInt

module Data.Text.Prettyprint.Doc.Custom

-- | This prints a document enclosed by brackets, possibly indenting the
--   output on a new line if it does not fit.
brackets' :: Doc a -> Doc a

-- | This prints a document enclosed by braces, possibly indenting the
--   output on a new line if it does not fit.
braces' :: Doc a -> Doc a

-- | This is the same as <a>vsep</a>, but it <a>group</a>s the output, so
--   that documents are printed on the same line when possible.
vsep' :: [Doc a] -> Doc a

-- | This prints a document enclosed by parentheses, aligning the opening
--   and closing parentheses.
parens' :: Doc a -> Doc a

-- | This prints both documents on the same line separated by a space if
--   they can fit, and behaves like <a>&lt;//&gt;</a> otherwise.
(</>) :: Doc a -> Doc a -> Doc a
infixr 5 </>

-- | This operator prints <tt>a</tt> and then prints <tt>b</tt> indented on
--   a new line
(<//>) :: Doc a -> Doc a -> Doc a
infixr 5 <//>

module ErrorCode

-- | Assigns an error-code to data-constructors (values) of error types.
--   Note, when implementing this method you're only supposed to look at
--   the outermost constructor (whnf) of the <tt>a</tt> value to decide for
--   the error-code.
class HasErrorCode a
errorCode :: HasErrorCode a => a -> ErrorCode

-- | A wrapper to Natural so as to override the pretty instance of Natural
--   with zero padding
newtype ErrorCode
ErrorCode :: Natural -> ErrorCode
instance GHC.Enum.Enum ErrorCode.ErrorCode
instance GHC.Classes.Ord ErrorCode.ErrorCode
instance GHC.Classes.Eq ErrorCode.ErrorCode
instance Prettyprinter.Internal.Pretty ErrorCode.ErrorCode

module PlutusCore.Constant.Dynamic.Emit

-- | A class for emitting <a>String</a>s in a monadic context (basically,
--   for logging).
class Monad m => MonadEmitter m
emit :: MonadEmitter m => String -> m ()

-- | A concrete type implementing <a>MonadEmitter</a>. Useful in signatures
--   of built-in functions that do logging. We don't use any concrete
--   first-order encoding and instead pack a <tt>MonadEmitter m</tt>
--   constraint internally, so that built-in functions that do logging can
--   work in any monad implementing <a>MonadEmitter</a> (for example,
--   <tt>CkM</tt> or <tt>CekM</tt>).
newtype Emitter a
Emitter :: (forall m. MonadEmitter m => m a) -> Emitter a
[unEmitter] :: Emitter a -> forall m. MonadEmitter m => m a

-- | A newtype wrapper for via-deriving a vacuous <a>MonadEmitter</a>
--   instance for a monad.
newtype NoEmitterT m a
NoEmitterT :: m a -> NoEmitterT m a
[unNoEmitterT] :: NoEmitterT m a -> m a

-- | A newtype wrapper for providing a <a>MonadEmitter</a> instance by
--   directly providing the function.
newtype WithEmitterT m a
WithEmitterT :: ((String -> m ()) -> m a) -> WithEmitterT m a
[unWithEmitterT] :: WithEmitterT m a -> (String -> m ()) -> m a
instance GHC.Base.Functor PlutusCore.Constant.Dynamic.Emit.Emitter
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (PlutusCore.Constant.Dynamic.Emit.WithEmitterT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (PlutusCore.Constant.Dynamic.Emit.WithEmitterT m)
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Constant.Dynamic.Emit.WithEmitterT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (PlutusCore.Constant.Dynamic.Emit.WithEmitterT m)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Constant.Dynamic.Emit.WithEmitterT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (PlutusCore.Constant.Dynamic.Emit.NoEmitterT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (PlutusCore.Constant.Dynamic.Emit.NoEmitterT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (PlutusCore.Constant.Dynamic.Emit.NoEmitterT m)
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Constant.Dynamic.Emit.NoEmitterT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (PlutusCore.Constant.Dynamic.Emit.NoEmitterT m)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Constant.Dynamic.Emit.NoEmitterT m)
instance GHC.Base.Monad m => PlutusCore.Constant.Dynamic.Emit.MonadEmitter (PlutusCore.Constant.Dynamic.Emit.NoEmitterT m)
instance GHC.Base.Monad m => PlutusCore.Constant.Dynamic.Emit.MonadEmitter (PlutusCore.Constant.Dynamic.Emit.WithEmitterT m)
instance Control.Monad.Trans.Class.MonadTrans PlutusCore.Constant.Dynamic.Emit.WithEmitterT
instance GHC.Base.Applicative PlutusCore.Constant.Dynamic.Emit.Emitter
instance GHC.Base.Monad PlutusCore.Constant.Dynamic.Emit.Emitter
instance PlutusCore.Constant.Dynamic.Emit.MonadEmitter PlutusCore.Constant.Dynamic.Emit.Emitter
instance PlutusCore.Constant.Dynamic.Emit.MonadEmitter m => PlutusCore.Constant.Dynamic.Emit.MonadEmitter (Control.Monad.Trans.Except.ExceptT e m)

module PlutusPrelude

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
infixr 3 &&&

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>

-- | List of elements of a structure, from left to right.
toList :: Foldable t => t a -> [a]

-- | Case analysis for the <a>Bool</a> type. <tt><a>bool</a> x y p</tt>
--   evaluates to <tt>x</tt> when <tt>p</tt> is <a>False</a>, and evaluates
--   to <tt>y</tt> when <tt>p</tt> is <a>True</a>.
--   
--   This is equivalent to <tt>if p then y else x</tt>; that is, one can
--   think of it as an if-then-else construct with its arguments reordered.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; bool "foo" "bar" True
--   "bar"
--   
--   &gt;&gt;&gt; bool "foo" "bar" False
--   "foo"
--   </pre>
--   
--   Confirm that <tt><a>bool</a> x y p</tt> and <tt>if p then y else
--   x</tt> are equivalent:
--   
--   <pre>
--   &gt;&gt;&gt; let p = True; x = "bar"; y = "foo"
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   
--   &gt;&gt;&gt; let p = False
--   
--   &gt;&gt;&gt; bool x y p == if p then y else x
--   True
--   </pre>
bool :: a -> a -> Bool -> a

-- | Map covariantly over the first argument.
--   
--   <pre>
--   <a>first</a> f ≡ <a>bimap</a> f <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper ('j', 3)
--   ('J',3)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; first toUpper (Left 'j')
--   Left 'J'
--   </pre>
first :: Bifunctor p => (a -> b) -> p a c -> p b c

-- | Map covariantly over the second argument.
--   
--   <pre>
--   <a>second</a> ≡ <a>bimap</a> <a>id</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) ('j', 3)
--   ('j',4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; second (+1) (Right 3)
--   Right 4
--   </pre>
second :: Bifunctor p => (b -> c) -> p a b -> p a c

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <a>Nothing</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just 3)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just ())
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isNothing (Just Nothing)
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | The <a>isJust</a> function returns <a>True</a> iff its argument is of
--   the form <tt>Just _</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just 3)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just ())
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   </pre>
--   
--   Only the outer constructor is taken into consideration:
--   
--   <pre>
--   &gt;&gt;&gt; isJust (Just Nothing)
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" (Just "Hello, World!")
--   "Hello, World!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromMaybe "" Nothing
--   ""
--   </pre>
--   
--   Read an integer from a string using <a>readMaybe</a>. If we fail to
--   parse an integer, we want to return <tt>0</tt> by default:
--   
--   <pre>
--   &gt;&gt;&gt; import Text.Read ( readMaybe )
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "5")
--   5
--   
--   &gt;&gt;&gt; fromMaybe 0 (readMaybe "")
--   0
--   </pre>
fromMaybe :: a -> Maybe a -> a

-- | Conditional failure of <a>Alternative</a> computations. Defined by
--   
--   <pre>
--   guard True  = <a>pure</a> ()
--   guard False = <a>empty</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Common uses of <a>guard</a> include conditionally signaling an error
--   in an error monad and conditionally rejecting the current choice in an
--   <a>Alternative</a>-based parser.
--   
--   As an example of signaling an error in the error monad <a>Maybe</a>,
--   consider a safe division function <tt>safeDiv x y</tt> that returns
--   <a>Nothing</a> when the denominator <tt>y</tt> is zero and
--   <tt><a>Just</a> (x `div` y)</tt> otherwise. For example:
--   
--   <pre>
--   &gt;&gt;&gt; safeDiv 4 0
--   Nothing
--   &gt;&gt;&gt; safeDiv 4 2
--   Just 2
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using guards, but not <a>guard</a>:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y | y /= 0    = Just (x `div` y)
--               | otherwise = Nothing
--   </pre>
--   
--   A definition of <tt>safeDiv</tt> using <a>guard</a> and <a>Monad</a>
--   <tt>do</tt>-notation:
--   
--   <pre>
--   safeDiv :: Int -&gt; Int -&gt; Maybe Int
--   safeDiv x y = do
--     guard (y /= 0)
--     return (x `div` y)
--   </pre>
guard :: Alternative f => Bool -> f ()

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <a>length</a>).
--   
--   For a general <a>Foldable</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl' f z = <a>foldl'</a> f z . <a>toList</a>
--   </pre>
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Combine the elements of a structure using a monoid.
fold :: (Foldable t, Monoid m) => t m -> m

-- | <a>for</a> is <a>traverse</a> with its arguments flipped. For a
--   version that ignores the results see <a>for_</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | Throw an exception. Exceptions may be thrown from purely functional
--   code, but may only be caught within the <a>IO</a> monad.
throw :: forall (r :: RuntimeRep) (a :: TYPE r) e. Exception e => e -> a

-- | The <a>join</a> function is the conventional monad join operator. It
--   is used to remove one level of monadic structure, projecting its bound
--   argument into the outer level.
--   
--   '<tt><a>join</a> bss</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do bs &lt;- bss
--      bs
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   A common use of <a>join</a> is to run an <a>IO</a> computation
--   returned from an <a>STM</a> transaction, since <a>STM</a> transactions
--   can't perform <a>IO</a> directly. Recall that
--   
--   <pre>
--   <a>atomically</a> :: STM a -&gt; IO a
--   </pre>
--   
--   is used to run <a>STM</a> transactions atomically. So, by specializing
--   the types of <a>atomically</a> and <a>join</a> to
--   
--   <pre>
--   <a>atomically</a> :: STM (IO b) -&gt; IO (IO b)
--   <a>join</a>       :: IO (IO b)  -&gt; IO b
--   </pre>
--   
--   we can compose them as
--   
--   <pre>
--   <a>join</a> . <a>atomically</a> :: STM (IO b) -&gt; IO b
--   </pre>
--   
--   to run an <a>STM</a> transaction and the <a>IO</a> action it returns.
join :: Monad m => m (m a) -> m a

-- | Right-to-left composition of Kleisli arrows.
--   <tt>(<a>&gt;=&gt;</a>)</tt>, with the arguments flipped.
--   
--   Note how this operator resembles function composition
--   <tt>(<a>.</a>)</tt>:
--   
--   <pre>
--   (.)   ::            (b -&gt;   c) -&gt; (a -&gt;   b) -&gt; a -&gt;   c
--   (&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
infixr 1 <=<

-- | Left-to-right composition of Kleisli arrows.
--   
--   '<tt>(bs <a>&gt;=&gt;</a> cs) a</tt>' can be understood as the
--   <tt>do</tt> expression
--   
--   <pre>
--   do b &lt;- bs a
--      cs b
--   </pre>
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Flipped version of <a>&lt;$</a>.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt>as <a>$&gt;</a> b</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do as
--      pure b
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with a
--   constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Nothing $&gt; "foo"
--   Nothing
--   
--   &gt;&gt;&gt; Just 90210 $&gt; "foo"
--   Just "foo"
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with a constant <a>String</a>, resulting in an
--   <tt><a>Either</a> <a>Int</a> <a>String</a></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 8675309 $&gt; "foo"
--   Left 8675309
--   
--   &gt;&gt;&gt; Right 8675309 $&gt; "foo"
--   Right "foo"
--   </pre>
--   
--   Replace each element of a list with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] $&gt; "foo"
--   ["foo","foo","foo"]
--   </pre>
--   
--   Replace the second element of a pair with a constant <a>String</a>:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) $&gt; "foo"
--   (1,"foo")
--   </pre>
($>) :: Functor f => f a -> b -> f b
infixl 4 $>

-- | Return the contents of a <a>Right</a>-value or a default value
--   otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; fromRight 1 (Right 3)
--   3
--   
--   &gt;&gt;&gt; fromRight 1 (Left "foo")
--   1
--   </pre>
fromRight :: b -> Either a b -> b

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
--   
--   <h4><b>Examples</b></h4>
--   
--   Basic usage:
--   
--   <pre>
--   &gt;&gt;&gt; isRight (Left "foo")
--   False
--   
--   &gt;&gt;&gt; isRight (Right 3)
--   True
--   </pre>
--   
--   Assuming a <a>Left</a> value signifies some sort of error, we can use
--   <a>isRight</a> to write a very simple reporting function that only
--   outputs "SUCCESS" when a computation has succeeded.
--   
--   This example shows how <a>isRight</a> might be used to avoid pattern
--   matching when one does not care about the value contained in the
--   constructor:
--   
--   <pre>
--   &gt;&gt;&gt; import Control.Monad ( when )
--   
--   &gt;&gt;&gt; let report e = when (isRight e) $ putStrLn "SUCCESS"
--   
--   &gt;&gt;&gt; report (Left "parse error")
--   
--   &gt;&gt;&gt; report (Right 1)
--   SUCCESS
--   </pre>
isRight :: Either a b -> Bool

-- | <tt><a>void</a> value</tt> discards or ignores the result of
--   evaluation, such as the return value of an <a>IO</a> action.
--   
--   Using <tt>ApplicativeDo</tt>: '<tt><a>void</a> as</tt>' can be
--   understood as the <tt>do</tt> expression
--   
--   <pre>
--   do as
--      pure ()
--   </pre>
--   
--   with an inferred <tt>Functor</tt> constraint.
--   
--   <h4><b>Examples</b></h4>
--   
--   Replace the contents of a <tt><a>Maybe</a> <a>Int</a></tt> with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void Nothing
--   Nothing
--   
--   &gt;&gt;&gt; void (Just 3)
--   Just ()
--   </pre>
--   
--   Replace the contents of an <tt><a>Either</a> <a>Int</a>
--   <a>Int</a></tt> with unit, resulting in an <tt><a>Either</a>
--   <a>Int</a> <tt>()</tt></tt>:
--   
--   <pre>
--   &gt;&gt;&gt; void (Left 8675309)
--   Left 8675309
--   
--   &gt;&gt;&gt; void (Right 8675309)
--   Right ()
--   </pre>
--   
--   Replace every element of a list with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void [1,2,3]
--   [(),(),()]
--   </pre>
--   
--   Replace the second element of a pair with unit:
--   
--   <pre>
--   &gt;&gt;&gt; void (1,2)
--   (1,())
--   </pre>
--   
--   Discard the result of an <a>IO</a> action:
--   
--   <pre>
--   &gt;&gt;&gt; mapM print [1,2]
--   1
--   2
--   [(),()]
--   
--   &gt;&gt;&gt; void $ mapM print [1,2]
--   1
--   2
--   </pre>
void :: Functor f => f a -> f ()

-- | Makes an effectful function ignore its result value and return its
--   input value.
through :: Functor f => (a -> f b) -> a -> f a

-- | The function <tt>coerce</tt> allows you to safely convert between
--   values of types that have the same representation with no run-time
--   overhead. In the simplest case you can use it instead of a newtype
--   constructor, to go from the newtype's concrete type to the abstract
--   type. But it also works in more complicated settings, e.g. converting
--   a list of newtypes to a list of concrete types.
--   
--   This function is runtime-representation polymorphic, but the
--   <tt>RuntimeRep</tt> type argument is marked as <tt>Inferred</tt>,
--   meaning that it is not available for visible type application. This
--   means the typechecker will accept <tt>coerce @Int @Age 42</tt>.
coerce :: forall (k :: RuntimeRep) (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a

-- | A class of types that can be fully evaluated.
class NFData a

-- | Type representing arbitrary-precision non-negative integers.
--   
--   <pre>
--   &gt;&gt;&gt; 2^100 :: Natural
--   1267650600228229401496703205376
--   </pre>
--   
--   Operations whose result would be negative <tt><a>throw</a>
--   (<a>Underflow</a> :: <a>ArithException</a>)</tt>,
--   
--   <pre>
--   &gt;&gt;&gt; -1 :: Natural
--   *** Exception: arithmetic underflow
--   </pre>
data Natural

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|

-- | 8-bit unsigned integer type
data Word8

-- | A monoid on applicative functors.
--   
--   If defined, <a>some</a> and <a>many</a> should be the least solutions
--   of the equations:
--   
--   <ul>
--   <li><pre><a>some</a> v = (:) <a>&lt;$&gt;</a> v <a>&lt;*&gt;</a>
--   <a>many</a> v</pre></li>
--   <li><pre><a>many</a> v = <a>some</a> v <a>&lt;|&gt;</a> <a>pure</a>
--   []</pre></li>
--   </ul>
class Applicative f => Alternative (f :: Type -> Type)

-- | The identity of <a>&lt;|&gt;</a>
empty :: Alternative f => f a

-- | An associative binary operation
(<|>) :: Alternative f => f a -> f a -> f a

-- | One or more.
some :: Alternative f => f a -> f [a]

-- | Zero or more.
many :: Alternative f => f a -> f [a]
infixl 3 <|>

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
newtype PairT b f a
PairT :: f (b, a) -> PairT b f a
[unPairT] :: PairT b f a -> f (b, a)

-- | <tt>Coercible</tt> is a two-parameter class that has instances for
--   types <tt>a</tt> and <tt>b</tt> if the compiler can infer that they
--   have the same representation. This class does not have regular
--   instances; instead they are created on-the-fly during type-checking.
--   Trying to manually declare an instance of <tt>Coercible</tt> is an
--   error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance Coercible a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class a ~R# b => Coercible (a :: k) (b :: k)

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
type Lens' s a = Lens s s a a
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
(^.) :: s -> Getting a s a -> a
view :: MonadReader s m => Getting a s a -> m a
(.~) :: ASetter s t a b -> b -> s -> t
set :: ASetter s t a b -> b -> s -> t
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | Like <a>traceShow</a> but returns the shown value instead of a third
--   value.
--   
--   <pre>
--   &gt;&gt;&gt; traceShowId (1+2+3, "hello" ++ "world")
--   (6,"helloworld")
--   (6,"helloworld")
--   </pre>
traceShowId :: Show a => a -> a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   &gt;&gt;&gt; let x = 123; f = show
--   
--   &gt;&gt;&gt; trace ("calling f with x = " ++ show x) (f x)
--   "calling f with x = 123
--   123"
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a
(.*) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
(<<$>>) :: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<$>>
(<<*>>) :: (Applicative f1, Applicative f2) => f1 (f2 (a -> b)) -> f1 (f2 a) -> f1 (f2 b)
infixl 4 <<*>>
mtraverse :: (Monad m, Traversable m, Applicative f) => (a -> f (m b)) -> m a -> f (m b)

-- | Fold a monadic function over a <a>Foldable</a>. The monadic version of
--   <a>foldMap</a>.
foldMapM :: (Foldable f, Monad m, Monoid b) => (a -> m b) -> f a -> m b

-- | This function generalizes <tt>eitherToMaybe</tt>,
--   <tt>eitherToList</tt>, <tt>listToMaybe</tt> and other such functions.
reoption :: (Foldable f, Alternative g) => f a -> g a
enumeration :: (Bounded a, Enum a) => [a]

-- | Basically a <tt>Data.Functor.Representable</tt> instance for
--   <a>Array</a>. We can't provide an actual instance because of the
--   <tt>Distributive</tt> superclass: <tt>Array i</tt> is not
--   <tt>Distributive</tt> unless we assume that indices in an array range
--   over the entirety of <tt>i</tt>.
tabulateArray :: (Bounded i, Enum i, Ix i) => (i -> a) -> Array i a

-- | <tt>b ? x</tt> is equal to <tt>pure x</tt> whenever <tt>b</tt> holds
--   and is <a>empty</a> otherwise.
(?) :: Alternative f => Bool -> a -> f a
infixr 2 ?

-- | <tt>ensure p x</tt> is equal to <tt>pure x</tt> whenever <tt>p x</tt>
--   holds and is <a>empty</a> otherwise.
ensure :: Alternative f => (a -> Bool) -> a -> f a

-- | A monadic version of <a>asks</a>.
asksM :: MonadReader r m => (r -> m a) -> m a
data Doc ann

-- | A newtype wrapper around <tt>a</tt> whose point is to provide a
--   <a>Show</a> instance for anything that has a <a>Pretty</a> instance.
newtype ShowPretty a
ShowPretty :: a -> ShowPretty a
[unShowPretty] :: ShowPretty a -> a
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann
type family HasPrettyDefaults config :: Bool
type PrettyDefaultBy config = DispatchPrettyDefaultBy NonStuckHasPrettyDefaults config config
newtype PrettyAny a
PrettyAny :: a -> PrettyAny a
[unPrettyAny] :: PrettyAny a -> a
class Render str
render :: Render str => Doc ann -> str
display :: forall str a. (Pretty a, Render str) => a -> str

-- | A command suitable for use in GHCi as an interactive printer.
printPretty :: Pretty a => a -> IO ()
showText :: Show a => a -> Text
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusPrelude.ShowPretty a)
instance Text.PrettyBy.Internal.PrettyDefaultBy config (Data.Either.Either a b) => Text.PrettyBy.Internal.PrettyBy config (Data.Either.Either a b)
instance GHC.Base.Functor f => GHC.Base.Functor (PlutusPrelude.PairT b f)
instance Prettyprinter.Internal.Pretty a => GHC.Show.Show (PlutusPrelude.ShowPretty a)
instance (Prettyprinter.Internal.Pretty a, Prettyprinter.Internal.Pretty b) => Prettyprinter.Internal.Pretty (Data.Either.Either a b)
instance (Text.PrettyBy.Internal.PrettyBy config a, Text.PrettyBy.Internal.PrettyBy config b) => Text.PrettyBy.Internal.DefaultPrettyBy config (Data.Either.Either a b)

module PlutusCore.Name

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name
Name :: Text -> Unique -> Name

-- | The identifier name, for use in error messages.
[nameString] :: Name -> Text

-- | A <a>Unique</a> assigned to the name, allowing for cheap comparisons
--   in the compiler.
[nameUnique] :: Name -> Unique

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName
TyName :: Name -> TyName
[unTyName] :: TyName -> Name

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int

-- | The unique of a type-level name.
newtype TypeUnique
TypeUnique :: Unique -> TypeUnique
[unTypeUnique] :: TypeUnique -> Unique

-- | The unique of a term-level name.
newtype TermUnique
TermUnique :: Unique -> TermUnique
[unTermUnique] :: TermUnique -> Unique

-- | Types which have a <a>Unique</a> attached to them, mostly names.
class Coercible unique Unique => HasUnique a unique | a -> unique

-- | The default implementation of <a>HasUnique</a> for newtypes.
unique :: HasUnique a unique => Lens' a unique

-- | The default implementation of <a>HasUnique</a> for newtypes.
unique :: (HasUnique a unique, Wrapped a, HasUnique (Unwrapped a) unique', Coercible unique' unique) => Lens' a unique

-- | A lens focused on the <a>Unique</a> of a name.
theUnique :: HasUnique name unique => Lens' name Unique

-- | A mapping from uniques to values of type <tt>a</tt>.
newtype UniqueMap unique a
UniqueMap :: IntMap a -> UniqueMap unique a
[unUniqueMap] :: UniqueMap unique a -> IntMap a

-- | Insert a value by a unique.
insertByUnique :: Coercible unique Unique => unique -> a -> UniqueMap unique a -> UniqueMap unique a

-- | Insert a value by the unique of a name.
insertByName :: HasUnique name unique => name -> a -> UniqueMap unique a -> UniqueMap unique a

-- | Insert a value by the index of the unique of a name. Unlike
--   <a>insertByUnique</a> and <a>insertByName</a>, this function does not
--   provide any static guarantees, so you can for example insert by a
--   type-level name in a map from term-level uniques.
insertByNameIndex :: (HasUnique name unique1, Coercible unique2 Unique) => name -> a -> UniqueMap unique2 a -> UniqueMap unique2 a

-- | Convert a <a>Foldable</a> into a <a>UniqueMap</a> using the given
--   insertion function.
fromFoldable :: Foldable f => (i -> a -> UniqueMap unique a -> UniqueMap unique a) -> f (i, a) -> UniqueMap unique a

-- | Convert a <a>Foldable</a> with uniques into a <a>UniqueMap</a>.
fromUniques :: Foldable f => Coercible Unique unique => f (unique, a) -> UniqueMap unique a

-- | Convert a <a>Foldable</a> with names into a <a>UniqueMap</a>.
fromNames :: Foldable f => HasUnique name unique => f (name, a) -> UniqueMap unique a

-- | Look up a value by a unique.
lookupUnique :: Coercible unique Unique => unique -> UniqueMap unique a -> Maybe a

-- | Look up a value by the unique of a name.
lookupName :: HasUnique name unique => name -> UniqueMap unique a -> Maybe a

-- | Look up a value by the index of the unique of a name. Unlike
--   <a>lookupUnique</a> and <a>lookupName</a>, this function does not
--   provide any static guarantees, so you can for example look up a
--   type-level name in a map from term-level uniques.
lookupNameIndex :: (HasUnique name unique1, Coercible unique2 Unique) => name -> UniqueMap unique2 a -> Maybe a

-- | Apply a function to the string representation of a <a>Name</a>.
mapNameString :: (Text -> Text) -> Name -> Name

-- | Apply a function to the string representation of a <a>TyName</a>.
mapTyNameString :: (Text -> Text) -> TyName -> TyName
instance Data.Hashable.Class.Hashable PlutusCore.Name.Unique
instance Prettyprinter.Internal.Pretty PlutusCore.Name.Unique
instance Control.DeepSeq.NFData PlutusCore.Name.Unique
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Name.Unique
instance GHC.Enum.Enum PlutusCore.Name.Unique
instance GHC.Classes.Ord PlutusCore.Name.Unique
instance GHC.Show.Show PlutusCore.Name.Unique
instance GHC.Classes.Eq PlutusCore.Name.Unique
instance Data.Hashable.Class.Hashable PlutusCore.Name.Name
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Name.Name
instance Control.DeepSeq.NFData PlutusCore.Name.Name
instance GHC.Generics.Generic PlutusCore.Name.Name
instance GHC.Show.Show PlutusCore.Name.Name
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.Name.TyName
instance Data.Hashable.Class.Hashable PlutusCore.Name.TyName
instance Control.DeepSeq.NFData PlutusCore.Name.TyName
instance GHC.Classes.Ord PlutusCore.Name.TyName
instance GHC.Classes.Eq PlutusCore.Name.TyName
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Name.TyName
instance GHC.Generics.Generic PlutusCore.Name.TyName
instance GHC.Show.Show PlutusCore.Name.TyName
instance Data.Hashable.Class.Hashable PlutusCore.Name.TypeUnique
instance GHC.Classes.Ord PlutusCore.Name.TypeUnique
instance GHC.Classes.Eq PlutusCore.Name.TypeUnique
instance Data.Hashable.Class.Hashable PlutusCore.Name.TermUnique
instance GHC.Classes.Ord PlutusCore.Name.TermUnique
instance GHC.Classes.Eq PlutusCore.Name.TermUnique
instance GHC.Base.Functor (PlutusCore.Name.UniqueMap unique)
instance GHC.Base.Monoid (PlutusCore.Name.UniqueMap unique a)
instance GHC.Base.Semigroup (PlutusCore.Name.UniqueMap unique a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Name.UniqueMap unique a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Name.UniqueMap unique a)
instance PlutusCore.Name.HasUnique PlutusCore.Name.Unique PlutusCore.Name.Unique
instance PlutusCore.Name.HasUnique PlutusCore.Name.Name PlutusCore.Name.TermUnique
instance PlutusCore.Name.HasUnique PlutusCore.Name.TyName PlutusCore.Name.TypeUnique
instance Control.Lens.Wrapped.Wrapped PlutusCore.Name.TyName
instance PlutusCore.Pretty.ConfigName.HasPrettyConfigName config => Text.PrettyBy.Internal.PrettyBy config PlutusCore.Name.Name
instance GHC.Classes.Eq PlutusCore.Name.Name
instance GHC.Classes.Ord PlutusCore.Name.Name

module PlutusCore.Quote

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: Monad m => QuoteT m a -> m a

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: MonadQuote m => Text -> m Name

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: MonadQuote m => Text -> m TyName

-- | Make a copy of the given <a>Name</a> that is distinct from the old
--   one.
freshenName :: MonadQuote m => Name -> m Name

-- | Make a copy of the given <a>TyName</a> that is distinct from the old
--   one.
freshenTyName :: MonadQuote m => TyName -> m TyName

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
newtype QuoteT m a
QuoteT :: StateT FreshState m a -> QuoteT m a
[unQuoteT] :: QuoteT m a -> StateT FreshState m a

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m

-- | The state contains the "next" <a>Unique</a> that should be used for a
--   name
type FreshState = Unique
liftQuote :: MonadQuote m => Quote a -> m a

-- | Mark a all <a>Unique</a>s less than the given <a>Unique</a> as used,
--   so they will not be generated in future.
markNonFreshBelow :: MonadQuote m => Unique -> m ()

-- | Mark a given <a>Unique</a> (and implicitly all <a>Unique</a>s less
--   than it) as used, so they will not be generated in future.
markNonFresh :: MonadQuote m => Unique -> m ()

-- | Mark the maximal <a>Unique</a> from a set of <a>Unique</a>s (and
--   implicitly all <a>Unique</a>s less than it) as used, so they will not
--   be generated in future.
markNonFreshMax :: MonadQuote m => Set Unique -> m ()
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (PlutusCore.Quote.QuoteT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (PlutusCore.Quote.QuoteT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (PlutusCore.Quote.QuoteT m)
instance Control.Monad.Morph.MFunctor PlutusCore.Quote.QuoteT
instance Control.Monad.Trans.Class.MonadTrans PlutusCore.Quote.QuoteT
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (PlutusCore.Quote.QuoteT m)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Quote.QuoteT m)
instance GHC.Base.Monad m => PlutusCore.Quote.MonadQuote (PlutusCore.Quote.QuoteT m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.State.Lazy.StateT s m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Maybe.MaybeT m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Except.ExceptT e m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Control.Monad.Trans.Reader.ReaderT r m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Gen.GenT m)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (Hedgehog.Internal.Property.PropertyT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (PlutusCore.Quote.QuoteT m)


-- | The monad that the renamer runs in and related infrastructure.
module PlutusCore.Rename.Monad

-- | The monad the renamer runs in.
newtype RenameT ren m a
RenameT :: ReaderT ren m a -> RenameT ren m a
[unRenameT] :: RenameT ren m a -> ReaderT ren m a
type ScopedRenameT = RenameT ScopedRenaming

-- | A renaming is a mapping from old uniques to new ones.
newtype Renaming unique
Renaming :: UniqueMap unique unique -> Renaming unique
[unRenaming] :: Renaming unique -> UniqueMap unique unique

-- | A type-level renaming. Needed for instantiating functions running over
--   types in generic <tt>RenameT ren m</tt> to a particular type of
--   renaming.
type TypeRenaming = Renaming TypeUnique

-- | Scoping-aware mapping from locally unique uniques to globally unique
--   uniques.
data ScopedRenaming
ScopedRenaming :: Renaming TypeUnique -> Renaming TermUnique -> ScopedRenaming
[_scopedRenamingTypes] :: ScopedRenaming -> Renaming TypeUnique
[_scopedRenamingTerms] :: ScopedRenaming -> Renaming TermUnique

-- | A class that specifies which <a>Renaming</a> a <tt>ren</tt> has
--   inside. A <tt>ren</tt> can contain several <a>Renaming</a>s (like
--   <tt>Scoped</tt>, for example).
class Coercible unique Unique => HasRenaming ren unique
renaming :: HasRenaming ren unique => Lens' ren (Renaming unique)
scopedRenamingTypes :: Lens' ScopedRenaming (Renaming TypeUnique)
scopedRenamingTerms :: Lens' ScopedRenaming (Renaming TermUnique)

-- | Run a <a>RenameT</a> computation with an empty renaming.
runRenameT :: Monoid ren => RenameT ren m a -> m a

-- | Look up the new unique a name got mapped to.
lookupNameM :: (HasUnique name unique, HasRenaming ren unique, Monad m) => name -> RenameT ren m (Maybe unique)

-- | Rename a name that has a unique inside.
renameNameM :: (HasRenaming ren unique, HasUnique name unique, Monad m) => name -> RenameT ren m name

-- | Replace the unique in a name by a new unique, save the mapping from
--   the old unique to the new one and supply the updated value to a
--   continuation.
withFreshenedName :: (HasRenaming ren unique, HasUnique name unique, MonadQuote m) => name -> (name -> RenameT ren m c) -> RenameT ren m c

-- | Run a <a>RenameT</a> computation in the environment extended by the
--   mapping from an old name to a new one.
withRenamedName :: (HasRenaming ren unique, HasUnique name unique, Monad m) => name -> name -> RenameT ren m c -> RenameT ren m c
instance GHC.Base.Semigroup PlutusCore.Rename.Monad.ScopedRenaming
instance GHC.Base.Monoid PlutusCore.Rename.Monad.ScopedRenaming
instance (GHC.Types.Coercible unique1 PlutusCore.Name.Unique, unique1 GHC.Types.~ unique2) => PlutusCore.Rename.Monad.HasRenaming (PlutusCore.Rename.Monad.Renaming unique1) unique2
instance PlutusCore.Rename.Monad.HasRenaming PlutusCore.Rename.Monad.ScopedRenaming PlutusCore.Name.TypeUnique
instance PlutusCore.Rename.Monad.HasRenaming PlutusCore.Rename.Monad.ScopedRenaming PlutusCore.Name.TermUnique
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader ren (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Rename.Monad.RenameT ren m)
instance GHC.Base.Monoid (PlutusCore.Rename.Monad.Renaming unique)
instance GHC.Base.Semigroup (PlutusCore.Rename.Monad.Renaming unique)

module PlutusCore.Generators.NEAT.Common
data Z
data S n
FZ :: S n
FS :: n -> S n

-- | Absurd for the zero type.
fromZ :: Z -> a
data NameState n
NameState :: (n -> Name) -> Stream Text -> NameState n
[nameOf] :: NameState n -> n -> Name
[freshNameStrings] :: NameState n -> Stream Text
newtype TyNameState n
TyNameState :: NameState n -> TyNameState n
tynameOf :: TyNameState n -> n -> TyName

-- | Create an empty name state from a stream of text names.
emptyNameState :: Stream Text -> NameState Z

-- | Extend name state with a fresh name.
extNameState :: MonadQuote m => NameState n -> m (NameState (S n))

-- | Create an empty name state from a stream of text names.
emptyTyNameState :: Stream Text -> TyNameState Z

-- | Extend type name state with a fresh type name.
extTyNameState :: MonadQuote m => TyNameState n -> m (TyNameState (S n))

-- | Create a stream of names |x0, x1, x2, ...| from a prefix |"x"|
mkTextNameStream :: Text -> Stream Text
instance GHC.Show.Show PlutusCore.Generators.NEAT.Common.Z
instance GHC.Classes.Ord PlutusCore.Generators.NEAT.Common.Z
instance GHC.Classes.Eq PlutusCore.Generators.NEAT.Common.Z
instance GHC.Base.Functor PlutusCore.Generators.NEAT.Common.S
instance GHC.Show.Show n => GHC.Show.Show (PlutusCore.Generators.NEAT.Common.S n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PlutusCore.Generators.NEAT.Common.S n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PlutusCore.Generators.NEAT.Common.S n)
instance Control.Enumerable.Enumerable n => Control.Enumerable.Enumerable (PlutusCore.Generators.NEAT.Common.S n)
instance Control.Enumerable.Enumerable PlutusCore.Generators.NEAT.Common.Z

module Common

-- | A <a>TestTree</a> of tests under some name prefix.
type TestNested = Reader [String] TestTree

-- | Run a <a>TestTree</a> of tests with a given name prefix.
runTestNestedIn :: [String] -> TestNested -> TestTree

-- | Run a <a>TestTree</a> of tests with an empty prefix.
runTestNested :: TestNested -> TestTree

-- | Descend into a name prefix.
testNested :: String -> [TestNested] -> TestNested

-- | Check the contents of a file against a <a>Text</a>.
goldenVsText :: TestName -> FilePath -> Text -> TestTree

-- | Check the contents of a file against a <a>Text</a>.
goldenVsTextM :: TestName -> FilePath -> IO Text -> TestTree

-- | Check the contents of a file against a <a>Doc</a>.
goldenVsDoc :: TestName -> FilePath -> Doc ann -> TestTree

-- | Check the contents of a file against a <a>Doc</a>.
goldenVsDocM :: TestName -> FilePath -> IO (Doc ann) -> TestTree

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsText :: TestName -> Text -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsTextM :: TestName -> IO Text -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsDoc :: TestName -> Doc ann -> TestNested

-- | Check the contents of a file under a name prefix against a
--   <a>Text</a>.
nestedGoldenVsDocM :: TestName -> IO (Doc ann) -> TestNested

module Universe

-- | "Escapes" a type of an arbitrary kind to fit into <a>Type</a>.
data Esc a
data Some (tag :: k -> Type)
pattern Some :: forall k tag (a :: k). () => tag a -> Some tag

-- | A particular type from a universe.
data SomeTypeIn uni
SomeTypeIn :: !uni (Esc a) -> SomeTypeIn uni
data Kinded uni ta
[Kinded] :: Typeable k => !uni (Esc a) -> Kinded uni (Esc (a :: k))

-- | A value of a particular type from a universe.
data ValueOf uni a
ValueOf :: !uni (Esc a) -> !a -> ValueOf uni a

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, given its explicit type
--   tag.
someValueOf :: forall a uni. uni (Esc a) -> a -> Some (ValueOf uni)

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, provided its type is in
--   the universe.
someValue :: forall a uni. uni `Includes` a => a -> Some (ValueOf uni)

-- | A class for enumerating types and fully instantiated type formers that
--   <tt>uni</tt> contains. For example, a particular <tt>ExampleUni</tt>
--   may have monomorphic types in it:
--   
--   instance ExampleUni <a>Contains</a> Integer where <a>...</a> instance
--   ExampleUni <a>Contains</a> Bool where <a>...</a>
--   
--   as well as polymorphic ones:
--   
--   instance ExampleUni <a>Contains</a> [] where <a>...</a> instance
--   ExampleUni <a>Contains</a> (,) where <a>...</a>
--   
--   as well as their instantiations:
--   
--   instance ExampleUni <a>Contains</a> a =&gt; ExampleUni <a>Contains</a>
--   [a] where <a>...</a> instance (ExampleUni <a>Contains</a> a,
--   ExampleUni <a>Contains</a> b) =&gt; ExampleUni <a>Contains</a> (a, b)
--   where <a>...</a>
--   
--   (a universe can have any subset of the mentioned sorts of types, for
--   example it's fine to have instantiated polymorphic types and not have
--   uninstantiated ones and vice versa)
--   
--   Note that when used as a constraint of a function <a>Contains</a> does
--   not allow you to directly express things like "<tt>uni</tt> has the
--   <tt>Integer</tt>, <tt>Bool</tt> and <tt>[]</tt> types and type
--   formers", because <tt>[]</tt> is not fully instantiated. So you can
--   only say "<tt>uni</tt> has <tt>Integer</tt>, <tt>Bool</tt>,
--   <tt>[Integer]</tt>, <tt>[Bool]</tt>, <tt>[[Integer]]</tt>,
--   <tt>[[Bool]]</tt> etc" and such manual enumeration is annoying, so
--   we'd really like to be able to say that <tt>uni</tt> has lists of
--   arbitrary built-in types (including lists of lists etc).
--   <a>Contains</a> does not allow that, but <a>Includes</a> does. For
--   example, in the body of the following definition:
--   
--   foo :: (uni <a>Includes</a> Integer, uni <a>Includes</a> Bool, uni
--   <a>Includes</a> []) =&gt; <a>...</a> foo = <a>...</a>
--   
--   you can make use of the fact that <tt>uni</tt> has lists of arbitrary
--   included types (integers, booleans and lists).
--   
--   Hence most of the time opt for using the more flexible
--   <a>Includes</a>.
--   
--   <a>Includes</a> is defined in terms of <a>Contains</a>, so you only
--   need to provide a <a>Contains</a> instance per type from the universe
--   and you'll get <a>Includes</a> for free.
class uni `Contains` a
knownUni :: Contains uni a => uni (Esc a)

-- | <tt>uni <a>Includes</a> a</tt> reads as "<tt>a</tt> is in the
--   <tt>uni</tt>". <tt>a</tt> can be of a higher-kind, see the docs of
--   <a>Contains</a> on why you might want that.
type Includes uni = Permits (Contains uni)

-- | A monad to decode types from a universe in. We use a monad for
--   decoding, because parsing arguments of polymorphic built-in types can
--   peel off an arbitrary amount of type tags from the input list of tags
--   and so we have state, which is convenient to handle with, well,
--   <a>StateT</a>.
newtype DecodeUniM a
DecodeUniM :: StateT [Int] Maybe a -> DecodeUniM a
[unDecodeUniM] :: DecodeUniM a -> StateT [Int] Maybe a

-- | A universe is <a>Closed</a>, if it's known how to constrain every type
--   from the universe and every type can be encoded to / decoded from a
--   sequence of integer tags. The universe doesn't have to be finite and
--   providing support for infinite universes is the reason why we encode a
--   type as a sequence of integer tags as opposed to a single integer tag.
--   For example, given
--   
--   <pre>
--   data U a where
--       UList :: !(U a) -&gt; U [a]
--       UInt  :: U Int
--   </pre>
--   
--   <tt>UList (UList UInt)</tt> can be encoded to <tt>[0,0,1]</tt> where
--   <tt>0</tt> and <tt>1</tt> are the integer tags of the <tt>UList</tt>
--   and <tt>UInt</tt> constructors, respectively.
class Closed uni where {
    
    -- | A constrant for "<tt>constr a</tt> holds for any <tt>a</tt> from
    --   <tt>uni</tt>".
    type family Everywhere uni (constr :: Type -> Constraint) :: Constraint;
}

-- | Encode a type as a sequence of <a>Int</a> tags. The opposite of
--   <tt>decodeUni</tt>.
encodeUni :: Closed uni => uni a -> [Int]

-- | Decode a type and feed it to the continuation.
withDecodedUni :: Closed uni => (forall k (a :: k). Typeable k => uni (Esc a) -> DecodeUniM r) -> DecodeUniM r

-- | Bring a <tt>constr a</tt> instance in scope, provided <tt>a</tt> is a
--   type from the universe and <tt>constr</tt> holds for any type from the
--   universe.
bring :: (Closed uni, uni `Everywhere` constr) => proxy constr -> uni (Esc a) -> (constr a => r) -> r

-- | Decode a type from a sequence of <a>Int</a> tags. The opposite of
--   <a>encodeUni</a> (modulo invalid input).
decodeKindedUni :: Closed uni => [Int] -> Maybe (SomeTypeIn (Kinded uni))

-- | Peel off a tag from the input list of type tags.
peelUniTag :: DecodeUniM Int

-- | <tt>constr <a>Permits</a> f</tt> elaborates to one of - constr f
--   forall a. constr a =&gt; constr (f a) forall a b. (constr a, constr b)
--   =&gt; constr (f a b) forall a b c. (constr a, constr b, constr c)
--   =&gt; constr (f a b c)
--   
--   depending on the kind of <tt>f</tt>. This allows us to say things like
--   
--   ( constr <a>Permits</a> Integer , constr <a>Permits</a> [] , constr
--   <a>Permits</a> (,) )
--   
--   and thus constraint every type from the universe (including
--   polymorphic ones) to satisfy <tt>constr</tt>, which is how we provide
--   an implementation of <a>Everywhere</a> for universes with polymorphic
--   types.
--   
--   <a>Permits</a> is an open type family, so you can provide type
--   instances for <tt>f</tt>s expecting more type arguments than 3 if you
--   need that.
--   
--   Note that, say, <tt>constr <a>Permits</a> []</tt> elaborates to
--   
--   forall a. constr a =&gt; constr [a]
--   
--   and for certain type classes that does not make sense (e.g. the
--   <tt>Generic</tt> instance of <tt>[]</tt> does not require the type of
--   elements to be <tt>Generic</tt>), however it's not a problem because
--   we use <tt>Permit</tt> to constrain the whole universe and so we know
--   that arguments of polymorphic built-in types are builtins themselves
--   are hence do satisfy the constraint and the fact that these
--   constraints on arguments do not get used in the polymorphic case only
--   means that they get ignored.
type family Permits
type family uni `EverywhereAll` constrs

-- | A constraint for "<tt>uni1</tt> is a subuniverse of <tt>uni2</tt>".
type uni1 <: uni2 = uni1 `Everywhere` Includes uni2

-- | A class for "<tt>uni</tt> has general type application".
class HasUniApply (uni :: Type -> Type)

-- | Deconstruct a type application into the function and the argument and
--   feed them to the continuation. If the type is not an application, then
--   return the default value.
matchUniApply :: HasUniApply uni => uni tb -> r -> (forall k l (f :: k -> l) a. tb ~ Esc (f a) => uni (Esc f) -> uni (Esc a) -> r) -> r

-- | Check if the kind of the given type from the universe is <a>Type</a>.
checkStar :: forall uni a (x :: a). Typeable a => uni (Esc x) -> Maybe (a :~: Type)

-- | Check if one type from the universe can be applied to another (i.e.
--   check that the expected kind of the argument matches the actual one)
--   and call the continuation in the refined context. Fail with
--   <a>mzero</a> otherwise.
withApplicable :: forall (a :: Type) (ab :: Type) f x uni m r. (Typeable ab, Typeable a, MonadPlus m) => uni (Esc (f :: ab)) -> uni (Esc (x :: a)) -> (forall (b :: Type). (Typeable b, ab ~ (a -> b)) => m r) -> m r

-- | Same as <a>knownUni</a>, but receives a <tt>proxy</tt>.
knownUniOf :: uni `Contains` a => proxy a -> uni (Esc a)
class GShow (t :: k -> Type)
gshowsPrec :: forall (a :: k). GShow t => Int -> t a -> ShowS
gshow :: forall k t (a :: k). GShow t => t a -> String
class GEq (f :: k -> Type)
geq :: forall (a :: k) (b :: k). GEq f => f a -> f b -> Maybe (a :~: b)
deriveGEq :: DeriveGEQ t => t -> Q [Dec]

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall k (a :: k). a :~: a
infix 4 :~:

module PlutusCore.Pretty
data Doc ann
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann
class PrettyBy config a
prettyBy :: PrettyBy config a => config -> a -> Doc ann
prettyListBy :: PrettyBy config a => config -> [a] -> Doc ann
newtype IgnorePrettyConfig a
IgnorePrettyConfig :: a -> IgnorePrettyConfig a
[unIgnorePrettyConfig] :: IgnorePrettyConfig a -> a
data AttachPrettyConfig config a
AttachPrettyConfig :: !config -> !a -> AttachPrettyConfig config a
class Render str
render :: Render str => Doc ann -> str
display :: forall str a. (Pretty a, Render str) => a -> str
displayBy :: forall str a config. (PrettyBy config a, Render str) => config -> a -> str

-- | Pretty-print a value in the default mode using the classic view.
prettyPlcDef :: PrettyPlc a => a -> Doc ann

-- | Render a value to <a>String</a> in the default mode using the classic
--   view.
displayPlcDef :: (PrettyPlc a, Render str) => a -> str

-- | Whether to pretty-print PLC errors in full or with some information
--   omitted.
data CondensedErrors
CondensedErrorsYes :: CondensedErrors
CondensedErrorsNo :: CondensedErrors

-- | Options for pretty-printing PLC entities.
newtype PrettyConfigPlcOptions
PrettyConfigPlcOptions :: CondensedErrors -> PrettyConfigPlcOptions
[_pcpoCondensedErrors] :: PrettyConfigPlcOptions -> CondensedErrors

-- | Strategy for pretty-printing PLC entities.
data PrettyConfigPlcStrategy
PrettyConfigPlcClassic :: PrettyConfigClassic PrettyConfigName -> PrettyConfigPlcStrategy
PrettyConfigPlcReadable :: PrettyConfigReadable PrettyConfigName -> PrettyConfigPlcStrategy

-- | Global configuration used for pretty-printing PLC entities.
data PrettyConfigPlc
PrettyConfigPlc :: PrettyConfigPlcOptions -> PrettyConfigPlcStrategy -> PrettyConfigPlc
[_pcpOptions] :: PrettyConfigPlc -> PrettyConfigPlcOptions
[_pcpStrategy] :: PrettyConfigPlc -> PrettyConfigPlcStrategy

-- | The "pretty-printable PLC entity" constraint.
type PrettyPlc = PrettyBy PrettyConfigPlc

-- | The <a>PrettyConfigPlcOptions</a> used by default: print errors in
--   full.
defPrettyConfigPlcOptions :: PrettyConfigPlcOptions

-- | The <a>PrettyConfigPlc</a> used by default: use the classic view and
--   print neither <tt>Unique</tt>s, nor name attachments.
defPrettyConfigPlcClassic :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging: use the classic view
--   and print <tt>Unique</tt>s, but not name attachments.
debugPrettyConfigPlcClassic :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used by default and for readability: use
--   the refined view and print neither <tt>Unique</tt>s, nor name
--   attachments.
defPrettyConfigPlcReadable :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | The <a>PrettyConfigPlc</a> used for debugging and readability: use the
--   refined view and print <tt>Unique</tt>s, but not name attachments.
debugPrettyConfigPlcReadable :: PrettyConfigPlcOptions -> PrettyConfigPlc

-- | Pretty-print a PLC value in the default mode using the classic view.
prettyPlcClassicDef :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the debug mode using the classic view.
prettyPlcClassicDebug :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the default mode using the readable view.
prettyPlcReadableDef :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value in the debug mode using the readable view.
prettyPlcReadableDebug :: PrettyPlc a => a -> Doc ann

-- | Pretty-print a PLC value using the condensed way (see
--   <a>CondensedErrors</a>) of pretty-printing PLC errors (in case there
--   are any).
prettyPlcCondensedErrorBy :: PrettyPlc a => (PrettyConfigPlcOptions -> PrettyConfigPlc) -> a -> Doc ann

-- | Render an error to <a>String</a> in the condensed manner using the
--   classic view.
displayPlcCondensedErrorClassic :: (PrettyPlc a, Render str) => a -> str

-- | A config that determines how to pretty-print a PLC name.
newtype PrettyConfigName
PrettyConfigName :: Bool -> PrettyConfigName

-- | Whether to show the <tt>Unique</tt> of a name or not.
[_pcnShowsUnique] :: PrettyConfigName -> Bool

-- | A class of configs from which a <a>PrettyConfigName</a> can be
--   extracted.
class HasPrettyConfigName config
toPrettyConfigName :: HasPrettyConfigName config => config -> PrettyConfigName

-- | The <a>PrettyConfigName</a> used by default: print neither
--   <tt>Unique</tt>s, nor name attachments.
defPrettyConfigName :: PrettyConfigName

-- | The <a>PrettyConfigName</a> used for debugging: print
--   <tt>Unique</tt>s, but not name attachments.
debugPrettyConfigName :: PrettyConfigName

-- | Configuration for the classic pretty-printing.
newtype PrettyConfigClassic configName
PrettyConfigClassic :: configName -> PrettyConfigClassic configName
[_pccConfigName] :: PrettyConfigClassic configName -> configName

-- | The "classically pretty-printable" constraint.
type PrettyClassicBy configName = PrettyBy (PrettyConfigClassic configName)
type PrettyClassic = PrettyClassicBy PrettyConfigName

-- | Pretty-print a value in the default mode using the classic view.
prettyClassicDef :: PrettyClassic a => a -> Doc ann

-- | Pretty-print a value in the debug mode using the classic view.
prettyClassicDebug :: PrettyClassic a => a -> Doc ann
data ShowKinds
ShowKindsYes :: ShowKinds
ShowKindsNo :: ShowKinds

-- | Configuration for the readable pretty-printing.
data PrettyConfigReadable configName
PrettyConfigReadable :: configName -> RenderContext -> ShowKinds -> PrettyConfigReadable configName
[_pcrConfigName] :: PrettyConfigReadable configName -> configName
[_pcrRenderContext] :: PrettyConfigReadable configName -> RenderContext
[_pcrShowKinds] :: PrettyConfigReadable configName -> ShowKinds

-- | The "readably pretty-printable" constraint.
type PrettyReadableBy configName = PrettyBy (PrettyConfigReadable configName)
type PrettyReadable = PrettyReadableBy PrettyConfigName

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>topFixity</a>.
topPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName

-- | A <a>PrettyConfigReadable</a> with the fixity specified to
--   <a>botFixity</a>.
botPrettyConfigReadable :: configName -> ShowKinds -> PrettyConfigReadable configName
prettyBytes :: ByteString -> Doc ann
data ConstConfig
ConstConfig :: ConstConfig
type PrettyConst = PrettyBy ConstConfig
prettyConst :: PrettyConst a => a -> Doc ann


-- | This module defines a common type various evaluation machine use to
--   return their results.
module PlutusCore.Evaluation.Result

-- | A class for viewing errors as evaluation failures (in the sense of
--   Plutus).
class AsEvaluationFailure err
_EvaluationFailure :: AsEvaluationFailure err => Prism' err ()
evaluationFailure :: AsEvaluationFailure err => err

-- | Construct a <a>Prism</a> focusing on the <tt>*EvaluationFailure</tt>
--   part of <tt>err</tt> by taking that <tt>*EvaluationFailure</tt> and
--   
--   <ol>
--   <li>returning it for the setter part of the prism</li>
--   <li>checking the error for equality with <tt>*EvaluationFailure</tt>
--   for the opposite direction.</li>
--   </ol>
_EvaluationFailureVia :: Eq err => err -> Prism' err ()

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | Check whether an <a>EvaluationResult</a> is an
--   <a>EvaluationSuccess</a>.
isEvaluationSuccess :: EvaluationResult a -> Bool

-- | Check whether an <a>EvaluationResult</a> is an
--   <a>EvaluationFailure</a>.
isEvaluationFailure :: EvaluationResult a -> Bool
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (PlutusCore.Evaluation.Result.EvaluationResult a)
instance Data.Traversable.Traversable PlutusCore.Evaluation.Result.EvaluationResult
instance Data.Foldable.Foldable PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Functor PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Generics.Generic (PlutusCore.Evaluation.Result.EvaluationResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Evaluation.Result.EvaluationResult a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Evaluation.Result.EvaluationResult a)
instance Control.Monad.Error.Class.MonadError () PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Applicative PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Monad PlutusCore.Evaluation.Result.EvaluationResult
instance GHC.Base.Alternative PlutusCore.Evaluation.Result.EvaluationResult
instance Text.PrettyBy.Internal.PrettyBy config a => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.Result.EvaluationResult a)
instance PlutusCore.Pretty.Classic.PrettyClassic a => Prettyprinter.Internal.Pretty (PlutusCore.Evaluation.Result.EvaluationResult a)
instance PlutusCore.Evaluation.Result.AsEvaluationFailure ()


-- | The exceptions that an abstract machine can throw.
module PlutusCore.Evaluation.Machine.Exception

-- | When unlifting of a PLC term into a Haskell value fails, this error is
--   thrown.
newtype UnliftingError
UnliftingErrorE :: Text -> UnliftingError
class AsUnliftingError r_a1eZS
_UnliftingError :: AsUnliftingError r_a1eZS => Prism' r_a1eZS UnliftingError
_UnliftingErrorE :: AsUnliftingError r_a1eZS => Prism' r_a1eZS Text

-- | Errors which can occur during a run of an abstract machine.
data MachineError fun

-- | An attempt to reduce a not immediately reducible type instantiation.
NonPolymorphicInstantiationMachineError :: MachineError fun

-- | An attempt to unwrap a not wrapped term.
NonWrapUnwrappedMachineError :: MachineError fun

-- | An attempt to reduce a not immediately reducible application.
NonFunctionalApplicationMachineError :: MachineError fun

-- | An attempt to evaluate an open term.
OpenTermEvaluatedMachineError :: MachineError fun

-- | An attempt to compute a constant application resulted in
--   <tt>ConstAppError</tt>.
UnliftingMachineError :: UnliftingError -> MachineError fun

-- | A builtin expected a term argument, but something else was received
BuiltinTermArgumentExpectedMachineError :: MachineError fun

-- | A builtin received a term argument when something else was expected
UnexpectedBuiltinTermArgumentMachineError :: MachineError fun

-- | We've reached a state where a builtin instantiation or application is
--   attempted when the arity is zero. In the absence of nullary builtins,
--   this should be impossible. See the machine implementations for
--   details.
EmptyBuiltinArityMachineError :: MachineError fun
UnknownBuiltin :: fun -> MachineError fun
class AsMachineError r_a1f05 fun_a1ezc | r_a1f05 -> fun_a1ezc
_MachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 (MachineError fun_a1ezc)
_NonPolymorphicInstantiationMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 ()
_NonWrapUnwrappedMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 ()
_NonFunctionalApplicationMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 ()
_OpenTermEvaluatedMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 ()
_UnliftingMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 UnliftingError
_BuiltinTermArgumentExpectedMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 ()
_UnexpectedBuiltinTermArgumentMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 ()
_EmptyBuiltinArityMachineError :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 ()
_UnknownBuiltin :: AsMachineError r_a1f05 fun_a1ezc => Prism' r_a1f05 fun_a1ezc

-- | The type of errors (all of them) which can occur during evaluation
--   (some are used-caused, some are internal).
data EvaluationError user internal

-- | Indicates bugs.
InternalEvaluationError :: internal -> EvaluationError user internal

-- | Indicates user errors.
UserEvaluationError :: user -> EvaluationError user internal
class AsEvaluationError r_a1f0o user_a1eza internal_a1ezb | r_a1f0o -> user_a1eza internal_a1ezb
_EvaluationError :: AsEvaluationError r_a1f0o user_a1eza internal_a1ezb => Prism' r_a1f0o (EvaluationError user_a1eza internal_a1ezb)
_InternalEvaluationError :: AsEvaluationError r_a1f0o user_a1eza internal_a1ezb => Prism' r_a1f0o internal_a1ezb
_UserEvaluationError :: AsEvaluationError r_a1f0o user_a1eza internal_a1ezb => Prism' r_a1f0o user_a1eza

-- | An error and (optionally) what caused it.
data ErrorWithCause err term
ErrorWithCause :: err -> Maybe term -> ErrorWithCause err term
[_ewcError] :: ErrorWithCause err term -> err
[_ewcCause] :: ErrorWithCause err term -> Maybe term
type EvaluationException user internal = ErrorWithCause (EvaluationError user internal)
mapCauseInMachineException :: (term1 -> term2) -> EvaluationException user (MachineError fun) term1 -> EvaluationException user (MachineError fun) term2
throwing_ :: MonadError e m => AReview e () -> m x

-- | <a>Prismatically</a> throw an error and its (optional) cause.
throwingWithCause :: forall exc e t term m x. (exc ~ ErrorWithCause e term, MonadError exc m) => AReview e t -> t -> Maybe term -> m x

-- | Turn any <a>UserEvaluationError</a> into an <a>EvaluationFailure</a>.
extractEvaluationResult :: Either (EvaluationException user internal term) a -> Either (ErrorWithCause internal term) (EvaluationResult a)
unsafeExtractEvaluationResult :: (PrettyPlc internal, PrettyPlc term, Typeable internal, Typeable term) => Either (EvaluationException user internal term) a -> EvaluationResult a
instance (Control.DeepSeq.NFData err, Control.DeepSeq.NFData term) => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance Data.Traversable.Traversable (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err)
instance Data.Foldable.Foldable (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err)
instance GHC.Base.Functor (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err)
instance (GHC.Classes.Eq err, GHC.Classes.Eq term) => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance (PlutusCore.Pretty.Plc.PrettyPlc term, PlutusCore.Pretty.Plc.PrettyPlc err, Data.Typeable.Internal.Typeable term, Data.Typeable.Internal.Typeable err) => GHC.Exception.Type.Exception (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance Data.Bifunctor.Bifunctor PlutusCore.Evaluation.Machine.Exception.ErrorWithCause
instance PlutusCore.Evaluation.Result.AsEvaluationFailure err => PlutusCore.Evaluation.Result.AsEvaluationFailure (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance (Prettyprinter.Internal.Pretty err, Prettyprinter.Internal.Pretty term) => Prettyprinter.Internal.Pretty (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance (Text.PrettyBy.Internal.PrettyBy config term, Text.PrettyBy.Internal.PrettyBy config err) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance (PlutusCore.Pretty.Plc.PrettyPlc term, PlutusCore.Pretty.Plc.PrettyPlc err) => GHC.Show.Show (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err term)
instance ErrorCode.HasErrorCode err => ErrorCode.HasErrorCode (PlutusCore.Evaluation.Machine.Exception.ErrorWithCause err t)
instance PlutusCore.Evaluation.Machine.Exception.AsEvaluationError (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal) user internal
instance (internal GHC.Types.~ PlutusCore.Evaluation.Machine.Exception.MachineError fun) => PlutusCore.Evaluation.Machine.Exception.AsMachineError (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal) fun
instance PlutusCore.Evaluation.Machine.Exception.AsUnliftingError internal => PlutusCore.Evaluation.Machine.Exception.AsUnliftingError (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)
instance PlutusCore.Evaluation.Result.AsEvaluationFailure user => PlutusCore.Evaluation.Result.AsEvaluationFailure (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)
instance PlutusCore.Evaluation.Machine.Exception.AsMachineError (PlutusCore.Evaluation.Machine.Exception.MachineError fun) fun
instance PlutusCore.Evaluation.Machine.Exception.AsUnliftingError (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance PlutusCore.Evaluation.Machine.Exception.AsUnliftingError PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance (Text.PrettyBy.Internal.HasPrettyDefaults config GHC.Types.~ 'GHC.Types.True, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance (Text.PrettyBy.Internal.HasPrettyDefaults config GHC.Types.~ 'GHC.Types.True, Text.PrettyBy.Internal.PrettyBy config internal, Prettyprinter.Internal.Pretty user) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)
instance ErrorCode.HasErrorCode PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance ErrorCode.HasErrorCode (PlutusCore.Evaluation.Machine.Exception.MachineError err)
instance (ErrorCode.HasErrorCode user, ErrorCode.HasErrorCode internal) => ErrorCode.HasErrorCode (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance Data.String.IsString PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance GHC.Show.Show PlutusCore.Evaluation.Machine.Exception.UnliftingError
instance Control.DeepSeq.NFData fun => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance GHC.Base.Functor PlutusCore.Evaluation.Machine.Exception.MachineError
instance GHC.Classes.Eq fun => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance GHC.Show.Show fun => GHC.Show.Show (PlutusCore.Evaluation.Machine.Exception.MachineError fun)
instance (Control.DeepSeq.NFData internal, Control.DeepSeq.NFData user) => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)
instance GHC.Base.Functor (PlutusCore.Evaluation.Machine.Exception.EvaluationError user)
instance (GHC.Classes.Eq internal, GHC.Classes.Eq user) => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)
instance (GHC.Show.Show internal, GHC.Show.Show user) => GHC.Show.Show (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal)

module PlutusCore.Core
data Kind ann
Type :: ann -> Kind ann
KindArrow :: ann -> Kind ann -> Kind ann -> Kind ann

-- | A <a>Type</a> assigned to expressions.
data Type tyname uni ann
TyVar :: ann -> tyname -> Type tyname uni ann
TyFun :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Fix-point type, for constructing self-recursive types
TyIFix :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann
TyForall :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Builtin type
TyBuiltin :: ann -> SomeTypeIn uni -> Type tyname uni ann
TyLam :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann
TyApp :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann
data Term tyname name uni fun ann

-- | a named variable
Var :: ann -> name -> Term tyname name uni fun ann
TyAbs :: ann -> tyname -> Kind ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
LamAbs :: ann -> name -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
Apply :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | a constant term
Constant :: ann -> Some (ValueOf uni) -> Term tyname name uni fun ann
Builtin :: ann -> fun -> Term tyname name uni fun ann
TyInst :: ann -> Term tyname name uni fun ann -> Type tyname uni ann -> Term tyname name uni fun ann
Unwrap :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
IWrap :: ann -> Type tyname uni ann -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
Error :: ann -> Type tyname uni ann -> Term tyname name uni fun ann

-- | Version of Plutus Core to be used for the program.
data Version ann
Version :: ann -> Natural -> Natural -> Natural -> Version ann

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a <a>Version</a>
--   of the core language.
data Program tyname name uni fun ann
Program :: ann -> Version ann -> Term tyname name uni fun ann -> Program tyname name uni fun ann

-- | Extract the universe from a type.
type family UniOf a :: Type -> Type
newtype Normalized a
Normalized :: a -> Normalized a
[unNormalized] :: Normalized a -> a

-- | All kinds of uniques an entity contains.
type family HasUniques a :: Constraint

-- | A class for converting Haskell kinds to PLC kinds.
class KnownKind kind
knownKind :: KnownKind kind => proxy kind -> Kind ()

-- | For getting the Plutus kind of a type from the universe.
class ToKind (uni :: Type -> Type)
toKind :: forall k (a :: k). ToKind uni => uni (Esc a) -> Kind ()

-- | Get the PLC kind of <tt>a</tt>.
kindOf :: forall uni k (a :: k). KnownKind k => uni (Esc a) -> Kind ()

-- | The default version of Plutus Core supported by this library.
defaultVersion :: ann -> Version ann
toTerm :: Program tyname name uni fun ann -> Term tyname name uni fun ann
termAnn :: Term tyname name uni fun ann -> ann
typeAnn :: Type tyname uni ann -> ann

-- | Map a function over the set of built-in functions.
mapFun :: (fun -> fun') -> Term tyname name uni fun ann -> Term tyname name uni fun' ann

-- | Get all the direct child 'tyname a's of the given <a>Type</a> from
--   binders.
typeTyBinds :: Traversal' (Type tyname uni ann) tyname

-- | Get all the direct child 'tyname a's of the given <a>Type</a> from
--   <a>TyVar</a>s.
typeTyVars :: Traversal' (Type tyname uni ann) tyname

-- | Get all the direct child <a>Unique</a>s of the given <a>Type</a> from
--   binders <a>TyVar</a>s.
typeUniques :: HasUniques (Type tyname uni ann) => Traversal' (Type tyname uni ann) Unique

-- | Get all the direct child <a>Type</a>s of the given <a>Type</a>.
typeSubtypes :: Traversal' (Type tyname uni ann) (Type tyname uni ann)

-- | Get all the transitive child <a>Type</a>s of the given <a>Type</a>.
typeSubtypesDeep :: Fold (Type tyname uni ann) (Type tyname uni ann)

-- | Get all the direct child 'tyname a's of the given <a>Term</a> from
--   <a>TyAbs</a>es.
termTyBinds :: Traversal' (Term tyname name uni fun ann) tyname

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>LamAbs</a>es.
termBinds :: Traversal' (Term tyname name uni fun ann) name

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>Var</a>s.
termVars :: Traversal' (Term tyname name uni fun ann) name

-- | Get all the direct child <a>Unique</a>s of the given <a>Term</a>
--   (including the type-level ones).
termUniques :: HasUniques (Term tyname name uni fun ann) => Traversal' (Term tyname name uni fun ann) Unique

-- | Get all the direct child <a>Type</a>s of the given <a>Term</a>.
termSubtypes :: Traversal' (Term tyname name uni fun ann) (Type tyname uni ann)

-- | Get all the transitive child <a>Type</a>s of the given <a>Term</a>.
termSubtypesDeep :: Fold (Term tyname name uni fun ann) (Type tyname uni ann)

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>.
termSubterms :: Traversal' (Term tyname name uni fun ann) (Term tyname name uni fun ann)

-- | Get all the transitive child <a>Term</a>s of the given <a>Term</a>.
termSubtermsDeep :: Fold (Term tyname name uni fun ann) (Term tyname name uni fun ann)

-- | Get all the transitive child <a>Unique</a>s of the given <a>Type</a>.
typeUniquesDeep :: HasUniques (Type tyname uni ann) => Fold (Type tyname uni ann) Unique

-- | Get all the transitive child <a>Unique</a>s of the given <a>Term</a>
--   (including the type-level ones).
termUniquesDeep :: HasUniques (Term tyname name uni fun ann) => Fold (Term tyname name uni fun ann) Unique
data TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
VarF :: ann_aYOK -> name_aYOH -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
TyAbsF :: ann_aYOK -> tyname_aYOG -> Kind ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
LamAbsF :: ann_aYOK -> name_aYOH -> Type tyname_aYOG uni_aYOI ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
ApplyF :: ann_aYOK -> r_a1aX9 -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
ConstantF :: ann_aYOK -> Some (ValueOf uni_aYOI) -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
BuiltinF :: ann_aYOK -> fun_aYOJ -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
TyInstF :: ann_aYOK -> r_a1aX9 -> Type tyname_aYOG uni_aYOI ann_aYOK -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
UnwrapF :: ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
IWrapF :: ann_aYOK -> Type tyname_aYOG uni_aYOI ann_aYOK -> Type tyname_aYOG uni_aYOI ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
ErrorF :: ann_aYOK -> Type tyname_aYOG uni_aYOI ann_aYOK -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
data TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyVarF :: ann_aYON -> tyname_aYOL -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyFunF :: ann_aYON -> r_a1aSR -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyIFixF :: ann_aYON -> r_a1aSR -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyForallF :: ann_aYON -> tyname_aYOL -> Kind ann_aYON -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyBuiltinF :: ann_aYON -> SomeTypeIn uni_aYOM -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyLamF :: ann_aYON -> tyname_aYOL -> Kind ann_aYON -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyAppF :: ann_aYON -> r_a1aSR -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
data KindF (ann_aYOO :: Type) r_a1aSj
TypeF :: ann_aYOO -> KindF (ann_aYOO :: Type) r_a1aSj
KindArrowF :: ann_aYOO -> r_a1aSj -> r_a1aSj -> KindF (ann_aYOO :: Type) r_a1aSj

-- | Check equality of two <a>Type</a>s.
eqTypeM :: (HasRenaming ren TypeUnique, GEq uni) => EqRenameOf ren (Type tyname uni ann)

-- | Check equality of two <a>Term</a>s.
eqTermM :: (GEq uni, Closed uni, uni `Everywhere` Eq, Eq fun) => EqRenameOf ScopedRenaming (Term tyname name uni fun ann)

-- | Check equality of two <a>Program</a>s.
eqProgramM :: (GEq uni, Closed uni, uni `Everywhere` Eq, Eq fun) => EqRenameOf ScopedRenaming (Program tyname name uni fun ann)

module PlutusCore.Subst

-- | Applicatively replace a type variable using the given function.
substTyVarA :: Applicative f => (tyname -> f (Maybe (Type tyname uni ann))) -> Type tyname uni ann -> f (Type tyname uni ann)

-- | Applicatively replace a variable using the given function.
substVarA :: Applicative f => (name -> f (Maybe (Term tyname name uni fun ann))) -> Term tyname name uni fun ann -> f (Term tyname name uni fun ann)

-- | Replace a type variable using the given function.
substTyVar :: (tyname -> Maybe (Type tyname uni ann)) -> Type tyname uni ann -> Type tyname uni ann

-- | Replace a variable using the given function.
substVar :: (name -> Maybe (Term tyname name uni fun ann)) -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | Naively monadically substitute names using the given function (i.e. do
--   not substitute binders).
termSubstNamesM :: Monad m => (name -> m (Maybe (Term tyname name uni fun ann))) -> Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Naively monadically substitute type names using the given function
--   (i.e. do not substitute binders).
termSubstTyNamesM :: Monad m => (tyname -> m (Maybe (Type tyname uni ann))) -> Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Naively monadically substitute type names (i.e. do not substitute
--   binders).
typeSubstTyNamesM :: Monad m => (tyname -> m (Maybe (Type tyname uni ann))) -> Type tyname uni ann -> m (Type tyname uni ann)

-- | Naively substitute names using the given function (i.e. do not
--   substitute binders).
termSubstNames :: (name -> Maybe (Term tyname name uni fun ann)) -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | Naively substitute type names using the given function (i.e. do not
--   substitute binders).
termSubstTyNames :: (tyname -> Maybe (Type tyname uni ann)) -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | Naively substitute type names (i.e. do not substitute binders).
typeSubstTyNames :: (tyname -> Maybe (Type tyname uni ann)) -> Type tyname uni ann -> Type tyname uni ann

-- | Applicatively substitute *free* names using the given function.
termSubstFreeNamesA :: (Applicative f, HasUnique name TermUnique) => (name -> f (Maybe (Term tyname name uni fun ann))) -> Term tyname name uni fun ann -> f (Term tyname name uni fun ann)

-- | Substitute *free* names using the given function.
termSubstFreeNames :: HasUnique name TermUnique => (name -> Maybe (Term tyname name uni fun ann)) -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | Get all the free term variables in a term.
fvTerm :: Ord name => Term tyname name uni fun ann -> Set name

-- | Get all the free type variables in a term.
ftvTerm :: Ord tyname => Term tyname name uni fun ann -> Set tyname

-- | Get all the free type variables in a type.
ftvTy :: Ord tyname => Type tyname uni ann -> Set tyname

-- | Get all the term variables in a term.
vTerm :: Ord name => Term tyname name uni fun ann -> Set name

-- | Get all the type variables in a term.
tvTerm :: Ord tyname => Term tyname name uni fun ann -> Set tyname

-- | Get all the type variables in a type.
tvTy :: Ord tyname => Type tyname uni ann -> Set tyname

-- | Get all the uniques in a type.
uniquesType :: HasUniques (Type tyname uni ann) => Type tyname uni ann -> Set Unique

-- | Get all the uniques in a term (including the type-level ones).
uniquesTerm :: HasUniques (Term tyname name uni fun ann) => Term tyname name uni fun ann -> Set Unique

module PlutusCore.MkPlc

-- | A final encoding for Term, to allow PLC terms to be used transparently
--   as PIR terms.
class TermLike term tyname name uni fun | term -> tyname name uni fun
var :: TermLike term tyname name uni fun => ann -> name -> term ann
tyAbs :: TermLike term tyname name uni fun => ann -> tyname -> Kind ann -> term ann -> term ann
lamAbs :: TermLike term tyname name uni fun => ann -> name -> Type tyname uni ann -> term ann -> term ann
apply :: TermLike term tyname name uni fun => ann -> term ann -> term ann -> term ann
constant :: TermLike term tyname name uni fun => ann -> Some (ValueOf uni) -> term ann
builtin :: TermLike term tyname name uni fun => ann -> fun -> term ann
tyInst :: TermLike term tyname name uni fun => ann -> term ann -> Type tyname uni ann -> term ann
unwrap :: TermLike term tyname name uni fun => ann -> term ann -> term ann
iWrap :: TermLike term tyname name uni fun => ann -> Type tyname uni ann -> Type tyname uni ann -> term ann -> term ann
error :: TermLike term tyname name uni fun => ann -> Type tyname uni ann -> term ann
termLet :: TermLike term tyname name uni fun => ann -> TermDef term tyname name uni fun ann -> term ann -> term ann
typeLet :: TermLike term tyname name uni fun => ann -> TypeDef tyname uni ann -> term ann -> term ann

-- | Extract the universe from a type.
type family UniOf a :: Type -> Type

-- | Embed a type (given its explicit type tag) into a PLC type.
mkTyBuiltinOf :: forall k (a :: k) uni tyname ann. ann -> uni (Esc a) -> Type tyname uni ann

-- | Embed a type (provided it's in the universe) into a PLC type.
mkTyBuiltin :: forall k (a :: k) uni tyname ann. uni `Contains` a => ann -> Type tyname uni ann

-- | Embed a Haskell value (given its explicit type tag) into a PLC term.
mkConstantOf :: forall a uni fun term tyname name ann. TermLike term tyname name uni fun => ann -> uni (Esc a) -> a -> term ann

-- | Embed a Haskell value (provided its type is in the universe) into a
--   PLC term.
mkConstant :: forall a uni fun term tyname name ann. (TermLike term tyname name uni fun, uni `Includes` a) => ann -> a -> term ann

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl tyname name uni fun ann
VarDecl :: ann -> name -> Type tyname uni ann -> VarDecl tyname name uni fun ann
[varDeclAnn] :: VarDecl tyname name uni fun ann -> ann
[varDeclName] :: VarDecl tyname name uni fun ann -> name
[varDeclType] :: VarDecl tyname name uni fun ann -> Type tyname uni ann

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl tyname ann
TyVarDecl :: ann -> tyname -> Kind ann -> TyVarDecl tyname ann
[tyVarDeclAnn] :: TyVarDecl tyname ann -> ann
[tyVarDeclName] :: TyVarDecl tyname ann -> tyname
[tyVarDeclKind] :: TyVarDecl tyname ann -> Kind ann

-- | A "type declaration", i.e. a kind for a type.
data TyDecl tyname uni ann
TyDecl :: ann -> Type tyname uni ann -> Kind ann -> TyDecl tyname uni ann
[tyDeclAnn] :: TyDecl tyname uni ann -> ann
[tyDeclType] :: TyDecl tyname uni ann -> Type tyname uni ann
[tyDeclKind] :: TyDecl tyname uni ann -> Kind ann

-- | Make a <a>Var</a> referencing the given <a>VarDecl</a>.
mkVar :: TermLike term tyname name uni fun => ann -> VarDecl tyname name uni fun ann -> term ann

-- | Make a <a>TyVar</a> referencing the given <a>TyVarDecl</a>.
mkTyVar :: ann -> TyVarDecl tyname ann -> Type tyname uni ann
tyDeclVar :: TyVarDecl tyname ann -> TyDecl tyname uni ann

-- | A definition. Pretty much just a pair with more descriptive names.
data Def var val
Def :: var -> val -> Def var val
[defVar] :: Def var val -> var
[defVal] :: Def var val -> val
embed :: TermLike term tyname name uni fun => Term tyname name uni fun ann -> term ann

-- | A term definition as a variable.
type TermDef term tyname name uni fun ann = Def (VarDecl tyname name uni fun ann) (term ann)

-- | A type definition as a type variable.
type TypeDef tyname uni ann = Def (TyVarDecl tyname ann) (Type tyname uni ann)

-- | The type of a PLC function.
data FunctionType tyname uni ann
FunctionType :: ann -> Type tyname uni ann -> Type tyname uni ann -> FunctionType tyname uni ann

-- | An annotation.
[_functionTypeAnn] :: FunctionType tyname uni ann -> ann

-- | The domain of a function.
[_functionTypeDom] :: FunctionType tyname uni ann -> Type tyname uni ann

-- | The codomain of the function.
[_functionTypeCod] :: FunctionType tyname uni ann -> Type tyname uni ann

-- | A PLC function.
data FunctionDef term tyname name uni fun ann
FunctionDef :: ann -> name -> FunctionType tyname uni ann -> term ann -> FunctionDef term tyname name uni fun ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef term tyname name uni fun ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef term tyname name uni fun ann -> name

-- | The type of the function.
[_functionDefType] :: FunctionDef term tyname name uni fun ann -> FunctionType tyname uni ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef term tyname name uni fun ann -> term ann

-- | Convert a <a>FunctionType</a> to the corresponding <a>Type</a>.
functionTypeToType :: FunctionType tyname uni ann -> Type tyname uni ann

-- | Get the type of a <a>FunctionDef</a>.
functionDefToType :: FunctionDef term tyname name uni fun ann -> Type tyname uni ann

-- | Convert a <a>FunctionDef</a> to a <a>VarDecl</a>. I.e. ignore the
--   actual term.
functionDefVarDecl :: FunctionDef term tyname name uni fun ann -> VarDecl tyname name uni fun ann

-- | Make a <tt>FunctioDef</tt>. Return <a>Nothing</a> if the provided type
--   is not functional.
mkFunctionDef :: ann -> name -> Type tyname uni ann -> term ann -> Maybe (FunctionDef term tyname name uni fun ann)

-- | Make a "let-binding" for a term as an immediately applied lambda
--   abstraction.
mkImmediateLamAbs :: TermLike term tyname name uni fun => ann -> TermDef term tyname name uni fun ann -> term ann -> term ann

-- | Make a "let-binding" for a type as an immediately instantiated type
--   abstraction. Note: the body must be a value.
mkImmediateTyAbs :: TermLike term tyname name uni fun => ann -> TypeDef tyname uni ann -> term ann -> term ann

-- | Universally quantify a list of names.
mkIterTyForall :: [TyVarDecl tyname ann] -> Type tyname uni ann -> Type tyname uni ann

-- | Lambda abstract a list of names.
mkIterTyLam :: [TyVarDecl tyname ann] -> Type tyname uni ann -> Type tyname uni ann

-- | Make an iterated application.
mkIterApp :: TermLike term tyname name uni fun => ann -> term ann -> [term ann] -> term ann

-- | Make an iterated function type.
mkIterTyFun :: ann -> [Type tyname uni ann] -> Type tyname uni ann -> Type tyname uni ann

-- | Lambda abstract a list of names.
mkIterLamAbs :: TermLike term tyname name uni fun => [VarDecl tyname name uni fun ann] -> term ann -> term ann

-- | Make an iterated instantiation.
mkIterInst :: TermLike term tyname name uni fun => ann -> term ann -> [Type tyname uni ann] -> term ann

-- | Type abstract a list of names.
mkIterTyAbs :: TermLike term tyname name uni fun => [TyVarDecl tyname ann] -> term ann -> term ann

-- | Make an iterated type application.
mkIterTyApp :: ann -> Type tyname uni ann -> [Type tyname uni ann] -> Type tyname uni ann

-- | Make an iterated function kind.
mkIterKindArrow :: ann -> [Kind ann] -> Kind ann -> Kind ann
instance forall tyname name (uni :: * -> *) k (fun :: k) ann. GHC.Generics.Generic (PlutusCore.MkPlc.VarDecl tyname name uni fun ann)
instance forall tyname name (uni :: * -> *) k (fun :: k) ann. (GHC.Show.Show ann, GHC.Show.Show name, GHC.Show.Show tyname, Data.GADT.Internal.GShow uni) => GHC.Show.Show (PlutusCore.MkPlc.VarDecl tyname name uni fun ann)
instance forall tyname name (uni :: * -> *) k (fun :: k). GHC.Base.Functor (PlutusCore.MkPlc.VarDecl tyname name uni fun)
instance GHC.Generics.Generic (PlutusCore.MkPlc.TyVarDecl tyname ann)
instance (GHC.Show.Show ann, GHC.Show.Show tyname) => GHC.Show.Show (PlutusCore.MkPlc.TyVarDecl tyname ann)
instance GHC.Base.Functor (PlutusCore.MkPlc.TyVarDecl tyname)
instance GHC.Generics.Generic (PlutusCore.MkPlc.TyDecl tyname uni ann)
instance (GHC.Show.Show ann, GHC.Show.Show tyname, Data.GADT.Internal.GShow uni) => GHC.Show.Show (PlutusCore.MkPlc.TyDecl tyname uni ann)
instance GHC.Base.Functor (PlutusCore.MkPlc.TyDecl tyname uni)
instance GHC.Generics.Generic (PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Ord var, GHC.Classes.Ord val) => GHC.Classes.Ord (PlutusCore.MkPlc.Def var val)
instance (GHC.Classes.Eq var, GHC.Classes.Eq val) => GHC.Classes.Eq (PlutusCore.MkPlc.Def var val)
instance (GHC.Show.Show var, GHC.Show.Show val) => GHC.Show.Show (PlutusCore.MkPlc.Def var val)
instance PlutusCore.MkPlc.TermLike (PlutusCore.Core.Type.Term tyname name uni fun) tyname name uni fun


-- | This module defines Haskell data types that simplify construction of
--   PLC types and terms.
module PlutusCore.StdLib.Type

-- | A recursive type packaged along with a specified <tt>Wrap</tt> that
--   allows to construct elements of this type.
data RecursiveType uni fun ann
RecursiveType :: Type TyName uni ann -> (forall term. TermLike term TyName Name uni fun => [Type TyName uni ann] -> term ann -> term ann) -> RecursiveType uni fun ann
[_recursiveType] :: RecursiveType uni fun ann -> Type TyName uni ann
[_recursiveWrap] :: RecursiveType uni fun ann -> forall term. TermLike term TyName Name uni fun => [Type TyName uni ann] -> term ann -> term ann

-- | Construct a <a>RecursiveType</a> out of its name, variables bound in
--   its pattern functor and the body of the pattern functor. The 0- and
--   1-ary pattern functors are special-cased, while in the general case
--   the pattern functor and type arguments get encoded into a 1-ary form
--   first.
makeRecursiveType :: FromDataPieces uni ann (RecursiveType uni fun ann)
instance GHC.Exception.Type.Exception PlutusCore.StdLib.Type.IndicesLengthsMismatchException
instance GHC.Show.Show PlutusCore.StdLib.Type.IndicesLengthsMismatchException


-- | <tt>tuple</tt>s of various sizes and related functions.
module PlutusCore.StdLib.Meta.Data.Tuple

-- | A Plutus Core (Scott-encoded) tuple.
data Tuple term uni ann
[Tuple] :: TermLike term TyName Name uni fun => {_tupleElementTypes :: [Type TyName uni ann] " The types of elements of a tuple.", _tupleTerm :: term ann " A term representation of the tuple."} -> Tuple term uni ann

-- | Get the type of a <a>Tuple</a>.
--   
--   <pre>
--   getTupleType _ (Tuple [a1, ... , an] _) = all r. (a1 -&gt; ... -&gt; an -&gt; r) -&gt; r
--   </pre>
getTupleType :: MonadQuote m => ann -> Tuple term uni ann -> m (Type TyName uni ann)

-- | Get the type of the ith element of a <a>Tuple</a> along with the
--   element itself.
--   
--   <pre>
--   tupleTypeTermAt _ i (Tuple [a0, ... , an] term) =
--       (ai, term {ai} (\(x0 : a0) ... (xn : an) -&gt; xi))
--   </pre>
tupleTypeTermAt :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> Int -> Tuple term uni ann -> m (Type TyName uni ann, term ann)

-- | Get the ith element of a <a>Tuple</a>.
tupleTermAt :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> Int -> Tuple term uni ann -> m (term ann)

-- | Get the ith element of a <a>Tuple</a> as a <a>TermDef</a>.
tupleDefAt :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> Int -> Name -> Tuple term uni ann -> m (TermDef term TyName Name uni fun ann)

-- | Bind all elements of a <a>Tuple</a> inside a <a>Term</a>.
--   
--   <pre>
--   bindTuple _ [x_1, ... , x_n] (Tuple [a1, ... , an] term) body =
--       (\(tup : all r. (a_1 -&gt; ... -&gt; a_n -&gt; r) -&gt; r) -&gt;
--         let x_1 = _1 tup
--             ...
--             x_n = _n tup
--           in body
--       ) term
--   </pre>
bindTuple :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> [Name] -> Tuple term uni ann -> term ann -> m (term ann)

-- | Given an arity <tt>n</tt>, create the n-ary product type.
--   
--   <pre>
--   (T_1 :: *) .. (T_n :: *) . all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R
--   </pre>
prodN :: Int -> Type TyName uni ()

-- | Given an arity <tt>n</tt>, create the constructor for n-ary products.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (arg_1 : T_1) .. (arg_n : T_n) .
--           /(R :: *).
--               (case : T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; case arg_1 .. arg_n
--   </pre>
prodNConstructor :: TermLike term TyName Name uni fun => Int -> term ()

-- | Given an arity <tt>n</tt> and an index <tt>i</tt>, create a function
--   for accessing the i'th component of a n-tuple.
--   
--   <pre>
--   /(T_1 :: *) .. (T_n :: *) .
--       (tuple : all (R :: *) . (T_1 -&gt; .. -&gt; T_n -&gt; R) -&gt; R)) .
--           tuple {T_i} ((arg_1 : T_1) .. (arg_n : T_n) . arg_i)
--   </pre>
prodNAccessor :: TermLike term TyName Name uni fun => Int -> Int -> term ()

-- | Convert a Haskell spine of <a>Term</a>s to a PLC <a>Tuple</a>.
--   
--   <pre>
--   getSpineToTuple _ [(a1, x1), ... , (an, xn)] =
--       Tuple [a1, ... , an] (/\(r :: *) -&gt; \(f :: a1 -&gt; ... -&gt; an -&gt; r) -&gt; f x1 ... xn)
--   </pre>
getSpineToTuple :: (TermLike term TyName Name uni fun, MonadQuote m) => ann -> [(Type TyName uni ann, term ann)] -> m (Tuple term uni ann)


-- | Meta-functions relating to functions.
module PlutusCore.StdLib.Meta.Data.Function

-- | <a>const</a> as a PLC term.
--   
--   <pre>
--   constPartial t = /\(A :: *) -&gt; \(x : A) -&gt; t
--   </pre>
constPartial :: TermLike term TyName Name uni fun => term () -> term ()

-- | Eta-expand a function at a given type. Note that this has to be a
--   "meta" function for it not force the function it receives and instead
--   directly hide it under a lambda.
--   
--   <pre>
--   etaExpand ty fun = \(x : ty) -&gt; fun x
--   </pre>
etaExpand :: TermLike term TyName Name uni fun => Type TyName uni () -> term () -> term ()


-- | <tt>unit</tt> and related functions.
module PlutusCore.StdLib.Data.Unit

-- | <tt>()</tt> as a PLC type.
unit :: uni `Includes` () => Type TyName uni ()

-- | <tt>()</tt> as a PLC term.
unitval :: (TermLike term TyName Name uni fun, uni `Includes` ()) => term ()

-- | <a>seq</a> specified to <tt>()</tt> as a PLC term.
sequ :: (TermLike term TyName Name uni fun, uni `Includes` ()) => term ()


-- | <tt>sum</tt> and related functions.
module PlutusCore.StdLib.Data.Sum

-- | <a>Either</a> as a PLC type.
--   
--   <pre>
--   \(a b :: *) -&gt; all (r :: *). (a -&gt; r) -&gt; (b -&gt; r) -&gt; r
--   </pre>
sum :: Type TyName uni ()

-- | <a>Left</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(x : a) -&gt; /\(r :: *) -&gt; \(f : a -&gt; r) -&gt; (g : b -&gt; r) -&gt; f x
--   </pre>
left :: TermLike term TyName Name uni fun => term ()

-- | <a>Right</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(y : b) -&gt; /\(r :: *) -&gt; \(f : a -&gt; r) -&gt; (g : b -&gt; r) -&gt; g y
--   </pre>
right :: TermLike term TyName Name uni fun => term ()


-- | Scott-encoded <tt>unit</tt> and related functions.
module PlutusCore.StdLib.Data.ScottUnit

-- | <tt>()</tt> as a PLC type.
--   
--   <pre>
--   all (A :: *). A -&gt; A
--   </pre>
unit :: Type TyName uni ()

-- | <tt>()</tt> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x : A) -&gt; x
--   </pre>
unitval :: TermLike term TyName Name uni fun => term ()


-- | Combinators.
module PlutusCore.StdLib.Data.Function

-- | <a>const</a> as a PLC term.
--   
--   <pre>
--   /\(A B :: *) -&gt; \(x : A) (y : B) -&gt; x
--   </pre>
const :: TermLike term TyName Name uni fun => term ()

-- | <a>id</a> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(x : A) -&gt; x
--   </pre>
idFun :: TermLike term TyName Name uni fun => term ()

-- | <a>($)</a> as a PLC term.
--   
--   <pre>
--   /\(A B :: *) -&gt; \(f : A -&gt; B) (x : A) -&gt; f x
--   </pre>
applyFun :: TermLike term TyName Name uni fun => term ()

-- | <tt>Self</tt> as a PLC type.
--   
--   <pre>
--   fix \(self :: * -&gt; *) (a :: *) -&gt; self a -&gt; a
--   </pre>
selfData :: RecursiveType uni fun ()

-- | <tt>unroll</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(s : self a) -&gt; unwrap s s
--   </pre>
unroll :: TermLike term TyName Name uni fun => term ()

-- | <a>fix</a> as a PLC term.
--   
--   <pre>
--   /\(a b :: *) -&gt; \(f : (a -&gt; b) -&gt; a -&gt; b) -&gt;
--      unroll {a -&gt; b} (iwrap selfF (a -&gt; b) \(s : self (a -&gt; b)) \(x : a) -&gt; f (unroll {a -&gt; b} s) x)
--   </pre>
--   
--   See <tt>plutus<i>runQuote $
--   docs</i>fomega/z-combinator-benchmarks</tt> for details.
fix :: TermLike term TyName Name uni fun => term ()
fixAndType :: TermLike term TyName Name uni fun => (term (), Type TyName uni ())

-- | The <a>fixBy</a> combinator.
--   
--   <pre>
--   fixBy :
--       forall (F :: * -&gt; *) .
--       ((F ~&gt; Id) -&gt; (F ~&gt; Id)) -&gt;
--       ((F ~&gt; F) -&gt; (F ~&gt; Id))
--   </pre>
fixBy :: TermLike term TyName Name uni fun => term ()
fixByAndType :: TermLike term TyName Name uni fun => (term (), Type TyName uni ())

-- | Make a <tt>n</tt>-ary fixpoint combinator.
--   
--   <pre>
--   FixN n :
--       forall A1 B1 ... An Bn :: * .
--       (forall Q :: * .
--           ((A1 -&gt; B1) -&gt; ... -&gt; (An -&gt; Bn) -&gt; Q) -&gt;
--           (A1 -&gt; B1) -&gt;
--           ... -&gt;
--           (An -&gt; Bn) -&gt;
--           Q) -&gt;
--       (forall R :: * . ((A1 -&gt; B1) -&gt; ... (An -&gt; Bn) -&gt; R) -&gt; R)
--   </pre>
fixN :: TermLike term TyName Name uni fun => Integer -> term () -> term ()
fixNAndType :: TermLike term TyName Name uni fun => Integer -> term () -> (term (), Type TyName uni ())

-- | A PLC function.
data FunctionDef term tyname name uni fun ann
FunctionDef :: ann -> name -> FunctionType tyname uni ann -> term ann -> FunctionDef term tyname name uni fun ann

-- | An annotation.
[_functionDefAnn] :: FunctionDef term tyname name uni fun ann -> ann

-- | The name of a function.
[_functionDefName] :: FunctionDef term tyname name uni fun ann -> name

-- | The type of the function.
[_functionDefType] :: FunctionDef term tyname name uni fun ann -> FunctionType tyname uni ann

-- | The definition of the function.
[_functionDefTerm] :: FunctionDef term tyname name uni fun ann -> term ann

-- | Get the fixed-point of a list of mutually recursive functions.
--   
--   <pre>
--   MutualFixOf _ fixN [ FunctionDef _ fN1 (FunctionType _ a1 b1) f1
--                      , ...
--                      , FunctionDef _ fNn (FunctionType _ an bn) fn
--                      ] =
--       Tuple [(a1 -&gt; b1) ... (an -&gt; bn)] $
--           fixN {a1} {b1} ... {an} {bn}
--               /\(q :: *) -&gt; \(choose : (a1 -&gt; b1) -&gt; ... -&gt; (an -&gt; bn) -&gt; q) -&gt;
--                   \(fN1 : a1 -&gt; b1) ... (fNn : an -&gt; bn) -&gt; choose f1 ... fn
--   </pre>
getMutualFixOf :: TermLike term TyName Name uni fun => ann -> term ann -> [FunctionDef term TyName Name uni fun ann] -> Quote (Tuple term uni ann)

-- | Get the fixed-point of a single recursive function.
getSingleFixOf :: TermLike term TyName Name uni fun => ann -> term ann -> FunctionDef term TyName Name uni fun ann -> term ann


-- | Church-encoded <tt>nat</tt> and related functions.
module PlutusCore.StdLib.Data.ChurchNat

-- | Church-encoded <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   all (r :: *). r -&gt; (r -&gt; r) -&gt; r
--   </pre>
churchNat :: Type TyName uni ()

-- | Church-encoded '0' as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; z
--   </pre>
churchZero :: TermLike term TyName Name uni fun => term ()

-- | Church-encoded <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; /\(r :: *) -&gt; \(z : r) (f : r -&gt; r) -&gt; f (n {r} z f)
--   </pre>
churchSucc :: TermLike term TyName Name uni fun => term ()


-- | The internal module of the renamer that defines the actual algorithms,
--   but not the user-facing API.
module PlutusCore.Rename.Internal

-- | Replace the unique in the name stored in a <a>TyVarDecl</a> by a new
--   unique, save the mapping from the old unique to the new one and supply
--   the updated <a>TyVarDecl</a> to a continuation.
withFreshenedTyVarDecl :: (HasRenaming ren TypeUnique, HasUniques (Type tyname uni ann), MonadQuote m) => TyVarDecl tyname ann -> (TyVarDecl tyname ann -> RenameT ren m c) -> RenameT ren m c

-- | Replace the unique in the name stored in a <a>VarDecl</a> by a new
--   unique, save the mapping from the old unique to the new one and supply
--   to a continuation the computation that renames the type stored in the
--   updated <a>VarDecl</a>. The reason the continuation receives a
--   computation rather than a pure term is that we may want to bring
--   several term and type variables in scope before renaming the types of
--   term variables. This situation arises when we want to rename a bunch
--   of mutually recursive bindings.
withFreshenedVarDecl :: (HasUniques (Term tyname name uni fun ann), MonadQuote m) => VarDecl tyname name uni fun ann -> (ScopedRenameT m (VarDecl tyname name uni fun ann) -> ScopedRenameT m c) -> ScopedRenameT m c

-- | Rename a <a>Type</a> in the <tt>RenameM</tt> monad.
renameTypeM :: (HasRenaming ren TypeUnique, HasUniques (Type tyname uni ann), MonadQuote m) => Type tyname uni ann -> RenameT ren m (Type tyname uni ann)

-- | Rename a <a>Term</a> in the <tt>RenameM</tt> monad.
renameTermM :: (HasUniques (Term tyname name uni fun ann), MonadQuote m) => Term tyname name uni fun ann -> ScopedRenameT m (Term tyname name uni fun ann)

-- | Rename a <a>Program</a> in the <tt>RenameM</tt> monad.
renameProgramM :: (HasUniques (Program tyname name uni fun ann), MonadQuote m) => Program tyname name uni fun ann -> ScopedRenameT m (Program tyname name uni fun ann)


-- | The user-facing API of the renamer.
module PlutusCore.Rename

-- | The class of things that can be renamed. I.e. things that are capable
--   of satisfying the global uniqueness condition.
class Rename a

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched and bound
--   variables must not get renamed to free ones. Must always assign new
--   names to bound variables, so that <tt>rename</tt> can be used for
--   alpha-renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a

-- | <tt>Dupable a</tt> is isomorphic to <tt>a</tt>, but the only way to
--   extract the <tt>a</tt> is via <a>liftDupable</a> which renames the
--   stored value along the way. This type is used whenever
--   
--   <ol>
--   <li>preserving global uniqueness is required</li>
--   <li>some value may be used multiple times</li>
--   </ol>
--   
--   so we annotate such a value with <a>Dupable</a> and call
--   <a>liftDupable</a> at each usage, which ensures global conditions is
--   preserved.
data Dupable a

-- | Extract the value stored in a <tt>Dupable a</tt> and rename it.
liftDupable :: (MonadQuote m, Rename a) => Dupable a -> m a
instance GHC.Base.Monad PlutusCore.Rename.Dupable
instance GHC.Base.Applicative PlutusCore.Rename.Dupable
instance Data.Traversable.Traversable PlutusCore.Rename.Dupable
instance Data.Foldable.Foldable PlutusCore.Rename.Dupable
instance GHC.Base.Functor PlutusCore.Rename.Dupable
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusCore.Rename.Dupable a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusCore.Rename.Dupable a)
instance PlutusCore.Core.Type.HasUniques (PlutusCore.Core.Type.Type tyname uni ann) => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Type tyname uni ann)
instance PlutusCore.Core.Type.HasUniques (PlutusCore.Core.Type.Term tyname name uni fun ann) => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Term tyname name uni fun ann)
instance PlutusCore.Core.Type.HasUniques (PlutusCore.Core.Type.Program tyname name uni fun ann) => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Program tyname name uni fun ann)
instance PlutusCore.Rename.Rename a => PlutusCore.Rename.Rename (PlutusCore.Core.Type.Normalized a)


-- | The internals of the normalizer.
module PlutusCore.Normalize.Internal

-- | The monad transformer that type normalization runs in.
data NormalizeTypeT m tyname uni ann a

-- | Run a <tt>NormalizeTypeM</tt> computation.
runNormalizeTypeM :: NormalizeTypeT m tyname uni ann a -> m a

-- | Locally extend a <a>TypeVarEnv</a> in a <tt>NormalizeTypeM</tt>
--   computation.
withExtendedTypeVarEnv :: (HasUnique tyname TypeUnique, Monad m) => tyname -> Normalized (Type tyname uni ann) -> NormalizeTypeT m tyname uni ann a -> NormalizeTypeT m tyname uni ann a

-- | Normalize a <a>Type</a> in the <tt>NormalizeTypeM</tt> monad.
normalizeTypeM :: (HasUnique tyname TypeUnique, MonadQuote m, HasUniApply uni) => Type tyname uni ann -> NormalizeTypeT m tyname uni ann (Normalized (Type tyname uni ann))

-- | Substitute a type for a variable in a type and normalize in the
--   <tt>NormalizeTypeM</tt> monad.
substNormalizeTypeM :: (HasUnique tyname TypeUnique, MonadQuote m, HasUniApply uni) => Normalized (Type tyname uni ann) -> tyname -> Type tyname uni ann -> NormalizeTypeT m tyname uni ann (Normalized (Type tyname uni ann))

-- | Normalize every <a>Type</a> in a <a>Term</a>.
normalizeTypesInM :: (HasUnique tyname TypeUnique, MonadQuote m, HasUniApply uni) => Term tyname name uni fun ann -> NormalizeTypeT m tyname uni ann (Term tyname name uni fun ann)
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (PlutusCore.Normalize.Internal.NormalizeTypeEnv tyname uni ann) (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Alternative m => GHC.Base.Alternative (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Applicative m => GHC.Base.Applicative (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusCore.Normalize.Internal.NormalizeTypeT m tyname uni ann)


-- | The user-facing API of the normalizer.
module PlutusCore.Normalize

-- | Normalize a <a>Type</a>.
normalizeType :: (HasUnique tyname TypeUnique, MonadQuote m, HasUniApply uni) => Type tyname uni ann -> m (Normalized (Type tyname uni ann))

-- | Normalize every <a>Type</a> in a <a>Term</a>.
normalizeTypesIn :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadQuote m, HasUniApply uni) => Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Normalize every <a>Type</a> in a <a>Program</a>.
normalizeTypesInProgram :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadQuote m, HasUniApply uni) => Program tyname name uni fun ann -> m (Program tyname name uni fun ann)


-- | Machinery defined in this module allows to export mulptiple Plutus
--   Core definitions (types and terms) as a single value which enables
--   convenient testing of various procedures (pretty-printing, type
--   checking, etc): each time a function / data type is added to that
--   value, none of the tests is required to be adapted, instead all the
--   tests see the new definition automatically.
module PlutusCore.FsTree

-- | An <a>FsTree</a> is either a file or a folder with a list of
--   <a>FsTree</a>s inside.
data FsTree a
FsFolder :: String -> FolderContents a -> FsTree a
FsFile :: String -> a -> FsTree a

-- | The contents of a folder. A wrapper around <tt>[FsTree a]</tt>. Exists
--   because of its <a>Semigroup</a> instance which allows to concatenate
--   two <a>FolderContents</a>s without placing them into the same folder
--   immediately, so we can have various PLC "modules" (<tt>stdlib</tt>,
--   <tt>examples</tt>, etc), define compound modules (e.g. <tt>stdlib
--   &lt;&gt; examples</tt>) and run various tests (pretty-printing, type
--   synthesis, etc) against simple and compound modules uniformly.
newtype FolderContents a
FolderContents :: [FsTree a] -> FolderContents a
[unFolderContents] :: FolderContents a -> [FsTree a]

-- | A <a>PlcEntity</a> is either a <a>Type</a> or a <a>Term</a>.
data PlcEntity uni fun
PlcType :: Type TyName uni () -> PlcEntity uni fun
PlcTerm :: Term TyName Name uni fun () -> PlcEntity uni fun
type PlcFsTree uni fun = FsTree (PlcEntity uni fun)
type PlcFolderContents uni fun = FolderContents (PlcEntity uni fun)

-- | Construct an <a>FsTree</a> out of the name of a folder and a list of
--   <a>FsTree</a>s.
treeFolderContents :: String -> [FsTree a] -> FsTree a

-- | Construct a single-file <a>PlcFsTree</a> out of a type.
plcTypeFile :: String -> Type TyName uni () -> PlcFsTree uni fun

-- | Construct a single-file <a>PlcFsTree</a> out of a term.
plcTermFile :: String -> Term TyName Name uni fun () -> PlcFsTree uni fun

-- | Fold a <a>FsTree</a>.
foldFsTree :: (String -> [b] -> b) -> (String -> a -> b) -> FsTree a -> b

-- | Fold a <a>PlcFsTree</a>.
foldPlcFsTree :: (String -> [b] -> b) -> (String -> Type TyName uni () -> b) -> (String -> Term TyName Name uni fun () -> b) -> PlcFsTree uni fun -> b

-- | Fold the contents of a PLC folder.
foldPlcFolderContents :: (String -> [b] -> b) -> (String -> Type TyName uni () -> b) -> (String -> Term TyName Name uni fun () -> b) -> PlcFolderContents uni fun -> [b]
instance GHC.Base.Monoid (PlutusCore.FsTree.FolderContents a)
instance GHC.Base.Semigroup (PlutusCore.FsTree.FolderContents a)

module PlutusCore.Evaluation.Machine.ExMemory
type CostingInteger = SatInt

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU
newtype GenericExMemoryUsage a
GenericExMemoryUsage :: a -> GenericExMemoryUsage a
[getGenericExMemoryUsage] :: GenericExMemoryUsage a -> a
class ExMemoryUsage a
memoryUsage :: ExMemoryUsage a => a -> ExMemory
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Num.Num PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Classes.Ord PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Num.Num PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Classes.Ord PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance (PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage a, PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage b) => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (Data.Either.Either a b)
instance (PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage a, PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage b) => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (a, b)
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage PlutusCore.Name.Name
instance (PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage tyname, PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage ann) => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (PlutusCore.Core.Type.Type tyname uni ann)
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage ann => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (PlutusCore.Core.Type.Kind ann)
instance (PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage tyname, PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage name, PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage ann, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage, PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage fun) => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (PlutusCore.Core.Type.Term tyname name uni fun ann)
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage PlutusCore.Name.TyName
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage PlutusCore.Name.Unique
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage a => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage [a]
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage a => PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage (GHC.Generics.K1 i a)
instance (GHC.Generics.Generic a, PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage (GHC.Generics.Rep a)) => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (PlutusCore.Evaluation.Machine.ExMemory.GenericExMemoryUsage a)
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage Data.SatInt.SatInt
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (Universe.Core.SomeTypeIn uni)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage) => PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage (Data.Some.Newtype.Some (Universe.Core.ValueOf uni))
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage ()
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage GHC.Integer.Type.Integer
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage Data.ByteString.Internal.ByteString
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage Data.Text.Internal.Text
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage GHC.Types.Int
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage GHC.Types.Char
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage GHC.Types.Bool
instance PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage GHC.Generics.U1
instance PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage GHC.Generics.V1
instance PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage f => PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage (GHC.Generics.M1 i c f)
instance (PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage f, PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage g) => PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage (f GHC.Generics.:*: g)
instance (PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage f, PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage g) => PlutusCore.Evaluation.Machine.ExMemory.GExMemoryUsage (f GHC.Generics.:+: g)
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExMemory.ExCPU
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExMemory.ExMemory
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExMemory.ExMemory


-- | Note [Budgeting units]
--   
--   We use picoseconds for measuring times and words for measuring memory
--   usage. Some care is required with time units because different units
--   are used in different places.
--   
--   <ul>
--   <li>The basic data for models of execution time is produced by
--   Criterion benchmarks (run via plutus-core:cost-model-budgeting-bench)
--   and saved in 'benching.csv'. At this point the time units are
--   seconds.</li>
--   <li>The data in 'benching.csv' is used by
--   plutus-core:update-cost-model to create cost-prediction models for the
--   built-in functions, and data describing these is written to
--   builtinCostModel.json. This process involves several steps:<ul><li>The
--   CostModelCreation module reads in the data from 'benching.csv' and
--   runs R code in 'models.R' to fit linear models to the benchmark
--   results for each builtin. This process (and its results) necessarily
--   invloves the use of floating-point numbers.</li></ul>Builtin execution
--   times are typically of the order of 10^(-6) or 10^(-7) seconds, and
--   the benching data is converted to milliseconds in 'models.R' because
--   it's sometimes useful to work with the data interactively and this
--   makes the numbers a lot more human-readable.<ul><li>The coefficents
--   from the R models are returned to the Haskell code in
--   CostModelCreation and written out to costModel.json. To avoid the use
--   of floats in JSON and in cost prediction at runtime (which might be
--   machine-dependent if floats were used), numbers are multiplied by 10^6
--   and rounded to the nearest integer, shfting from the millisecond scale
--   to the picosecond scale. This rescaling is safe because all of our
--   models are (currently) linear in their inputs.</li></ul></li>
--   <li>When the Plutus Core evaluator is compiled, the JSON data in
--   'builtinCostModel.json' is read in and used to create the
--   defaultCostModel object. This also includes information about the
--   costs of basic CEK machine operations obtained from
--   'cekMachineCosts.json' (currently generated manually).</li>
--   <li>When the Plutus Core evaluator is run, the code in
--   PlutusCore.Evaluation.Machine.BuiltinCostModel uses the data in
--   defaultCostModel to create Haskell versions of the cost models which
--   estimate the execution time of a built-in function given the sizes of
--   its inputs. This (and the memory usage) are fed into a budgeting
--   process which measures the ongoing resource consumption during script
--   execution.</li>
--   </ul>
--   
--   All budget calculations are (at least on 64-bit machines) done using
--   the <tt>SatInt</tt> type which deals with overflow by truncating
--   excessivly large values to the maximum <tt>SatInt</tt> value, 2^63-1.
--   In picoseconds this is about 106 days, which should suffice for any
--   code we expect to run. Memory budgeting is entirely in terms of
--   machine words, and floating-point issues are irrelevant.
--   
--   Some precision is lost during the conversion from R's floating-point
--   models to the integral numbers used in the Haskell models. However,
--   experimentation shows that the difference is very small. The tests in
--   plutus-core: cost-model-test run the R models and the Haskell models
--   with a large number of random inputs and check that they agree to
--   within one part in 10,000, which is well within the accuracy we
--   require for the cost model.
module PlutusCore.Evaluation.Machine.ExBudget
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[_exBudgetCPU] :: ExBudget -> ExCPU
[_exBudgetMemory] :: ExBudget -> ExMemory

-- | A class for injecting a <tt>Builtin</tt> into an <tt>exBudgetCat</tt>.
--   We need it, because the constant application machinery calls
--   <tt>spendBudget</tt> before reducing a constant application and we
--   want to be general over <tt>exBudgetCat</tt> there, but still track
--   the built-in functions category, hence the ad hoc polymorphism.
class ExBudgetBuiltin fun exBudgetCat
exBudgetBuiltin :: ExBudgetBuiltin fun exBudgetCat => fun -> exBudgetCat
newtype ExRestrictingBudget
ExRestrictingBudget :: ExBudget -> ExRestrictingBudget
[unExRestrictingBudget] :: ExRestrictingBudget -> ExBudget

-- | When we want to just evaluate the program we use the
--   <tt>Restricting</tt> mode with an enormous budget, so that evaluation
--   costs of on-chain budgeting are reflected accurately in benchmarks.
enormousBudget :: ExRestrictingBudget
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance Text.PrettyBy.Internal.PrettyBy config PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Show.Show PlutusCore.Evaluation.Machine.ExBudget.ExRestrictingBudget
instance GHC.Base.Semigroup PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance GHC.Base.Monoid PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.ExBudget.ExBudget
instance PlutusCore.Evaluation.Machine.ExBudget.ExBudgetBuiltin fun ()

module PlutusCore.Evaluation.Machine.BuiltinCostModel
type BuiltinCostModel = BuiltinCostModelBase CostingFun

-- | The main model which contains all data required to predict the cost of
--   builtin functions. See Note [Creation of the Cost Model] for how this
--   is generated. Calibrated for the CEK machine.
data BuiltinCostModelBase f
BuiltinCostModelBase :: f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelOneArgument -> f ModelOneArgument -> f ModelThreeArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelTwoArguments -> f ModelThreeArguments -> BuiltinCostModelBase f
[paramAddInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramSubtractInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramMultiplyInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramDivideInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramQuotientInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramRemainderInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramModInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramLessThanInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramLessThanEqInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramGreaterThanInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramGreaterThanEqInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramEqInteger] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramConcatenate] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramTakeByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramDropByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramSHA2] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramSHA3] :: BuiltinCostModelBase f -> f ModelOneArgument
[paramVerifySignature] :: BuiltinCostModelBase f -> f ModelThreeArguments
[paramEqByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramLtByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramGtByteString] :: BuiltinCostModelBase f -> f ModelTwoArguments
[paramIfThenElse] :: BuiltinCostModelBase f -> f ModelThreeArguments
data CostingFun model
CostingFun :: model -> model -> CostingFun model
[costingFunCpu] :: CostingFun model -> model
[costingFunMemory] :: CostingFun model -> model

-- | s * (x + y) + I
data ModelAddedSizes
ModelAddedSizes :: CostingInteger -> CostingInteger -> ModelAddedSizes
[modelAddedSizesIntercept] :: ModelAddedSizes -> CostingInteger
[modelAddedSizesSlope] :: ModelAddedSizes -> CostingInteger

-- | s * (x - y) + I
data ModelSubtractedSizes
ModelSubtractedSizes :: CostingInteger -> CostingInteger -> CostingInteger -> ModelSubtractedSizes
[modelSubtractedSizesIntercept] :: ModelSubtractedSizes -> CostingInteger
[modelSubtractedSizesSlope] :: ModelSubtractedSizes -> CostingInteger
[modelSubtractedSizesMinimum] :: ModelSubtractedSizes -> CostingInteger
data ModelOrientation
ModelOrientationX :: ModelOrientation
ModelOrientationY :: ModelOrientation
data ModelLinearSize
ModelLinearSize :: CostingInteger -> CostingInteger -> ModelOrientation -> ModelLinearSize
[modelLinearSizeIntercept] :: ModelLinearSize -> CostingInteger
[modelLinearSizeSlope] :: ModelLinearSize -> CostingInteger

-- | x or y?
[modelLinearSizeOrientation] :: ModelLinearSize -> ModelOrientation

-- | s * (x * y) + I
data ModelMultipliedSizes
ModelMultipliedSizes :: CostingInteger -> CostingInteger -> ModelMultipliedSizes
[modelMultipliedSizesIntercept] :: ModelMultipliedSizes -> CostingInteger
[modelMultipliedSizesSlope] :: ModelMultipliedSizes -> CostingInteger

-- | s * min(x, y) + I
data ModelMinSize
ModelMinSize :: CostingInteger -> CostingInteger -> ModelMinSize
[modelMinSizeIntercept] :: ModelMinSize -> CostingInteger
[modelMinSizeSlope] :: ModelMinSize -> CostingInteger

-- | s * max(x, y) + I
data ModelMaxSize
ModelMaxSize :: CostingInteger -> CostingInteger -> ModelMaxSize
[modelMaxSizeIntercept] :: ModelMaxSize -> CostingInteger
[modelMaxSizeSlope] :: ModelMaxSize -> CostingInteger

-- | (if (x &gt; y) then s * (x + y) else 0) + I
data ModelSplitConst
ModelSplitConst :: CostingInteger -> CostingInteger -> ModelSplitConst
[modelSplitConstIntercept] :: ModelSplitConst -> CostingInteger
[modelSplitConstSlope] :: ModelSplitConst -> CostingInteger
data ModelOneArgument
ModelOneArgumentConstantCost :: CostingInteger -> ModelOneArgument
ModelOneArgumentLinearCost :: ModelLinearSize -> ModelOneArgument
data ModelTwoArguments
ModelTwoArgumentsConstantCost :: CostingInteger -> ModelTwoArguments
ModelTwoArgumentsAddedSizes :: ModelAddedSizes -> ModelTwoArguments
ModelTwoArgumentsSubtractedSizes :: ModelSubtractedSizes -> ModelTwoArguments
ModelTwoArgumentsMultipliedSizes :: ModelMultipliedSizes -> ModelTwoArguments
ModelTwoArgumentsMinSize :: ModelMinSize -> ModelTwoArguments
ModelTwoArgumentsMaxSize :: ModelMaxSize -> ModelTwoArguments
ModelTwoArgumentsSplitConstMulti :: ModelSplitConst -> ModelTwoArguments
ModelTwoArgumentsLinearSize :: ModelLinearSize -> ModelTwoArguments
data ModelThreeArguments
ModelThreeArgumentsConstantCost :: CostingInteger -> ModelThreeArguments
ModelThreeArgumentsAddedSizes :: ModelAddedSizes -> ModelThreeArguments
runCostingFunOneArgument :: CostingFun ModelOneArgument -> ExMemory -> ExBudget
runCostingFunTwoArguments :: CostingFun ModelTwoArguments -> ExMemory -> ExMemory -> ExBudget
runCostingFunThreeArguments :: CostingFun ModelThreeArguments -> ExMemory -> ExMemory -> ExMemory -> ExBudget
class Hashable a
instance Data.Aeson.Types.ToJSON.ToJSON model => Data.Aeson.Types.ToJSON.ToJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance Data.Aeson.Types.FromJSON.FromJSON model => Data.Aeson.Types.FromJSON.FromJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance Control.DeepSeq.NFData model => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance Data.Default.Class.Default model => Data.Default.Class.Default (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance Language.Haskell.TH.Syntax.Lift model => Language.Haskell.TH.Syntax.Lift (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance GHC.Classes.Eq model => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance GHC.Show.Show model => GHC.Show.Show (PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun model)
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelAddedSizes
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelAddedSizes
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelAddedSizes
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelAddedSizes
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelAddedSizes
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelAddedSizes
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelAddedSizes
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSubtractedSizes
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSubtractedSizes
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSubtractedSizes
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSubtractedSizes
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSubtractedSizes
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSubtractedSizes
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSubtractedSizes
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOrientation
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOrientation
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOrientation
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOrientation
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOrientation
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOrientation
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOrientation
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelLinearSize
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelLinearSize
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelLinearSize
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelLinearSize
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelLinearSize
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelLinearSize
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelLinearSize
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMultipliedSizes
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMultipliedSizes
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMultipliedSizes
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMultipliedSizes
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMultipliedSizes
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMultipliedSizes
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMultipliedSizes
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMinSize
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMinSize
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMinSize
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMinSize
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMinSize
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMinSize
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMinSize
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMaxSize
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMaxSize
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMaxSize
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMaxSize
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMaxSize
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMaxSize
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelMaxSize
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSplitConst
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSplitConst
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSplitConst
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSplitConst
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSplitConst
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSplitConst
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelSplitConst
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance Data.Aeson.Types.ToJSON.ToJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance Data.Aeson.Types.FromJSON.FromJSON PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance GHC.Show.Show PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance Barbies.Internal.ConstraintsB.ConstraintsB PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase
instance Barbies.Internal.TraversableB.TraversableB PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase
instance Barbies.Internal.FunctorB.FunctorB PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase
instance GHC.Generics.Generic (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance Data.Aeson.Types.ToJSON.ToJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun)
instance Data.Aeson.Types.FromJSON.FromJSON (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase PlutusCore.Evaluation.Machine.BuiltinCostModel.CostingFun)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels Control.DeepSeq.NFData f => Control.DeepSeq.NFData (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels Data.Default.Class.Default f => Data.Default.Class.Default (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels Language.Haskell.TH.Syntax.Lift f => Language.Haskell.TH.Syntax.Lift (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels GHC.Show.Show f => GHC.Show.Show (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance PlutusCore.Evaluation.Machine.BuiltinCostModel.AllArgumentModels GHC.Classes.Eq f => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.BuiltinCostModel.BuiltinCostModelBase f)
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelThreeArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelTwoArguments
instance Data.Default.Class.Default PlutusCore.Evaluation.Machine.BuiltinCostModel.ModelOneArgument

module PlutusCore.Error

-- | An error encountered during parsing.
data ParseError ann
LexErr :: String -> ParseError ann
Unexpected :: Token ann -> ParseError ann
UnknownBuiltinType :: ann -> Text -> ParseError ann
BuiltinTypeNotAStar :: ann -> Text -> ParseError ann
UnknownBuiltinFunction :: ann -> Text -> ParseError ann
InvalidBuiltinConstant :: ann -> Text -> Text -> ParseError ann
class AsParseError r_a3lvv ann_a3lep | r_a3lvv -> ann_a3lep
_ParseError :: AsParseError r_a3lvv ann_a3lep => Prism' r_a3lvv (ParseError ann_a3lep)
_LexErr :: AsParseError r_a3lvv ann_a3lep => Prism' r_a3lvv String
_Unexpected :: AsParseError r_a3lvv ann_a3lep => Prism' r_a3lvv (Token ann_a3lep)
_UnknownBuiltinType :: AsParseError r_a3lvv ann_a3lep => Prism' r_a3lvv (ann_a3lep, Text)
_BuiltinTypeNotAStar :: AsParseError r_a3lvv ann_a3lep => Prism' r_a3lvv (ann_a3lep, Text)
_UnknownBuiltinFunction :: AsParseError r_a3lvv ann_a3lep => Prism' r_a3lvv (ann_a3lep, Text)
_InvalidBuiltinConstant :: AsParseError r_a3lvv ann_a3lep => Prism' r_a3lvv (ann_a3lep, Text, Text)
data NormCheckError tyname name uni fun ann
BadType :: ann -> Type tyname uni ann -> Text -> NormCheckError tyname name uni fun ann
BadTerm :: ann -> Term tyname name uni fun ann -> Text -> NormCheckError tyname name uni fun ann
class AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM | r_a3mcw -> tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM
_NormCheckError :: AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM => Prism' r_a3mcw (NormCheckError tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM)
_BadType :: AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM => Prism' r_a3mcw (ann_a3lSM, Type tyname_a3lSI uni_a3lSK ann_a3lSM, Text)
_BadTerm :: AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM => Prism' r_a3mcw (ann_a3lSM, Term tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM, Text)
data UniqueError ann
MultiplyDefined :: Unique -> ann -> ann -> UniqueError ann
IncoherentUsage :: Unique -> ann -> ann -> UniqueError ann
FreeVariable :: Unique -> ann -> UniqueError ann
class AsUniqueError r_a3lSg ann_a3lwa | r_a3lSg -> ann_a3lwa
_UniqueError :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (UniqueError ann_a3lwa)
_MultiplyDefined :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa, ann_a3lwa)
_IncoherentUsage :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa, ann_a3lwa)
_FreeVariable :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa)
data TypeError term uni fun ann
KindMismatch :: ann -> Type TyName uni () -> Kind () -> Kind () -> TypeError term uni fun ann
TypeMismatch :: ann -> term -> Type TyName uni () -> Normalized (Type TyName uni ()) -> TypeError term uni fun ann
FreeTypeVariableE :: ann -> TyName -> TypeError term uni fun ann
FreeVariableE :: ann -> Name -> TypeError term uni fun ann
UnknownBuiltinFunctionE :: ann -> fun -> TypeError term uni fun ann
class AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 | r_a3mHv -> term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0
_TypeError :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (TypeError term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0)
_KindMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Type TyName uni_a3mcY (), Kind (), Kind ())
_TypeMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, term_a3mcX, Type TyName uni_a3mcY (), Normalized (Type TyName uni_a3mcY ()))
_FreeTypeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, TyName)
_FreeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Name)
_UnknownBuiltinFunctionE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, fun_a3mcZ)

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: Unique -> FreeVariableError
FreeIndex :: Index -> FreeVariableError
class AsFreeVariableError r_aVzL
_FreeVariableError :: AsFreeVariableError r_aVzL => Prism' r_aVzL FreeVariableError
_FreeUnique :: AsFreeVariableError r_aVzL => Prism' r_aVzL Unique
_FreeIndex :: AsFreeVariableError r_aVzL => Prism' r_aVzL Index
data Error uni fun ann
ParseErrorE :: ParseError ann -> Error uni fun ann
UniqueCoherencyErrorE :: UniqueError ann -> Error uni fun ann
TypeErrorE :: TypeError (Term TyName Name uni fun ()) uni fun ann -> Error uni fun ann
NormCheckErrorE :: NormCheckError TyName Name uni fun ann -> Error uni fun ann
FreeVariableErrorE :: FreeVariableError -> Error uni fun ann
class AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk | r_a3n86 -> uni_a3mIi fun_a3mIj ann_a3mIk
_Error :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (Error uni_a3mIi fun_a3mIj ann_a3mIk)
_ParseErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (ParseError ann_a3mIk)
_UniqueCoherencyErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (UniqueError ann_a3mIk)
_TypeErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (TypeError (Term TyName Name uni_a3mIi fun_a3mIj ()) uni_a3mIi fun_a3mIj ann_a3mIk)
_NormCheckErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (NormCheckError TyName Name uni_a3mIi fun_a3mIj ann_a3mIk)
_FreeVariableErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 FreeVariableError

-- | Lifts an <a>Either</a> into an error context where we can embed the
--   <a>Left</a> value into the error.
throwingEither :: MonadError e m => AReview e t -> Either t a -> m a
instance PlutusCore.Error.AsError (PlutusCore.Error.Error uni fun ann) uni fun ann
instance PlutusCore.Error.AsParseError (PlutusCore.Error.Error uni fun ann) ann
instance PlutusCore.Error.AsUniqueError (PlutusCore.Error.Error uni fun ann) ann
instance PlutusCore.Error.AsTypeError (PlutusCore.Error.Error uni fun ann) (PlutusCore.Core.Type.Term PlutusCore.Name.TyName PlutusCore.Name.Name uni fun ()) uni fun ann
instance (tyname GHC.Types.~ PlutusCore.Name.TyName, name GHC.Types.~ PlutusCore.Name.Name) => PlutusCore.Error.AsNormCheckError (PlutusCore.Error.Error uni fun ann) tyname name uni fun ann
instance PlutusCore.DeBruijn.Internal.AsFreeVariableError (PlutusCore.Error.Error uni fun ann)
instance Prettyprinter.Internal.Pretty ann => Prettyprinter.Internal.Pretty (PlutusCore.Error.ParseError ann)
instance Prettyprinter.Internal.Pretty ann => Prettyprinter.Internal.Pretty (PlutusCore.Error.UniqueError ann)
instance (Prettyprinter.Internal.Pretty ann, Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Core.Type.Type tyname uni ann), Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Core.Type.Term tyname name uni fun ann)) => Text.PrettyBy.Internal.PrettyBy config (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance (Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty ann, Prettyprinter.Internal.Pretty fun, Prettyprinter.Internal.Pretty term) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusCore.Error.TypeError term uni fun ann)
instance (Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun, Prettyprinter.Internal.Pretty ann) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusCore.Error.Error uni fun ann)
instance ErrorCode.HasErrorCode (PlutusCore.Error.ParseError _a)
instance ErrorCode.HasErrorCode (PlutusCore.Error.UniqueError _a)
instance ErrorCode.HasErrorCode (PlutusCore.Error.NormCheckError _a _b _c _d _e)
instance ErrorCode.HasErrorCode (PlutusCore.Error.TypeError _a _b _c _d)
instance ErrorCode.HasErrorCode (PlutusCore.Error.Error _a _b _c)
instance GHC.Base.Functor (PlutusCore.Error.Error uni fun)
instance (Universe.Core.Everywhere uni Control.DeepSeq.NFData, Universe.Core.Closed uni, Control.DeepSeq.NFData ann, Control.DeepSeq.NFData fun) => Control.DeepSeq.NFData (PlutusCore.Error.Error uni fun ann)
instance GHC.Generics.Generic (PlutusCore.Error.Error uni fun ann)
instance (Universe.Core.Everywhere uni GHC.Classes.Eq, Data.GADT.Internal.GEq uni, Universe.Core.Closed uni, GHC.Classes.Eq ann, GHC.Classes.Eq fun) => GHC.Classes.Eq (PlutusCore.Error.Error uni fun ann)
instance (Universe.Core.Everywhere uni GHC.Show.Show, Prettyprinter.Internal.Pretty ann, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, GHC.Show.Show ann, GHC.Show.Show fun) => GHC.Show.Show (PlutusCore.Error.Error uni fun ann)
instance PlutusCore.Error.AsTypeError (PlutusCore.Error.TypeError term uni fun ann) term uni fun ann
instance GHC.Base.Functor (PlutusCore.Error.TypeError term uni fun)
instance (Universe.Core.Closed uni, Control.DeepSeq.NFData ann, Control.DeepSeq.NFData term, Control.DeepSeq.NFData fun) => Control.DeepSeq.NFData (PlutusCore.Error.TypeError term uni fun ann)
instance GHC.Generics.Generic (PlutusCore.Error.TypeError term uni fun ann)
instance (Data.GADT.Internal.GEq uni, GHC.Classes.Eq ann, GHC.Classes.Eq term, GHC.Classes.Eq fun) => GHC.Classes.Eq (PlutusCore.Error.TypeError term uni fun ann)
instance (Data.GADT.Internal.GShow uni, GHC.Show.Show ann, GHC.Show.Show term, GHC.Show.Show fun) => GHC.Show.Show (PlutusCore.Error.TypeError term uni fun ann)
instance PlutusCore.Error.AsNormCheckError (PlutusCore.Error.NormCheckError tyname name uni fun ann) tyname name uni fun ann
instance (Universe.Core.Everywhere uni Control.DeepSeq.NFData, Universe.Core.Closed uni, Control.DeepSeq.NFData ann, Control.DeepSeq.NFData tyname, Control.DeepSeq.NFData name, Control.DeepSeq.NFData fun) => Control.DeepSeq.NFData (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance GHC.Generics.Generic (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance GHC.Base.Functor (PlutusCore.Error.NormCheckError tyname name uni fun)
instance (Universe.Core.Everywhere uni GHC.Show.Show, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, GHC.Show.Show ann, GHC.Show.Show tyname, GHC.Show.Show name, GHC.Show.Show fun) => GHC.Show.Show (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance (PlutusCore.Core.Type.HasUniques (PlutusCore.Core.Type.Term tyname name uni fun ann), Data.GADT.Internal.GEq uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni GHC.Classes.Eq, GHC.Classes.Eq fun, GHC.Classes.Eq ann) => GHC.Classes.Eq (PlutusCore.Error.NormCheckError tyname name uni fun ann)
instance PlutusCore.Error.AsUniqueError (PlutusCore.Error.UniqueError ann) ann
instance GHC.Base.Functor PlutusCore.Error.UniqueError
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (PlutusCore.Error.UniqueError ann)
instance GHC.Generics.Generic (PlutusCore.Error.UniqueError ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (PlutusCore.Error.UniqueError ann)
instance GHC.Show.Show ann => GHC.Show.Show (PlutusCore.Error.UniqueError ann)
instance PlutusCore.Error.AsParseError (PlutusCore.Error.ParseError ann) ann
instance Prettyprinter.Internal.Pretty ann => GHC.Show.Show (PlutusCore.Error.ParseError ann)
instance GHC.Base.Functor PlutusCore.Error.ParseError
instance Control.DeepSeq.NFData ann => Control.DeepSeq.NFData (PlutusCore.Error.ParseError ann)
instance GHC.Generics.Generic (PlutusCore.Error.ParseError ann)
instance GHC.Classes.Eq ann => GHC.Classes.Eq (PlutusCore.Error.ParseError ann)

module PlutusCore.Lexer
alexMonadScan :: Alex (Token AlexPosn)
runAlexST' :: forall a. ByteString -> Alex a -> StateT IdentifierState (Except (ParseError AlexPosn)) a
data AlexPosn
AlexPn :: !Int -> !Int -> !Int -> AlexPosn
newtype Alex a
Alex :: (AlexState -> Either String (AlexState, a)) -> Alex a
[unAlex] :: Alex a -> AlexState -> Either String (AlexState, a)
topAlexPosn :: AlexPosn
instance GHC.Show.Show PlutusCore.Lexer.AlexPosn
instance GHC.Classes.Eq PlutusCore.Lexer.AlexPosn
instance GHC.Generics.Generic PlutusCore.Lexer.AlexPosn
instance Control.DeepSeq.NFData PlutusCore.Lexer.AlexPosn
instance Language.Haskell.TH.Syntax.Lift PlutusCore.Lexer.AlexPosn
instance GHC.Classes.Ord PlutusCore.Lexer.AlexPosn
instance GHC.Base.Functor PlutusCore.Lexer.Alex
instance GHC.Base.Applicative PlutusCore.Lexer.Alex
instance GHC.Base.Monad PlutusCore.Lexer.Alex
instance Control.Monad.State.Class.MonadState PlutusCore.Lexer.AlexState PlutusCore.Lexer.Alex
instance Prettyprinter.Internal.Pretty PlutusCore.Lexer.AlexPosn


-- | Support for using de Bruijn indices for term and type names.
module PlutusCore.DeBruijn

-- | A relative index used for de Bruijn identifiers.
newtype Index
Index :: Natural -> Index

-- | A term name as a de Bruijn index, without the name string.
newtype DeBruijn
DeBruijn :: Index -> DeBruijn
[dbnIndex] :: DeBruijn -> Index

-- | A term name as a de Bruijn index.
data NamedDeBruijn
NamedDeBruijn :: Text -> Index -> NamedDeBruijn
[ndbnString] :: NamedDeBruijn -> Text
[ndbnIndex] :: NamedDeBruijn -> Index

-- | A type name as a de Bruijn index, without the name string.
newtype TyDeBruijn
TyDeBruijn :: DeBruijn -> TyDeBruijn

-- | A type name as a de Bruijn index.
newtype NamedTyDeBruijn
NamedTyDeBruijn :: NamedDeBruijn -> NamedTyDeBruijn

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: Unique -> FreeVariableError
FreeIndex :: Index -> FreeVariableError
class AsFreeVariableError r_aVzL
_FreeVariableError :: AsFreeVariableError r_aVzL => Prism' r_aVzL FreeVariableError
_FreeUnique :: AsFreeVariableError r_aVzL => Prism' r_aVzL Unique
_FreeIndex :: AsFreeVariableError r_aVzL => Prism' r_aVzL Index

-- | Convert a <a>Type</a> with <a>TyName</a>s into a <a>Type</a> with
--   <a>NamedTyDeBruijn</a>s.
deBruijnTy :: (AsFreeVariableError e, MonadError e m) => Type TyName uni ann -> m (Type NamedTyDeBruijn uni ann)

-- | Convert a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Term</a> with <a>NamedTyDeBruijn</a>s and <a>NamedDeBruijn</a>s.
deBruijnTerm :: (AsFreeVariableError e, MonadError e m) => Term TyName Name uni fun ann -> m (Term NamedTyDeBruijn NamedDeBruijn uni fun ann)

-- | Convert a <a>Program</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Program</a> with <a>NamedTyDeBruijn</a>s and <a>NamedDeBruijn</a>s.
deBruijnProgram :: (AsFreeVariableError e, MonadError e m) => Program TyName Name uni fun ann -> m (Program NamedTyDeBruijn NamedDeBruijn uni fun ann)

-- | Convert a <a>Type</a> with <a>NamedTyDeBruijn</a>s into a <a>Type</a>
--   with <a>TyName</a>s.
unDeBruijnTy :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Type NamedTyDeBruijn uni ann -> m (Type TyName uni ann)

-- | Convert a <a>Term</a> with <a>NamedTyDeBruijn</a>s and
--   <a>NamedDeBruijn</a>s into a <a>Term</a> with <a>TyName</a>s and
--   <a>Name</a>s.
unDeBruijnTerm :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Term NamedTyDeBruijn NamedDeBruijn uni fun ann -> m (Term TyName Name uni fun ann)

-- | Convert a <a>Program</a> with <a>NamedTyDeBruijn</a>s and
--   <a>NamedDeBruijn</a>s into a <a>Program</a> with <a>TyName</a>s and
--   <a>Name</a>s.
unDeBruijnProgram :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Program NamedTyDeBruijn NamedDeBruijn uni fun ann -> m (Program TyName Name uni fun ann)
unNameDeBruijn :: NamedDeBruijn -> DeBruijn
unNameTyDeBruijn :: NamedTyDeBruijn -> TyDeBruijn
fakeNameDeBruijn :: DeBruijn -> NamedDeBruijn


-- | Flat instances for Plutus Core types. Make sure to read the Note
--   [Stable encoding of PLC] before touching anything in this file. Also
--   see the Notes [Serialising unit annotations] and [Serialising Scripts]
--   before using anything in this file.
module PlutusCore.Flat
encode :: Flat a => a -> Encoding
decode :: Flat a => Get a
safeEncodeBits :: NumBits -> Word8 -> Encoding
instance Flat.Class.Flat a => Flat.Class.Flat (PlutusCore.Core.Type.Normalized a)
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.Index
instance Universe.Core.Closed uni => Flat.Class.Flat (Universe.Core.SomeTypeIn uni)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat) => Flat.Class.Flat (Data.Some.Newtype.Some (Universe.Core.ValueOf uni))
instance Flat.Class.Flat PlutusCore.Name.Unique
instance Flat.Class.Flat PlutusCore.Name.Name
instance Flat.Class.Flat PlutusCore.Name.TyName
instance Flat.Class.Flat ann => Flat.Class.Flat (PlutusCore.Core.Type.Version ann)
instance Flat.Class.Flat ann => Flat.Class.Flat (PlutusCore.Core.Type.Kind ann)
instance (Universe.Core.Closed uni, Flat.Class.Flat ann, Flat.Class.Flat tyname) => Flat.Class.Flat (PlutusCore.Core.Type.Type tyname uni ann)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat fun, Flat.Class.Flat ann, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusCore.Core.Type.Term tyname name uni fun ann)
instance (Universe.Core.Closed uni, Flat.Class.Flat fun, Flat.Class.Flat ann, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusCore.MkPlc.VarDecl tyname name uni fun ann)
instance (Flat.Class.Flat ann, Flat.Class.Flat tyname) => Flat.Class.Flat (PlutusCore.MkPlc.TyVarDecl tyname ann)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat fun, Flat.Class.Flat ann, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusCore.Core.Type.Program tyname name uni fun ann)
instance Flat.Class.Flat a => Flat.Class.Flat (PlutusCore.Lexer.Type.Token a)
instance Flat.Class.Flat PlutusCore.Lexer.Type.Keyword
instance Flat.Class.Flat PlutusCore.Lexer.Type.Special
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.DeBruijn
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.NamedDeBruijn
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.TyDeBruijn
instance Flat.Class.Flat PlutusCore.DeBruijn.Internal.NamedTyDeBruijn

module PlutusCore.Check.Value
isTermValue :: Term tyname name uni fun ann -> Bool


-- | This module makes sure types are normalized inside programs.
module PlutusCore.Check.Normal

-- | Ensure that all types in the <a>Program</a> are normalized.
checkProgram :: (AsNormCheckError e tyname name uni fun ann, MonadError e m) => Program tyname name uni fun ann -> m ()

-- | Ensure that all types in the <a>Term</a> are normalized.
checkTerm :: (AsNormCheckError e tyname name uni fun ann, MonadError e m) => Term tyname name uni fun ann -> m ()
isNormalType :: Type tyname uni ann -> Bool
data NormCheckError tyname name uni fun ann
BadType :: ann -> Type tyname uni ann -> Text -> NormCheckError tyname name uni fun ann
BadTerm :: ann -> Term tyname name uni fun ann -> Text -> NormCheckError tyname name uni fun ann

module PlutusCore.Check.Uniques
checkProgram :: (Ord ann, HasUnique name TermUnique, HasUnique tyname TypeUnique, AsUniqueError e ann, MonadError e m) => (UniqueError ann -> Bool) -> Program tyname name uni fun ann -> m ()
checkTerm :: (Ord ann, HasUnique name TermUnique, HasUnique tyname TypeUnique, AsUniqueError e ann, MonadError e m) => (UniqueError ann -> Bool) -> Term tyname name uni fun ann -> m ()
checkType :: (Ord ann, HasUnique tyname TypeUnique, AsUniqueError e ann, MonadError e m) => (UniqueError ann -> Bool) -> Type tyname uni ann -> m ()
data UniqueError ann
MultiplyDefined :: Unique -> ann -> ann -> UniqueError ann
IncoherentUsage :: Unique -> ann -> ann -> UniqueError ann
FreeVariable :: Unique -> ann -> UniqueError ann
class AsUniqueError r_a3lSg ann_a3lwa | r_a3lSg -> ann_a3lwa
_UniqueError :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (UniqueError ann_a3lwa)
_MultiplyDefined :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa, ann_a3lwa)
_IncoherentUsage :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa, ann_a3lwa)
_FreeVariable :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa)


-- | <tt>nat</tt> and related functions.
module PlutusCore.StdLib.Data.Nat

-- | <tt>Nat</tt> as a PLC type.
--   
--   <pre>
--   fix \(nat :: *) -&gt; all r. r -&gt; (nat -&gt; r) -&gt; r
--   </pre>
natData :: RecursiveType uni fun ()
natTy :: Type TyName uni ()

-- | '0' as a PLC term.
--   
--   <pre>
--   wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; z
--   </pre>
zero :: TermLike term TyName Name uni fun => term ()

-- | <a>succ</a> as a PLC term.
--   
--   <pre>
--   \(n : nat) -&gt; wrapNat [] /\(r :: *) -&gt; \(z : r) (f : nat -&gt; r) -&gt; f n
--   </pre>
succ :: TermLike term TyName Name uni fun => term ()

-- | <tt>foldrNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) (z : r) -&gt;
--       fix {nat} {r} \(rec : nat -&gt; r) (n : nat) -&gt;
--           unwrap n {r} z \(n' : nat) -&gt; f (rec n')
--   </pre>
foldrNat :: TermLike term TyName Name uni fun => term ()

-- | <tt>foldNat</tt> as a PLC term.
--   
--   <pre>
--   /\(r :: *) -&gt; \(f : r -&gt; r) -&gt;
--       fix {r} {nat -&gt; r} \(rec : r -&gt; nat -&gt; r) (z : r) (n : nat) -&gt;
--           unwrap n {r} z (\(n' : nat) -&gt; rec (f z) n')
--   </pre>
foldNat :: TermLike term TyName Name uni fun => term ()

-- | Convert a <tt>nat</tt> to an <tt>integer</tt>.
--   
--   <pre>
--   foldNat {integer} (addInteger 1) 1
--   </pre>
natToInteger :: (TermLike term TyName Name uni DefaultFun, uni `Includes` Integer) => term ()


-- | Functions related to <tt>integer</tt>.
module PlutusCore.StdLib.Data.Integer
integer :: uni `Includes` Integer => Type tyname uni ()

-- | <tt>succ :: Integer -&gt; Integer</tt> as a PLC term.
--   
--   <pre>
--   \(i : integer) -&gt; addInteger i 1
--   </pre>
succInteger :: (TermLike term TyName Name uni DefaultFun, uni `Includes` Integer) => term ()


-- | <tt>boolean</tt> and related functions.
module PlutusCore.StdLib.Data.Bool

-- | <a>Bool</a> as a PLC type.
bool :: uni `Includes` Bool => Type TyName uni ()

-- | <a>True</a> as a PLC term.
true :: (TermLike term TyName Name uni fun, uni `Includes` Bool) => term ()

-- | <a>False</a> as a PLC term.
false :: (TermLike term TyName Name uni fun, uni `Includes` Bool) => term ()

-- | <tt>if_then_else_</tt> as a PLC term.
--   
--   <pre>
--   /\(A :: *) -&gt; \(b : Bool) (x y : () -&gt; A) -&gt; IfThenElse {() -&gt; A} b x y ()
--   </pre>
ifThenElse :: (TermLike term TyName Name uni DefaultFun, uni `Includes` Bool, uni `Includes` ()) => term ()


-- | <tt>list</tt> and related functions.
module PlutusCore.StdLib.Data.List

-- | <tt>List</tt> as a PLC type.
--   
--   <pre>
--   fix \(list :: * -&gt; *) (a :: *) -&gt; all (r :: *). r -&gt; (a -&gt; list a -&gt; r) -&gt; r
--   </pre>
listData :: RecursiveType uni fun ()
listTy :: Type TyName uni ()

-- | '[]' as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; z)
--   </pre>
nil :: TermLike term TyName Name uni fun => term ()

-- | <tt>(:)</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(x : a) (xs : list a) -&gt;
--       wrapList [a] /\(r :: *) -&gt; \(z : r) (f : a -&gt; list a -&gt; r) -&gt; f x xs
--   </pre>
cons :: TermLike term TyName Name uni fun => term ()

-- | <tt>foldrList</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : a -&gt; r -&gt; r) (z : r) -&gt;
--       fix {list a} {r} \(rec : list a -&gt; r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; f x (rec xs')
--   </pre>
foldrList :: TermLike term TyName Name uni fun => term ()

-- | 'foldl'' as a PLC term.
--   
--   <pre>
--   /\(a :: *) (r :: *) -&gt; \(f : r -&gt; a -&gt; r) -&gt;
--       fix {r} {list a -&gt; r} \(rec : r -&gt; list a -&gt; r) (z : r) (xs : list a) -&gt;
--           unwrap xs {r} z \(x : a) (xs' : list a) -&gt; rec (f z x) xs'
--   </pre>
foldList :: TermLike term TyName Name uni fun => term ()

-- | <tt>map</tt> as a PLC term.
--   
--   <pre>
--   /\(a :: *) (b :: *) -&gt; \(f : a -&gt; b) -&gt;
--       foldrList {a} {list b} (\(x : a) -&gt; cons {b} (f x)) (nil {b})
--   </pre>
map :: TermLike term TyName Name uni fun => term ()

-- | <a>reverse</a> as a PLC term.
--   
--   <pre>
--   /\(a :: *) -&gt; \(xs : list a) -&gt;
--       foldList {a} {list a} (\(r : list a) (x : a) -&gt; cons {a} x r) (nil {a})
--   </pre>
reverse :: TermLike term TyName Name uni fun => term ()

-- | <a>enumFromTo</a> as a PLC term
--   
--   <pre>
--   \(n m : integer) -&gt;
--       fix {integer} {list (integer)}
--           (\(rec : integer -&gt; list (integer)) (n' : integer) -&gt;
--               ifThenElse {list (integer)}
--                   (greaterThanInteger n' m)
--                   (nil {integer})
--                   (cons {integer} n' (rec (succInteger n'))))
--           n
--   </pre>
enumFromTo :: (TermLike term TyName Name uni DefaultFun, uni `Includes` Integer, uni `Includes` (), uni `Includes` Bool) => term ()

-- | <a>sum</a> as a PLC term.
--   
--   <pre>
--   foldList {integer} {integer} addInteger 0
--   </pre>
sum :: (TermLike term TyName Name uni DefaultFun, uni `Includes` Integer) => term ()

-- | <a>product</a> as a PLC term.
--   
--   <pre>
--   foldList {integer} {integer} multiplyInteger 1
--   </pre>
product :: (TermLike term TyName Name uni DefaultFun, uni `Includes` Integer) => term ()


-- | Functions that generate Plutus Core terms from Haskell values and vice
--   versa.
module PlutusCore.StdLib.Meta

-- | Convert an <a>Integer</a> to a <tt>nat</tt>. TODO: convert PLC's
--   <tt>integer</tt> to <tt>nat</tt> instead.
metaIntegerToNat :: TermLike term TyName Name uni fun => Integer -> term ()

-- | Convert a Haskell <a>Either</a> to a PLC <tt>sum</tt>.
metaEitherToSum :: TermLike term TyName Name uni fun => Type TyName uni () -> Type TyName uni () -> Either (term ()) (term ()) -> term ()

-- | Convert a Haskell list of <a>Term</a>s to a PLC <tt>list</tt>.
metaListToList :: TermLike term TyName Name uni fun => Type TyName uni () -> [term ()] -> term ()

module PlutusCore.Default

-- | The universe used by default.
data DefaultUni a
[DefaultUniInteger] :: DefaultUni (Esc Integer)
[DefaultUniByteString] :: DefaultUni (Esc ByteString)
[DefaultUniChar] :: DefaultUni (Esc Char)
[DefaultUniUnit] :: DefaultUni (Esc ())
[DefaultUniBool] :: DefaultUni (Esc Bool)
[DefaultUniProtoList] :: DefaultUni (Esc [])
[DefaultUniProtoPair] :: DefaultUni (Esc (,))
[DefaultUniApply] :: !DefaultUni (Esc f) -> !DefaultUni (Esc a) -> DefaultUni (Esc (f a))
pattern DefaultUniList :: forall a k1 k2 (f :: k1 -> k2) (a1 :: k1). () => (a ~ Esc (f a1), Esc f ~ Esc []) => DefaultUni (Esc a1) -> DefaultUni a
pattern DefaultUniPair :: forall a k1 k2 (f1 :: k1 -> k2) (a1 :: k1) k3 k4 (f2 :: k3 -> k4) (a2 :: k3). () => (a ~ Esc (f1 a1), Esc f1 ~ Esc (f2 a2), Esc f2 ~ Esc (,)) => DefaultUni (Esc a2) -> DefaultUni (Esc a1) -> DefaultUni a
pattern DefaultUniString :: forall a k1 k2 (f :: k1 -> k2) (a1 :: k1). () => (a ~ Esc (f a1), Esc f ~ Esc [], Esc a1 ~ Esc Char) => DefaultUni a

-- | Default built-in functions.
data DefaultFun
AddInteger :: DefaultFun
SubtractInteger :: DefaultFun
MultiplyInteger :: DefaultFun
DivideInteger :: DefaultFun
QuotientInteger :: DefaultFun
RemainderInteger :: DefaultFun
ModInteger :: DefaultFun
LessThanInteger :: DefaultFun
LessThanEqInteger :: DefaultFun
GreaterThanInteger :: DefaultFun
GreaterThanEqInteger :: DefaultFun
EqInteger :: DefaultFun
Concatenate :: DefaultFun
TakeByteString :: DefaultFun
DropByteString :: DefaultFun
SHA2 :: DefaultFun
SHA3 :: DefaultFun
VerifySignature :: DefaultFun
EqByteString :: DefaultFun
LtByteString :: DefaultFun
GtByteString :: DefaultFun
IfThenElse :: DefaultFun
CharToString :: DefaultFun
Append :: DefaultFun
EqualsString :: DefaultFun
EncodeUtf8 :: DefaultFun
DecodeUtf8 :: DefaultFun
Trace :: DefaultFun
Nop1 :: DefaultFun
Nop2 :: DefaultFun
Nop3 :: DefaultFun

-- | Turn a function into another function that returns
--   <a>EvaluationFailure</a> when its second argument is 0 or calls the
--   original function otherwise and wraps the result in
--   <a>EvaluationSuccess</a>. Useful for correctly handling <a>div</a>,
--   <a>mod</a>, etc.
nonZeroArg :: (Integer -> Integer -> Integer) -> Integer -> Integer -> EvaluationResult Integer

-- | Using 5 bits to encode builtin tags.
builtinTagWidth :: NumBits
encodeBuiltin :: Word8 -> Encoding
decodeBuiltin :: Get Word8


-- | This module exports everything from the stdlib via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire stdlib in a convenient way: each time a function
--   / data type is added to the stdlib, none of the tests is required to
--   be adapted, instead you just add the new definition to <a>stdLib</a>
--   defined below and all the tests see it automatically.
module PlutusCore.StdLib.Everything

-- | The entire stdlib exported as a single value.
stdLib :: PlcFolderContents DefaultUni DefaultFun

module PlutusCore.Parser

-- | Parse a PLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseProgram :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program TyName Name DefaultUni DefaultFun AlexPosn)

-- | Parse a PLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Term TyName Name DefaultUni DefaultFun AlexPosn)

-- | Parse a PLC type. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseType :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Type TyName DefaultUni AlexPosn)

-- | An error encountered during parsing.
data ParseError ann
LexErr :: String -> ParseError ann
Unexpected :: Token ann -> ParseError ann
UnknownBuiltinType :: ann -> Text -> ParseError ann
BuiltinTypeNotAStar :: ann -> Text -> ParseError ann
UnknownBuiltinFunction :: ann -> Text -> ParseError ann
InvalidBuiltinConstant :: ann -> Text -> Text -> ParseError ann

-- | An <a>IdentifierState</a> includes a map indexed by <a>Int</a>s as
--   well as a map indexed by <tt>ByteString</tt>s. It is used during
--   parsing.
type IdentifierState = (Map Text Unique, Unique)
emptyIdentifierState :: IdentifierState


-- | Reexports from modules from the <tt>Constant</tt> folder.
module PlutusCore.Constant

-- | Type schemes of primitive operations. <tt>as</tt> is a list of types
--   of arguments, <tt>r</tt> is the resulting type. E.g. <tt>Char -&gt;
--   Bool -&gt; Integer</tt> is encoded as <tt>TypeScheme term [Char, Bool]
--   Integer</tt>.
data TypeScheme term (args :: [Type]) res
[TypeSchemeResult] :: KnownType term res => Proxy res -> TypeScheme term '[] res
[TypeSchemeArrow] :: KnownType term arg => Proxy arg -> TypeScheme term args res -> TypeScheme term (arg : args) res
[TypeSchemeAll] :: (KnownSymbol text, KnownNat uniq, KnownKind kind) => Proxy '(text, uniq, kind) -> (forall ot. ot ~ TyVarRep ('TyNameRep @kind text uniq) => Proxy ot -> TypeScheme term args res) -> TypeScheme term args res
infixr 9 `TypeSchemeArrow`

-- | Turn a list of Haskell types <tt>args</tt> into a functional type
--   ending in <tt>res</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; :kind! FoldArgs [Char, Bool] Integer
--   FoldArgs [Char, Bool] Integer :: *
--   = Char -&gt; Bool -&gt; Integer
--   </pre>
type family FoldArgs args res

-- | Calculates the parameters of the costing function for a builtin.
type family FoldArgsEx args

-- | Representation of a type variable: its name and unique and an implicit
--   kind.
data TyNameRep (kind :: Type)
TyNameRep :: Symbol -> Nat -> TyNameRep (kind :: Type)

-- | Representation of an intrinsically-kinded type variable: a name.
data family TyVarRep (var :: TyNameRep kind) :: kind

-- | Representation of an intrinsically-kinded type application: a function
--   and an argument.
data family TyAppRep (fun :: dom -> cod) (arg :: dom) :: cod

-- | Representation of of an intrinsically-kinded universal quantifier: a
--   bound name and a body.
data family TyForallRep (var :: TyNameRep kind) (a :: Type) :: Type

-- | The denotation of a term whose PLC type is encoded in <tt>rep</tt>
--   (for example a type variable or an application of a type variable).
--   I.e. the denotation of such a term is the term itself. This is because
--   we have parametricity in Haskell, so we can't inspect a value whose
--   type is, say, a bound variable, so we never need to convert such a
--   term from Plutus Core to Haskell and back and instead can keep it
--   intact.
newtype Opaque term (rep :: Type)
Opaque :: term -> Opaque term (rep :: Type)
[unOpaque] :: Opaque term (rep :: Type) -> term

-- | Throw an <a>UnliftingError</a> saying that the received argument is
--   not a constant.
throwNotAConstant :: (MonadError (ErrorWithCause err term) m, AsUnliftingError err) => term -> m r
class AsConstant term

-- | Unlift from the <a>Constant</a> constructor throwing an
--   <a>UnliftingError</a> if the provided <tt>term</tt> is not a
--   <a>Constant</a>.
asConstant :: (AsConstant term, MonadError (ErrorWithCause err term) m, AsUnliftingError err) => term -> m (Some (ValueOf (UniOf term)))
class FromConstant term

-- | Wrap a Haskell value as a <tt>term</tt>.
fromConstant :: FromConstant term => Some (ValueOf (UniOf term)) -> term

-- | Ensures that <tt>term</tt> has a <a>Constant</a>-like constructor to
--   lift values to and unlift values from.
--   
--   <a>AsConstant</a> and <a>FromConstant</a> are separate, because we
--   need only one instance of <a>AsConstant</a> per <a>Term</a>-like type
--   and <a>FromConstant</a> requires as many instances as there are
--   different kinds of annotations (we're mostly interested in
--   <a>ExMemory</a> and <tt>()</tt>). Originally we had a single type
--   class but it proved to be less efficient than having two of them.
type HasConstant term = (AsConstant term, FromConstant term)

-- | Ensures that <tt>term</tt> has a <a>Constant</a>-like constructor to
--   lift values to and unlift values from and connects <tt>term</tt> and
--   its <tt>uni</tt>.
type HasConstantIn uni term = (UniOf term ~ uni, HasConstant term)
class KnownTypeAst uni (a :: k)

-- | The type representing <tt>a</tt> used on the PLC side.
toTypeAst :: KnownTypeAst uni a => proxy a -> Type TyName uni ()

-- | The type representing <tt>a</tt> used on the PLC side.
toTypeAst :: (KnownTypeAst uni a, uni `Contains` a) => proxy a -> Type TyName uni ()

-- | Haskell types known to exist on the PLC side.
class KnownTypeAst (UniOf term) a => KnownType term a

-- | Convert a Haskell value to the corresponding PLC term. The inverse of
--   <a>readKnown</a>.
makeKnown :: (KnownType term a, MonadEmitter m, MonadError err m, AsEvaluationFailure err) => a -> m term

-- | Convert a Haskell value to the corresponding PLC term. The inverse of
--   <a>readKnown</a>.
makeKnown :: (KnownType term a, MonadError err m, KnownBuiltinType term a) => a -> m term

-- | Convert a PLC term to the corresponding Haskell value. The inverse of
--   <a>makeKnown</a>.
readKnown :: (KnownType term a, MonadError (ErrorWithCause err term) m, AsUnliftingError err, AsEvaluationFailure err) => term -> m a

-- | Convert a PLC term to the corresponding Haskell value. The inverse of
--   <a>makeKnown</a>.
readKnown :: (KnownType term a, MonadError (ErrorWithCause err term) m, AsUnliftingError err, KnownBuiltinType term a) => term -> m a
makeKnownNoEmit :: (KnownType term a, MonadError err m, AsEvaluationFailure err) => a -> m term

-- | For unlifting from the <a>Constant</a> constructor. For cases where we
--   care about having a type tag in the denotation of a builtin rather
--   than full unlifting to a specific built-in type.
--   
--   The <tt>rep</tt> parameter specifies how the type looks on the PLC
--   side (i.e. just like with <tt>Opaque term rep</tt>).
newtype SomeConstant uni rep
SomeConstant :: Some (ValueOf uni) -> SomeConstant uni rep
[unSomeConstant] :: SomeConstant uni rep -> Some (ValueOf uni)

-- | <a>SomeConstantOf</a> is similar to <a>SomeConstant</a>: while the
--   latter is for unlifting any constants, the former is for unlifting
--   constants of a specific polymorphic built-in type (the <tt>f</tt>
--   parameter).
--   
--   A <tt>SomeConstantOf uni f reps</tt> is a value of existentially
--   instantiated <tt>f</tt>. For instance, a <tt>SomeConstantOf uni []
--   reps</tt> is a list of something (a list of integers or a list of
--   lists of booleans etc). And a <tt>SomeConstantOf uni (,) reps</tt> is
--   a tuple of something.
--   
--   The <tt>reps</tt> parameter serves two purposes: its main purpose is
--   to specify how the argument types look on the PLC side (i.e. it's the
--   same thing as with <tt>Opaque term rep</tt>), so that we can apply the
--   type of built-in lists to a PLC type variable for example. The
--   secondary purpose is ensuring type safety via indexing: a value of
--   <tt>SomeConstantOf uni f reps</tt> can be viewed as a proof that the
--   amount of arguments <tt>f</tt> expects and the length of <tt>reps</tt>
--   are the same number (we could go even further and compute the kind of
--   <tt>f</tt> from <tt>reps</tt>, but it doesn't seem like that would
--   give us any more type safety while it certainly would be a more
--   complex thing to do).
--   
--   The existential Haskell types <tt>f</tt> is applied to are reified as
--   type tags from <tt>uni</tt>. Note however that the correspondence
--   between the Haskell types and the PLC ones from <tt>reps</tt> is not
--   demanded and this is by design: during evaluation (i.e. on the Haskell
--   side of things) we always have concrete type tags, but at Plutus
--   compile time an argument to <tt>f</tt> can be a Plutus type variable
--   and so we can't establish any connection between the type tag that
--   we'll end up having at runtime and a Plutus type variable that we have
--   at compile time. Which also implies that one can specify that a
--   built-in function takes, say, a tuple of a type variable and a
--   boolean, but in the actual denotation unlift to a tuple of a unit and
--   an integer (boolean vs integer) and there won't be any Haskell type
--   error for that, let alone a Plutus type error -- it'll be an
--   evaluation failure, maybe even a delayed one. So be careful in the
--   denotation of a builtin to unlift its arguments to what you promised
--   to unlift them to in its type signature.
data SomeConstantOf uni f reps
[SomeConstantOfRes] :: uni (Esc b) -> b -> SomeConstantOf uni b '[]
[SomeConstantOfArg] :: uni (Esc a) -> SomeConstantOf uni (f a) reps -> SomeConstantOf uni f (rep : reps)

-- | The meaning of a built-in function consists of its type represented as
--   a <a>TypeScheme</a>, its Haskell denotation and a costing function
--   (both in uninstantiated form).
--   
--   The <a>TypeScheme</a> of a built-in function is used for
--   
--   <ol>
--   <li>computing the PLC type of the function to be used during type
--   checking</li>
--   <li>checking equality of the expected type of an argument of a builtin
--   and the actual one during evaluation, so that we can avoid
--   unsafe-coercing</li>
--   </ol>
--   
--   A costing function for a built-in function is computed from a cost
--   model for all built-in functions from a certain set, hence the
--   <tt>cost</tt> parameter.
data BuiltinMeaning term cost
BuiltinMeaning :: TypeScheme term args res -> FoldArgs args res -> (cost -> FoldArgsEx args) -> BuiltinMeaning term cost

-- | A <a>BuiltinRuntime</a> represents a possibly partial builtin
--   application. We get an initial <a>BuiltinRuntime</a> representing an
--   empty builtin application (i.e. just the builtin with no arguments) by
--   instantiating (via <a>toBuiltinRuntime</a>) a <a>BuiltinMeaning</a>.
--   
--   A <a>BuiltinRuntime</a> contains info that is used during evaluation:
--   
--   <ol>
--   <li>the <a>TypeScheme</a> of the uninstantiated part of the builtin.
--   I.e. initially it's the type scheme of the whole builtin, but applying
--   or type-instantiating the builtin peels off the corresponding
--   constructor from the type scheme</li>
--   <li>the (possibly partially instantiated) denotation</li>
--   <li>the (possibly partially instantiated) costing function</li>
--   </ol>
--   
--   All the three are in sync in terms of partial instantiatedness due to
--   <a>TypeScheme</a> being a GADT and <a>FoldArgs</a> and
--   <a>FoldArgsEx</a> operating on the index of that GADT.
data BuiltinRuntime term
BuiltinRuntime :: TypeScheme term args res -> FoldArgs args res -> FoldArgsEx args -> BuiltinRuntime term

-- | A <a>BuiltinRuntime</a> for each builtin from a set of builtins.
newtype BuiltinsRuntime fun term
BuiltinsRuntime :: Array fun (BuiltinRuntime term) -> BuiltinsRuntime fun term
[unBuiltinRuntime] :: BuiltinsRuntime fun term -> Array fun (BuiltinRuntime term)

-- | Instantiate a <a>BuiltinMeaning</a> given denotations of built-in
--   functions and a cost model.
toBuiltinRuntime :: cost -> BuiltinMeaning term cost -> BuiltinRuntime term

-- | A type class for "each function from a set of built-in functions has a
--   <a>BuiltinMeaning</a>".
class (Bounded fun, Enum fun, Ix fun) => ToBuiltinMeaning uni fun where {
    
    -- | The <tt>cost</tt> part of <a>BuiltinMeaning</a>.
    type family CostingPart uni fun;
}

-- | Get the <a>BuiltinMeaning</a> of a built-in function.
toBuiltinMeaning :: (ToBuiltinMeaning uni fun, HasConstantIn uni term) => fun -> BuiltinMeaning term (CostingPart uni fun)

-- | Get the type of a built-in function.
typeOfBuiltinFunction :: ToBuiltinMeaning uni fun => fun -> Type TyName uni ()

-- | Calculate runtime info for all built-in functions given denotations of
--   builtins and a cost model.
toBuiltinsRuntime :: (cost ~ CostingPart uni fun, HasConstantIn uni term, ToBuiltinMeaning uni fun) => cost -> BuiltinsRuntime fun term

-- | Look up the runtime info of a built-in function during evaluation.
lookupBuiltin :: (MonadError (ErrorWithCause err term) m, AsMachineError err fun, Ix fun) => fun -> BuiltinsRuntime fun val -> m (BuiltinRuntime val)
type family GetArgs a :: [Type]

-- | A class that allows us to derive a monotype for a builtin.
class KnownMonotype term args res a | args res -> a, a -> res
knownMonotype :: KnownMonotype term args res a => TypeScheme term args res

-- | Delete all <tt>x</tt>s from a list.
type family Delete x xs :: [a]

-- | Delete all elements appearing in the first list from the second one
--   and concatenate the lists.
type family Merge xs ys :: [a]

-- | Collect all unique variables (a variable consists of a textual name, a
--   unique and a kind) in an <tt>x</tt>.
type family ToBinds (x :: a) :: [Some TyNameRep]

-- | A class that allows us to derive a polytype for a builtin.
class KnownPolytype (binds :: [Some TyNameRep]) term args res a | args res -> a, a -> res
knownPolytype :: KnownPolytype binds term args res a => Proxy binds -> TypeScheme term args res

-- | Check if two values of different kinds are in fact the same value
--   (with the same kind). A heterogeneous version of
--   <tt>Type.Equality.(==)</tt>.
type family x === y
class same ~ (x === y) => TryUnify same x y

-- | Unify two values unless they're obviously distinct (in which case do
--   nothing). Allows us to detect and specialize type variables, since a
--   type variable is not obviously distinct from anything else and so the
--   INCOHERENT instance of <a>TryUnify</a> gets triggered and the variable
--   gets unified with whatever we want it to.
type x ~?~ y = TryUnify (x === y) x y

-- | Get the element at an <tt>i</tt>th position in a list.
type family Lookup n xs

-- | Get the name at the <tt>i</tt>th position in the list of default
--   names. We could use <tt>a_0</tt>, <tt>a_1</tt>, <tt>a_2</tt> etc
--   instead, but <tt>a</tt>, <tt>b</tt>, <tt>c</tt> etc are nicer.
type GetName i = Lookup i '["a", "b", "c", "d", "e", "f", "g", "h"]

-- | Try to specialize <tt>a</tt> as a type representing a Plutus type
--   variable. <tt>i</tt> is a fresh id and <tt>j</tt> is a final one
--   (either <tt>i + 1</tt> or <tt>i</tt> depending on whether
--   specialization attempt is successful or not).
class TrySpecializeAsVar i j term a | i term a -> j

-- | For looking into the type of a constant or the type arguments of a
--   polymorphic built-in type and specializing them as types representing
--   Plutus type variables. <tt>i</tt> is a fresh id and <tt>j</tt> is a
--   final one as in <a>TrySpecializeAsVar</a>, but since
--   <a>HandleSomeConstant</a> can specialize multiple variables,
--   <tt>j</tt> can be equal to <tt>i + n</tt> for any <tt>n</tt>
--   (including <tt>0</tt>).
class HandleSomeConstant i j term a | i term a -> j

-- | Specialize each Haskell type variable in <tt>a</tt> as a type
--   representing a Plutus Core type variable by deconstructing <tt>a</tt>
--   into an applied <tt>(-&gt;)</tt> (we don't recurse to the left of
--   <tt>(-&gt;)</tt>, only to the right) and trying to specialize every
--   argument type as a PLC type variable (via <a>TrySpecializeAsVar</a>)
--   until no deconstruction is possible, at which point we've got a result
--   which we don't try to specialize, because that would require an
--   incoherent instance and introducing one makes code that otherwise type
--   checks perfectly throw errors due to a bug in GHC, see
--   <a>https://github.com/input-output-hk/plutus/pull/2521#issuecomment-759522445</a>
--   In practice this means that if the result is a type variable, then
--   this type variable has to be mentioned as an argument type for
--   inference to work. I.e. <tt>absurd :: Void -&gt; a</tt> does not get
--   inferred, since <tt>a</tt> is only mentioned as the result type and
--   not as an argument type. But that's a fairly rear use case and we can
--   always provide a type signature manually.
class EnumerateFromTo i j term a | i term a -> j

-- | Construct the meaning for a built-in function by automatically
--   deriving its <a>TypeScheme</a>, given
--   
--   <ol>
--   <li>the denotation of the builtin</li>
--   <li>an uninstantiated costing function</li>
--   </ol>
makeBuiltinMeaning :: forall a term cost binds args res j. (args ~ GetArgs a, a ~ FoldArgs args res, binds ~ ToBinds (TypeScheme term args res), KnownPolytype binds term args res a, EnumerateFromTo 0 j term a) => a -> (cost -> FoldArgsEx args) -> BuiltinMeaning term cost

-- | Convert a <a>TypeScheme</a> to the corresponding <a>Type</a>.
--   Basically, a map from the PHOAS representation to the FOAS one.
typeSchemeToType :: TypeScheme term args res -> Type TyName (UniOf term) ()
countTermArgs :: TypeScheme uni args res -> Int

-- | This type is used when evaluating builtins to decide whether a term
--   argument or a type instantiation is required
data ArgumentClass
TypeArg :: ArgumentClass
TermArg :: ArgumentClass
type Arity = [ArgumentClass]

-- | Return a list containing the argument types of a TypeScheme
getArity :: TypeScheme uni args res -> Arity

module PlutusCore.Evaluation.Machine.MachineParameters

-- | We need to account for the costs of evaluator steps and also built-in
--   function evaluation. The models for these have different structures
--   and are used in different parts of the code, so inside the valuator we
--   pass separate objects about most of the time . It's convenient for
--   clients of the evaluator to only have to worry about a single object,
--   so the CostModel type bundles the two together. We could conceivably
--   have different evaluators with different internal costs, so we keep
--   the machine costs abstract. The model for Cek machine steps is in
--   UntypedPlutusCore.Evaluation.Machine.Cek.CekMachineCosts.
data CostModel machinecosts builtincosts
CostModel :: machinecosts -> builtincosts -> CostModel machinecosts builtincosts
[machineCostModel] :: CostModel machinecosts builtincosts -> machinecosts
[builtinCostModel] :: CostModel machinecosts builtincosts -> builtincosts

-- | At execution time we need a <a>BuiltinsRuntime</a> object which
--   includes both the cost model for builtins and their denotations. This
--   bundles one of those together with the cost model for evaluator steps.
--   The <tt>term</tt> type will be CekValue when we're using this with the
--   CEK machine.
data MachineParameters machinecosts term (uni :: Type -> Type) (fun :: Type)
MachineParameters :: machinecosts -> BuiltinsRuntime fun (term uni fun) -> MachineParameters machinecosts term (uni :: Type -> Type) (fun :: Type)
[machineCosts] :: MachineParameters machinecosts term (uni :: Type -> Type) (fun :: Type) -> machinecosts
[builtinsRuntime] :: MachineParameters machinecosts term (uni :: Type -> Type) (fun :: Type) -> BuiltinsRuntime fun (term uni fun)

-- | This just uses <a>toBuiltinsRuntime</a> function to convert a
--   BuiltinCostModel to a BuiltinsRuntime.
toMachineParameters :: (UniOf (val uni fun) ~ uni, CostingPart uni fun ~ builtincosts, HasConstant (val uni fun), ToBuiltinMeaning uni fun) => CostModel machinecosts builtincosts -> MachineParameters machinecosts val uni fun
instance (GHC.Show.Show machinecosts, GHC.Show.Show builtincosts) => GHC.Show.Show (PlutusCore.Evaluation.Machine.MachineParameters.CostModel machinecosts builtincosts)
instance (GHC.Classes.Eq machinecosts, GHC.Classes.Eq builtincosts) => GHC.Classes.Eq (PlutusCore.Evaluation.Machine.MachineParameters.CostModel machinecosts builtincosts)


-- | The CK machine.
module PlutusCore.Evaluation.Machine.Ck

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | The CK machine-specific <a>EvaluationException</a>.
type CkEvaluationException uni fun = CkEvaluationExceptionCarrying (Term TyName Name uni fun ()) fun
type CkM uni fun s = CkCarryingM (Term TyName Name uni fun ()) uni fun s
data CkValue uni fun

-- | Turn any <a>UserEvaluationError</a> into an <a>EvaluationFailure</a>.
extractEvaluationResult :: Either (EvaluationException user internal term) a -> Either (ErrorWithCause internal term) (EvaluationResult a)
runCk :: Ix fun => BuiltinsRuntime fun (CkValue uni fun) -> Bool -> Term TyName Name uni fun () -> (Either (CkEvaluationException uni fun) (Term TyName Name uni fun ()), [String])

-- | Evaluate a term using the CK machine with logging enabled.
evaluateCk :: Ix fun => BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> (Either (CkEvaluationException uni fun) (Term TyName Name uni fun ()), [String])

-- | Evaluate a term using the CK machine with logging disabled.
evaluateCkNoEmit :: Ix fun => BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> Either (CkEvaluationException uni fun) (Term TyName Name uni fun ())

-- | Evaluate a term using the CK machine with logging enabled. May throw a
--   <a>CkEvaluationException</a>.
unsafeEvaluateCk :: (GShow uni, Closed uni, Typeable uni, Typeable fun, uni `Everywhere` PrettyConst, Pretty fun, Ix fun) => BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> (EvaluationResult (Term TyName Name uni fun ()), [String])

-- | Evaluate a term using the CK machine with logging disabled. May throw
--   a <a>CkEvaluationException</a>.
unsafeEvaluateCkNoEmit :: (GShow uni, Closed uni, Typeable uni, Typeable fun, uni `Everywhere` PrettyConst, Pretty fun, Ix fun) => BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> EvaluationResult (Term TyName Name uni fun ())

-- | Unlift a value using the CK machine.
readKnownCk :: (Ix fun, KnownType (Term TyName Name uni fun ()) a) => BuiltinsRuntime fun (CkValue uni fun) -> Term TyName Name uni fun () -> Either (CkEvaluationException uni fun) a
instance (Universe.Core.Everywhere uni GHC.Show.Show, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, GHC.Show.Show fun) => GHC.Show.Show (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)
instance Control.DeepSeq.NFData PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Generics.Generic PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Classes.Eq PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Show.Show PlutusCore.Evaluation.Machine.Ck.CkUserError
instance PlutusCore.Constant.Dynamic.Emit.MonadEmitter (PlutusCore.Evaluation.Machine.Ck.CkCarryingM term uni fun s)
instance PlutusCore.Evaluation.Result.AsEvaluationFailure PlutusCore.Evaluation.Machine.Ck.CkUserError
instance Prettyprinter.Internal.Pretty PlutusCore.Evaluation.Machine.Ck.CkUserError
instance GHC.Show.Show (PlutusCore.Constant.Meaning.BuiltinRuntime (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun))
instance (Universe.Core.Closed uni, Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)
instance PlutusCore.Constant.Typed.FromConstant (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)
instance PlutusCore.Constant.Typed.AsConstant (PlutusCore.Evaluation.Machine.Ck.CkValue uni fun)


-- | Serialise instances for Plutus Core types. Make sure to read the Note
--   [Stable encoding of PLC] before touching anything in this file. Also
--   see the Notes [Serialising unit annotations] and [Serialising Scripts]
--   before using anything in this file.
module PlutusCore.CBOR
encode :: Serialise a => a -> Encoding
decode :: Serialise a => Decoder s a
encodeConstructorTag :: Word -> Encoding
decodeConstructorTag :: Decoder s Word

-- | Convenience functions for serialisation/deserialisation without units
serialiseOmittingUnits :: (Closed uni, Serialise name, Serialise tyname, uni `Everywhere` Serialise, Serialise fun) => Program name tyname uni fun () -> ByteString
deserialiseRestoringUnits :: (Closed uni, Serialise name, Serialise tyname, uni `Everywhere` Serialise, Serialise fun) => ByteString -> Program name tyname uni fun ()
deserialiseRestoringUnitsOrFail :: (Closed uni, Serialise name, Serialise tyname, uni `Everywhere` Serialise, Serialise fun) => ByteString -> Either DeserialiseFailure (Program name tyname uni fun ())
newtype InvisibleUnit
InvisibleUnit :: () -> InvisibleUnit
instance (Universe.Core.Everywhere uni Codec.Serialise.Class.Serialise, Universe.Core.Closed uni, Codec.Serialise.Class.Serialise name, Codec.Serialise.Class.Serialise tyname, Codec.Serialise.Class.Serialise fun) => Codec.Serialise.Class.Serialise (PlutusCore.CBOR.OmitUnitAnnotations name tyname uni fun)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (PlutusCore.Core.Type.Normalized a)
instance Codec.Serialise.Class.Serialise PlutusCore.DeBruijn.Internal.Index
instance Codec.Serialise.Class.Serialise PlutusCore.CBOR.InvisibleUnit
instance Universe.Core.Closed uni => Codec.Serialise.Class.Serialise (Universe.Core.SomeTypeIn uni)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Codec.Serialise.Class.Serialise) => Codec.Serialise.Class.Serialise (Data.Some.Newtype.Some (Universe.Core.ValueOf uni))
instance Codec.Serialise.Class.Serialise PlutusCore.Name.Unique
instance Codec.Serialise.Class.Serialise PlutusCore.Name.Name
instance Codec.Serialise.Class.Serialise PlutusCore.Name.TyName
instance Codec.Serialise.Class.Serialise ann => Codec.Serialise.Class.Serialise (PlutusCore.Core.Type.Version ann)
instance Codec.Serialise.Class.Serialise ann => Codec.Serialise.Class.Serialise (PlutusCore.Core.Type.Kind ann)
instance (Universe.Core.Closed uni, Codec.Serialise.Class.Serialise ann, Codec.Serialise.Class.Serialise tyname) => Codec.Serialise.Class.Serialise (PlutusCore.Core.Type.Type tyname uni ann)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Codec.Serialise.Class.Serialise, Codec.Serialise.Class.Serialise ann, Codec.Serialise.Class.Serialise tyname, Codec.Serialise.Class.Serialise name, Codec.Serialise.Class.Serialise fun) => Codec.Serialise.Class.Serialise (PlutusCore.Core.Type.Term tyname name uni fun ann)
instance (Universe.Core.Closed uni, Codec.Serialise.Class.Serialise ann, Codec.Serialise.Class.Serialise tyname, Codec.Serialise.Class.Serialise name) => Codec.Serialise.Class.Serialise (PlutusCore.MkPlc.VarDecl tyname name uni fun ann)
instance (Codec.Serialise.Class.Serialise ann, Codec.Serialise.Class.Serialise tyname) => Codec.Serialise.Class.Serialise (PlutusCore.MkPlc.TyVarDecl tyname ann)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Codec.Serialise.Class.Serialise, Codec.Serialise.Class.Serialise ann, Codec.Serialise.Class.Serialise tyname, Codec.Serialise.Class.Serialise name, Codec.Serialise.Class.Serialise fun) => Codec.Serialise.Class.Serialise (PlutusCore.Core.Type.Program tyname name uni fun ann)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (PlutusCore.Lexer.Type.Token a)
instance Codec.Serialise.Class.Serialise PlutusCore.Lexer.Type.Keyword
instance Codec.Serialise.Class.Serialise PlutusCore.Lexer.Type.Special
instance Codec.Serialise.Class.Serialise PlutusCore.DeBruijn.Internal.DeBruijn
instance Codec.Serialise.Class.Serialise PlutusCore.DeBruijn.Internal.TyDeBruijn


-- | Support for using de Bruijn indices for term names.
module UntypedPlutusCore.DeBruijn

-- | A relative index used for de Bruijn identifiers.
newtype Index
Index :: Natural -> Index

-- | A term name as a de Bruijn index, without the name string.
newtype DeBruijn
DeBruijn :: Index -> DeBruijn
[dbnIndex] :: DeBruijn -> Index

-- | A term name as a de Bruijn index.
data NamedDeBruijn
NamedDeBruijn :: Text -> Index -> NamedDeBruijn
[ndbnString] :: NamedDeBruijn -> Text
[ndbnIndex] :: NamedDeBruijn -> Index

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: Unique -> FreeVariableError
FreeIndex :: Index -> FreeVariableError
class AsFreeVariableError r_aVzL
_FreeVariableError :: AsFreeVariableError r_aVzL => Prism' r_aVzL FreeVariableError
_FreeUnique :: AsFreeVariableError r_aVzL => Prism' r_aVzL Unique
_FreeIndex :: AsFreeVariableError r_aVzL => Prism' r_aVzL Index

-- | Convert a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Term</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s.
deBruijnTerm :: (AsFreeVariableError e, MonadError e m) => Term Name uni fun ann -> m (Term NamedDeBruijn uni fun ann)

-- | Convert a <a>Program</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Program</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s.
deBruijnProgram :: (AsFreeVariableError e, MonadError e m) => Program Name uni fun ann -> m (Program NamedDeBruijn uni fun ann)

-- | Convert a <a>Term</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s
--   into a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s.
unDeBruijnTerm :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Term NamedDeBruijn uni fun ann -> m (Term Name uni fun ann)

-- | Convert a <a>Program</a> with <a>TyDeBruijn</a>s and <a>DeBruijn</a>s
--   into a <a>Program</a> with <a>TyName</a>s and <a>Name</a>s.
unDeBruijnProgram :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Program NamedDeBruijn uni fun ann -> m (Program Name uni fun ann)
unNameDeBruijn :: NamedDeBruijn -> DeBruijn

module UntypedPlutusCore.Evaluation.HOAS

-- | A higher-order version of <a>Term</a>. We parameterize it by a monad,
--   because there's no way we could generally convert a first-order
--   <a>Term</a> into a higher-order <a>HTerm</a> in a pure way: the
--   original term may contain free variables and we can't look under
--   lambdas to find that out before evaluation starts. Hence we need to
--   postpone converting variables when they appear under lambdas, which
--   either means throwing an <a>error</a> on a free variable or embedding
--   delayed monadic computations right into the AST. It's not an unseen
--   trick, here Kmett uses, for example:
--   <a>https://www.reddit.com/r/haskell/comments/j2q5p8/monthly_hask_anything_october_2020/g7zunsk/</a>
--   Except he hardcodes the monad to be <a>IO</a> and we keep it general,
--   which seems convenient.
data HTerm m name uni fun ann
data UserHoasError
HoasEvaluationFailure :: UserHoasError
data InternalHoasError fun
FreeVariableHoasError :: InternalHoasError fun
UnliftingHoasError :: UnliftingError -> InternalHoasError fun
ArityHoasError :: InternalHoasError fun
UnknownBuiltinHoasError :: fun -> InternalHoasError fun

-- | The type of errors that can occur during HOAS-based evaluation.
type HoasException fun = EvaluationException UserHoasError (InternalHoasError fun)

-- | A <a>Value</a> is an <a>HTerm</a> being evaluatated in the
--   <a>EvalM</a> monad and with built-in functions mapped to their
--   (possibly partially applied) meanings.
type Value unique name uni fun ann = HTerm (EvalM unique name uni fun ann) name uni (BuiltinApp unique name uni fun ann) ann

-- | A builtin application consists of a (possibly partially applied)
--   built-in function and a delayed computation returning the <a>Term</a>
--   representation of that builtin, which we need in case the built-in
--   function never gets fully saturated, which requires us to put the
--   (possibly partially applied) builtin into the resulting term.
data BuiltinApp unique name uni fun ann

-- | The monad the HOAS evaluator runs in.
data EvalM unique name uni fun ann a

-- | Evaluate a term using the HOAS evaluator.
evaluateHoas :: (term ~ Term name uni fun ann, value ~ Value unique name uni fun ann, HasUnique name unique, Ix fun) => BuiltinsRuntime fun value -> term -> Either (HoasException fun term) term

-- | Evaluate a term using the HOAS evaluator. May throw a
--   <a>HoasException</a>.
unsafeEvaluateHoas :: (term ~ Term name uni fun ann, value ~ Value unique name uni fun ann, HasUnique name unique, Ix fun, Typeable name, Typeable uni, Typeable fun, Typeable ann, Pretty fun, PrettyPlc term) => BuiltinsRuntime fun value -> term -> EvaluationResult term
instance UntypedPlutusCore.Evaluation.HOAS.AsInternalHoasError (UntypedPlutusCore.Evaluation.HOAS.InternalHoasError fun) fun
instance UntypedPlutusCore.Evaluation.HOAS.AsInternalHoasError internal fun => UntypedPlutusCore.Evaluation.HOAS.AsInternalHoasError (PlutusCore.Evaluation.Machine.Exception.EvaluationError user internal) fun
instance PlutusCore.Evaluation.Machine.Exception.AsUnliftingError (UntypedPlutusCore.Evaluation.HOAS.InternalHoasError fun)
instance UntypedPlutusCore.Evaluation.HOAS.AsUserHoasError UntypedPlutusCore.Evaluation.HOAS.UserHoasError
instance GHC.Classes.Eq UntypedPlutusCore.Evaluation.HOAS.UserHoasError
instance GHC.Show.Show UntypedPlutusCore.Evaluation.HOAS.UserHoasError
instance GHC.Base.Functor UntypedPlutusCore.Evaluation.HOAS.InternalHoasError
instance GHC.Classes.Eq fun => GHC.Classes.Eq (UntypedPlutusCore.Evaluation.HOAS.InternalHoasError fun)
instance GHC.Show.Show fun => GHC.Show.Show (UntypedPlutusCore.Evaluation.HOAS.InternalHoasError fun)
instance PlutusCore.Constant.Dynamic.Emit.MonadEmitter (UntypedPlutusCore.Evaluation.HOAS.EvalM unique name uni fun ann)
instance Control.Monad.Error.Class.MonadError (UntypedPlutusCore.Evaluation.HOAS.HoasException fun (UntypedPlutusCore.Evaluation.HOAS.Value unique name uni fun ann)) (UntypedPlutusCore.Evaluation.HOAS.EvalM unique name uni fun ann)
instance GHC.Base.Monad (UntypedPlutusCore.Evaluation.HOAS.EvalM unique name uni fun ann)
instance GHC.Base.Applicative (UntypedPlutusCore.Evaluation.HOAS.EvalM unique name uni fun ann)
instance GHC.Base.Functor (UntypedPlutusCore.Evaluation.HOAS.EvalM unique name uni fun ann)
instance Prettyprinter.Internal.Pretty fun => Text.PrettyBy.Internal.PrettyBy config (UntypedPlutusCore.Evaluation.HOAS.InternalHoasError fun)
instance Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc UntypedPlutusCore.Evaluation.HOAS.UserHoasError
instance PlutusCore.Evaluation.Result.AsEvaluationFailure UntypedPlutusCore.Evaluation.HOAS.UserHoasError
instance PlutusCore.Constant.Typed.AsConstant (UntypedPlutusCore.Evaluation.HOAS.HTerm m name uni fun ann)
instance PlutusCore.Constant.Typed.FromConstant (UntypedPlutusCore.Evaluation.HOAS.HTerm m name uni fun ())

module PlutusCore.Evaluation.Machine.CostModelInterface
type CostModelParams = Map Text Integer

-- | Given a CostModel, produce a single map containing the parameters from
--   both components
extractCostModelParams :: (ToJSON machinecosts, ToJSON builtincosts) => CostModel machinecosts builtincosts -> Maybe CostModelParams

-- | Update a CostModel for the CEK machine with a given set of parameters,
applyCostModelParams :: (FromJSON evaluatorcosts, FromJSON builtincosts, ToJSON evaluatorcosts, ToJSON builtincosts) => CostModel evaluatorcosts builtincosts -> CostModelParams -> Maybe (CostModel evaluatorcosts builtincosts)


-- | This is a parser for untyped Plutus Core. It's largely a copy of the
--   one for typed Plutus Core.
module UntypedPlutusCore.Parser

-- | Parse a PLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseProgram :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program Name DefaultUni DefaultFun AlexPosn)

-- | Parse a PLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Term Name DefaultUni DefaultFun AlexPosn)

-- | An error encountered during parsing.
data ParseError ann
LexErr :: String -> ParseError ann
Unexpected :: Token ann -> ParseError ann
UnknownBuiltinType :: ann -> Text -> ParseError ann
BuiltinTypeNotAStar :: ann -> Text -> ParseError ann
UnknownBuiltinFunction :: ann -> Text -> ParseError ann
InvalidBuiltinConstant :: ann -> Text -> Text -> ParseError ann


-- | The user-facing API of the untyped renamer. See PlutusCore.Rename for
--   details.
module UntypedPlutusCore.Rename

-- | The class of things that can be renamed. I.e. things that are capable
--   of satisfying the global uniqueness condition.
class Rename a

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched and bound
--   variables must not get renamed to free ones. Must always assign new
--   names to bound variables, so that <tt>rename</tt> can be used for
--   alpha-renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a
instance PlutusCore.Core.Type.HasUniques (UntypedPlutusCore.Core.Type.Term name uni fun ann) => PlutusCore.Rename.Rename (UntypedPlutusCore.Core.Type.Term name uni fun ann)
instance PlutusCore.Core.Type.HasUniques (UntypedPlutusCore.Core.Type.Program name uni fun ann) => PlutusCore.Rename.Rename (UntypedPlutusCore.Core.Type.Program name uni fun ann)


-- | The API to the CEK machine.
module UntypedPlutusCore.Evaluation.Machine.Cek

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a
data CekValue uni fun
VCon :: !Some (ValueOf uni) -> CekValue uni fun
VDelay :: Term Name uni fun () -> CekValEnv uni fun -> CekValue uni fun
VLamAbs :: Name -> Term Name uni fun () -> CekValEnv uni fun -> CekValue uni fun
VBuiltin :: !fun -> Term Name uni fun () -> CekValEnv uni fun -> !BuiltinRuntime (CekValue uni fun) -> CekValue uni fun
data CekUserError

-- | The final overspent (i.e. negative) budget.
CekOutOfExError :: ExRestrictingBudget -> CekUserError

-- | Error has been called or a builtin application has failed
CekEvaluationFailure :: CekUserError
type CekEvaluationException uni fun = CekEvaluationExceptionCarrying (Term Name uni fun ()) fun

-- | The CEK machine is parameterized over a <tt>spendBudget</tt> function
--   that has (roughly) the same type as the one from the
--   <tt>SpendBudget</tt> class (and so the <tt>SpendBudget</tt> instance
--   for <a>CekM</a> defers to the function stored in the environment).
--   This makes the budgeting machinery extensible and allows us to
--   separate budgeting logic from evaluation logic and avoid branching on
--   the union of all possible budgeting state types during evaluation.
newtype CekBudgetSpender uni fun s
CekBudgetSpender :: (ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()) -> CekBudgetSpender uni fun s
[unCekBudgetSpender] :: CekBudgetSpender uni fun s -> ExBudgetCategory fun -> ExBudget -> CekM uni fun s ()

-- | An error and (optionally) what caused it.
data ErrorWithCause err term
ErrorWithCause :: err -> Maybe term -> ErrorWithCause err term
[_ewcError] :: ErrorWithCause err term -> err
[_ewcCause] :: ErrorWithCause err term -> Maybe term

-- | The type of errors (all of them) which can occur during evaluation
--   (some are used-caused, some are internal).
data EvaluationError user internal

-- | Indicates bugs.
InternalEvaluationError :: internal -> EvaluationError user internal

-- | Indicates user errors.
UserEvaluationError :: user -> EvaluationError user internal
data ExBudgetCategory fun
BStep :: StepKind -> ExBudgetCategory fun
BBuiltinApp :: fun -> ExBudgetCategory fun
BStartup :: ExBudgetCategory fun
data StepKind
BConst :: StepKind
BVar :: StepKind
BLamAbs :: StepKind
BApply :: StepKind
BDelay :: StepKind
BForce :: StepKind
BBuiltin :: StepKind

-- | For a detailed report on what costs how much + the same overall budget
--   that <tt>Counting</tt> gives. The (derived) <a>Monoid</a> instance of
--   <a>CekExTally</a> is the main piece of the machinery.
newtype CekExTally fun
CekExTally :: MonoidalHashMap (ExBudgetCategory fun) ExBudget -> CekExTally fun

-- | A budgeting mode to execute the CEK machine in.
newtype ExBudgetMode cost uni fun
ExBudgetMode :: (forall s. ST s (ExBudgetInfo cost uni fun s)) -> ExBudgetMode cost uni fun
[unExBudgetMode] :: ExBudgetMode cost uni fun -> forall s. ST s (ExBudgetInfo cost uni fun s)

-- | For calculating the cost of execution by counting up using the
--   <a>Monoid</a> instance of <a>ExBudget</a>.
newtype CountingSt
CountingSt :: ExBudget -> CountingSt
data TallyingSt fun
TallyingSt :: CekExTally fun -> ExBudget -> TallyingSt fun
newtype RestrictingSt
RestrictingSt :: ExRestrictingBudget -> RestrictingSt

-- | Costs for evaluating AST nodes. Times should be specified in
--   picoseconds, memory sizes in bytes.
data CekMachineCosts
class Hashable a

-- | The set of constraints we need to be able to print things in
--   universes, which we need in order to throw exceptions.
type PrettyUni uni fun = (GShow uni, Closed uni, Pretty fun, Typeable uni, Typeable fun, Everywhere uni PrettyConst)

-- | For calculating the cost of execution.
counting :: ExBudgetMode CountingSt uni fun

-- | For a detailed report on what costs how much + the same overall budget
--   that <tt>Counting</tt> gives.
tallying :: (Eq fun, Hashable fun) => ExBudgetMode (TallyingSt fun) uni fun

-- | For execution, to avoid overruns.
restricting :: forall uni fun. PrettyUni uni fun => ExRestrictingBudget -> ExBudgetMode RestrictingSt uni fun

-- | <a>restricting</a> instantiated at <a>enormousBudget</a>.
restrictingEnormous :: PrettyUni uni fun => ExBudgetMode RestrictingSt uni fun

-- | Turn any <a>UserEvaluationError</a> into an <a>EvaluationFailure</a>.
extractEvaluationResult :: Either (EvaluationException user internal term) a -> Either (ErrorWithCause internal term) (EvaluationResult a)

-- | Evaluate a term using the CEK machine and keep track of costing,
--   logging is optional.
runCek :: (uni `Everywhere` ExMemoryUsage, Ix fun, PrettyUni uni fun) => MachineParameters CekMachineCosts CekValue uni fun -> ExBudgetMode cost uni fun -> Bool -> Term Name uni fun () -> (Either (CekEvaluationException uni fun) (Term Name uni fun ()), cost, [String])

-- | Evaluate a term using the CEK machine with logging disabled and keep
--   track of costing.
runCekNoEmit :: (uni `Everywhere` ExMemoryUsage, Ix fun, PrettyUni uni fun) => MachineParameters CekMachineCosts CekValue uni fun -> ExBudgetMode cost uni fun -> Term Name uni fun () -> (Either (CekEvaluationException uni fun) (Term Name uni fun ()), cost)

-- | Unsafely evaluate a term using the CEK machine with logging disabled
--   and keep track of costing. May throw a <tt>CekMachineException</tt>.
unsafeRunCekNoEmit :: (GShow uni, Typeable uni, Closed uni, uni `EverywhereAll` '[ExMemoryUsage, PrettyConst], Ix fun, Pretty fun, Typeable fun) => MachineParameters CekMachineCosts CekValue uni fun -> ExBudgetMode cost uni fun -> Term Name uni fun () -> (EvaluationResult (Term Name uni fun ()), cost)

-- | Evaluate a term using the CEK machine with logging enabled.
evaluateCek :: (uni `Everywhere` ExMemoryUsage, Ix fun, PrettyUni uni fun) => MachineParameters CekMachineCosts CekValue uni fun -> Term Name uni fun () -> (Either (CekEvaluationException uni fun) (Term Name uni fun ()), [String])

-- | Evaluate a term using the CEK machine with logging disabled.
evaluateCekNoEmit :: (uni `Everywhere` ExMemoryUsage, Ix fun, PrettyUni uni fun) => MachineParameters CekMachineCosts CekValue uni fun -> Term Name uni fun () -> Either (CekEvaluationException uni fun) (Term Name uni fun ())

-- | Evaluate a term using the CEK machine with logging enabled. May throw
--   a <tt>CekMachineException</tt>.
unsafeEvaluateCek :: (GShow uni, Typeable uni, Closed uni, uni `EverywhereAll` '[ExMemoryUsage, PrettyConst], Ix fun, Pretty fun, Typeable fun) => MachineParameters CekMachineCosts CekValue uni fun -> Term Name uni fun () -> (EvaluationResult (Term Name uni fun ()), [String])

-- | Evaluate a term using the CEK machine with logging disabled. May throw
--   a <tt>CekMachineException</tt>.
unsafeEvaluateCekNoEmit :: (GShow uni, Typeable uni, Closed uni, uni `EverywhereAll` '[ExMemoryUsage, PrettyConst], Ix fun, Pretty fun, Typeable fun) => MachineParameters CekMachineCosts CekValue uni fun -> Term Name uni fun () -> EvaluationResult (Term Name uni fun ())

-- | Unlift a value using the CEK machine.
readKnownCek :: (uni `Everywhere` ExMemoryUsage, KnownType (Term Name uni fun ()) a, Ix fun, PrettyUni uni fun) => MachineParameters CekMachineCosts CekValue uni fun -> Term Name uni fun () -> Either (CekEvaluationException uni fun) a

-- | When we want to just evaluate the program we use the
--   <tt>Restricting</tt> mode with an enormous budget, so that evaluation
--   costs of on-chain budgeting are reflected accurately in benchmarks.
enormousBudget :: ExRestrictingBudget


-- | Reexports from modules from the
--   <tt>PlutusCore.Generators.Internal</tt> folder.
module PlutusCore.Generators

-- | <pre>
--   hoist lift
--   </pre>
liftT :: (MFunctor t, MonadTrans s, Monad m) => t m a -> t (s m) a

-- | <pre>
--   hoist generalize
--   </pre>
generalizeT :: (MFunctor t, Monad m) => t Identity a -> t m a

-- | Supply an environment to an inner <a>ReaderT</a>.
hoistSupply :: (MFunctor t, Monad m) => r -> t (ReaderT r m) a -> t m a

-- | Same as <a>choice</a>, but with a default generator to be used when
--   the supplied list of generators is empty.
choiceDef :: Monad m => GenT m a -> [GenT m a] -> GenT m a

-- | Generate a value, but do not show it in case an error occurs.
forAllNoShow :: Monad m => Gen a -> PropertyT m a

-- | Generate a value, but do not show it in case an error occurs. A
--   supplied generator has access to the <a>Monad</a> the whole property
--   has access to.
forAllNoShowT :: Monad m => GenT m a -> PropertyT m a

-- | Generate a value using the <a>Pretty</a> class for getting its
--   <a>String</a> representation.
forAllPretty :: (Monad m, Pretty a) => Gen a -> PropertyT m a

-- | Generate a value using the <a>Pretty</a> class for getting its
--   <a>String</a> representation. A supplied generator has access to the
--   <a>Monad</a> the whole property has access to.
forAllPrettyT :: (Monad m, Pretty a) => GenT m a -> PropertyT m a

-- | Generate a value using the <a>PrettyPlc</a> constraint for getting its
--   <a>String</a> representation.
forAllPrettyPlc :: (Monad m, PrettyPlc a) => Gen a -> PropertyT m a

-- | Generate a value using the <a>PrettyPlc</a> constraint for getting its
--   <a>String</a> representation. A supplied generator has access to the
--   <a>Monad</a> the whole property has access to.
forAllPrettyPlcT :: (Monad m, PrettyPlc a) => GenT m a -> PropertyT m a

-- | Pretty-print a PLC error.
prettyPlcErrorString :: PrettyPlc err => err -> String

-- | A <tt>term</tt> along with the correspoding Haskell value.
data TermOf term a
TermOf :: term -> a -> TermOf term a

-- | The term
[_termOfTerm] :: TermOf term a -> term

-- | The Haskell value.
[_termOfValue] :: TermOf term a -> a

-- | A function of this type generates values of built-in typed (see
--   <tt>TypedBuiltin</tt> for the list of such types) and returns it along
--   with the corresponding PLC value.
type TypedBuiltinGenT term m = forall a. AsKnownType term a -> GenT m (TermOf term a)

-- | <a>TypedBuiltinGenT</a> specified to <a>Identity</a>.
type TypedBuiltinGen term = TypedBuiltinGenT term Identity

-- | Generate a UTF-8 lazy <tt>ByteString</tt> containg lower-case letters.
genLowerBytes :: Monad m => Range Int -> GenT m ByteString

-- | A built-ins generator that always fails.
genTypedBuiltinFail :: (GShow (UniOf term), Monad m) => TypedBuiltinGenT term m

-- | A default built-ins generator.
genTypedBuiltinDef :: (HasConstantIn DefaultUni term, Monad m) => TypedBuiltinGenT term m

-- | The type of errors that can occur during type-eval checking.
data TypeEvalCheckError uni fun
TypeEvalCheckErrorIllFormed :: Error uni fun () -> TypeEvalCheckError uni fun
TypeEvalCheckErrorIllTyped :: Normalized (Type TyName uni ()) -> Normalized (Type TyName uni ()) -> TypeEvalCheckError uni fun
TypeEvalCheckErrorException :: String -> TypeEvalCheckError uni fun

-- | The former is an expected result of evaluation, the latter -- is an
--   actual one.
TypeEvalCheckErrorIllEvaled :: EvaluationResult (Term TyName Name uni fun ()) -> EvaluationResult (Term TyName Name uni fun ()) -> TypeEvalCheckError uni fun

-- | Type-eval checking of a term results in a value of this type.
data TypeEvalCheckResult uni fun
TypeEvalCheckResult :: Normalized (Type TyName uni ()) -> EvaluationResult (Term TyName Name uni fun ()) -> TypeEvalCheckResult uni fun

-- | The type of the term.
[_termCheckResultType] :: TypeEvalCheckResult uni fun -> Normalized (Type TyName uni ())

-- | The result of evaluation of the term.
[_termCheckResultValue] :: TypeEvalCheckResult uni fun -> EvaluationResult (Term TyName Name uni fun ())

-- | The monad type-eval checking runs in.
type TypeEvalCheckM uni fun = Either (TypeEvalCheckError uni fun)

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one.
typeEvalCheckBy :: (uni ~ DefaultUni, fun ~ DefaultFun, KnownType (Term TyName Name uni fun ()) a, PrettyPlc internal) => (Term TyName Name uni fun () -> Either (EvaluationException user internal (Term TyName Name uni fun ())) (Term TyName Name uni fun ())) -> TermOf (Term TyName Name uni fun ()) a -> TypeEvalCheckM uni fun (TermOf (Term TyName Name uni fun ()) (TypeEvalCheckResult uni fun))

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one. Throw an error in case something goes wrong.
unsafeTypeEvalCheck :: (uni ~ DefaultUni, fun ~ DefaultFun, KnownType (Term TyName Name uni fun ()) a) => TermOf (Term TyName Name uni fun ()) a -> TermOf (Term TyName Name uni fun ()) (EvaluationResult (Term TyName Name uni fun ()))

-- | The type used in generators defined in this module. It's parameterized
--   by a <a>BuiltinGensT</a> which makes it possible to supply different
--   generators of built-in types. For example, <tt>genTypedBuiltinDiv</tt>
--   never generates a zero, so this generator can be used in order to
--   avoid the divide-by-zero-induced <tt>error</tt>. Supplied generators
--   are of arbitrary complexity and can call the currently running
--   generator recursively, for example.
type PlcGenT uni fun m = GenT (ReaderT (BuiltinGensT uni fun m) m)

-- | A function (called "head") applied to a list of arguments (called
--   "spine").
data IterApp head arg
IterApp :: head -> [arg] -> IterApp head arg
[_iterAppHead] :: IterApp head arg -> head
[_iterAppSpine] :: IterApp head arg -> [arg]

-- | One iterated application of a <tt>head</tt> to <tt>arg</tt>s
--   represented in three distinct ways.
data IterAppValue uni fun head arg r
IterAppValue :: Plain Term uni fun -> IterApp head arg -> r -> IterAppValue uni fun head arg r

-- | As a PLC <a>Term</a>.
[_iterTerm] :: IterAppValue uni fun head arg r -> Plain Term uni fun

-- | As an <a>IterApp</a>.
[_iterApp] :: IterAppValue uni fun head arg r -> IterApp head arg

-- | As a Haskell value.
[_iterTbv] :: IterAppValue uni fun head arg r -> r

-- | Run a <a>PlcGenT</a> computation by supplying built-ins generators.
runPlcT :: Monad m => TypedBuiltinGenT (Plain Term uni fun) m -> PlcGenT uni fun m a -> GenT m a

-- | Generate a <a>Builtin</a> and supply its typed version to a
--   continuation.
withTypedBuiltinGen :: (uni ~ DefaultUni, HasConstantIn uni term, Monad m) => (forall a. AsKnownType term a -> GenT m c) -> GenT m c

-- | Generate a <a>Term</a> along with the value it computes to, having a
--   generator of terms of built-in types.
withCheckedTermGen :: (uni ~ DefaultUni, fun ~ DefaultFun, Monad m) => TypedBuiltinGenT (Plain Term uni fun) m -> (forall a. AsKnownType (Plain Term uni fun) a -> TermOf (Plain Term uni fun) (EvaluationResult (Plain Term uni fun)) -> GenT m c) -> GenT m c

-- | Generate an <a>IterAppValue</a> from a <a>Denotation</a>. If the
--   <a>Denotation</a> has a functional type, then all arguments are
--   generated and supplied to the denotation. Since <a>IterAppValue</a>
--   consists of three components, we 1. grow the <a>Term</a> component by
--   applying it to arguments using <a>Apply</a> 2. grow the <a>IterApp</a>
--   component by appending arguments to its spine 3. feed arguments to the
--   Haskell function
genIterAppValue :: forall head uni fun res m. Monad m => Denotation (Plain Term uni fun) head res -> PlcGenT uni fun m (IterAppValue uni fun head (Plain Term uni fun) res)

-- | Generate a PLC <a>Term</a> of the specified type and the corresponding
--   Haskell value. Generates first-order functions and constants including
--   constant applications. Arguments to functions and <a>Builtin</a>s are
--   generated recursively.
genTerm :: forall uni fun m. (uni ~ DefaultUni, Monad m) => TypedBuiltinGenT (Plain Term uni fun) m -> DenotationContext (Plain Term uni fun) -> Int -> TypedBuiltinGenT (Plain Term uni fun) m

-- | Generates a <a>Term</a> with rather small values to make out-of-bounds
--   failures less likely. There are still like a half of terms that fail
--   with out-of-bounds errors being evaluated.
genTermLoose :: Monad m => TypedBuiltinGenT (Plain Term DefaultUni DefaultFun) m

-- | Generate a <tt>TypedBuiltin</tt> and a <a>TermOf</a> of the
--   corresponding type, attach the <tt>TypedBuiltin</tt> to the value part
--   of the <a>TermOf</a> and pass that to a continuation.
withAnyTermLoose :: (uni ~ DefaultUni, fun ~ DefaultFun, Monad m) => (forall a. KnownType (Plain Term uni fun) a => TermOf (Plain Term uni fun) a -> GenT m c) -> GenT m c

-- | Contains a proof that <tt>a</tt> is a <a>KnownType</a>.
data AsKnownType term a
[AsKnownType] :: KnownType term a => AsKnownType term a

-- | Turn any <tt>proxy a</tt> into an <tt>AsKnownType a</tt> provided
--   <tt>a</tt> is a <a>KnownType</a>.
proxyAsKnownType :: KnownType term a => proxy a -> AsKnownType term a

-- | Haskell denotation of a PLC object. An object can be a <a>Builtin</a>
--   or a variable for example.
data Denotation term object res
Denotation :: object -> (object -> term) -> FoldArgs args res -> TypeScheme term args res -> Denotation term object res

-- | A PLC object.
[_denotationObject] :: Denotation term object res -> object

-- | How to embed the object into a term.
[_denotationToTerm] :: Denotation term object res -> object -> term

-- | The denotation of the object. E.g. the denotation of <a>AddInteger</a>
--   is <a>(+)</a>.
[_denotationItself] :: Denotation term object res -> FoldArgs args res

-- | The <a>TypeScheme</a> of the object. See <tt>intIntInt</tt> for
--   example.
[_denotationScheme] :: Denotation term object res -> TypeScheme term args res

-- | A member of a <a>DenotationContext</a>. <tt>object</tt> is
--   existentially quantified, so the only thing that can be done with it,
--   is turning it into a <a>Term</a> using <a>_denotationToTerm</a>.
data DenotationContextMember term res
DenotationContextMember :: Denotation term object res -> DenotationContextMember term res

-- | A context of <a>DenotationContextMember</a>s. Each row is a mapping
--   from a type to a list of things that can return that type. For example
--   it can contain a mapping from <tt>integer</tt> to 1. a bound variable
--   of type <tt>integer</tt> 2. a bound variable of functional type with
--   the result being <tt>integer</tt> 3. the <a>AddInteger</a>
--   <a>Builtin</a> or any other <a>Builtin</a> which returns an
--   <tt>integer</tt>.
newtype DenotationContext term
DenotationContext :: DMap (AsKnownType term) (Compose [] (DenotationContextMember term)) -> DenotationContext term
[unDenotationContext] :: DenotationContext term -> DMap (AsKnownType term) (Compose [] (DenotationContextMember term))

-- | Get the <a>Denotation</a> of a variable.
denoteVariable :: KnownType (Term TyName Name uni fun ()) res => Name -> res -> Denotation (Term TyName Name uni fun ()) Name res

-- | Insert a variable into a <a>DenotationContext</a>.
insertVariable :: (GShow uni, KnownType (Term TyName Name uni fun ()) a) => Name -> a -> DenotationContext (Term TyName Name uni fun ()) -> DenotationContext (Term TyName Name uni fun ())

-- | Insert a builtin into a <a>DenotationContext</a>.
insertBuiltin :: DefaultFun -> DenotationContext (Term TyName Name DefaultUni DefaultFun ()) -> DenotationContext (Term TyName Name DefaultUni DefaultFun ())

-- | A <a>DenotationContext</a> that consists of <a>DefaultFun</a>s.
typedBuiltins :: DenotationContext (Term TyName Name DefaultUni DefaultFun ())


-- | Sample generators used for tests.
module PlutusCore.Generators.Interesting

-- | The type of terms-and-their-values generators.
type TermGen a = Gen (TermOf (Term TyName Name DefaultUni DefaultFun ()) a)

-- | A <tt>term</tt> along with the correspoding Haskell value.
data TermOf term a
TermOf :: term -> a -> TermOf term a

-- | The term
[_termOfTerm] :: TermOf term a -> term

-- | The Haskell value.
[_termOfValue] :: TermOf term a -> a

-- | Generates application of a builtin that returns a function,
--   immediately saturated afterwards.
--   
--   <pre>
--   ifThenElse {integer -&gt; integer -&gt; integer} (lessThanInteger i j) addInteger subtractInteger i j
--       == if i &lt; j then i + j else i - j
--   </pre>
genOverapplication :: TermGen Integer

-- | <tt>i -&gt; product [1 :: Integer .. i]</tt> as a PLC term.
--   
--   <pre>
--   \(i : integer) -&gt; product (enumFromTo 1 i)
--   </pre>
factorial :: Term TyName Name DefaultUni DefaultFun ()

-- | Generate a term that computes the factorial of an <tt>integer</tt> and
--   return it along with the factorial of the corresponding <a>Integer</a>
--   computed on the Haskell side.
genFactorial :: TermGen Integer

-- | The naive exponential fibonacci function as a PLC term.
--   
--   <pre>
--   \(i0 : integer) -&gt;
--       fix {integer} {integer}
--           (\(rec : integer -&gt; integer) (i : integer) -&gt;
--                   ifThenElse {integer}
--                       (lessThanEqInteger i 1)
--                       (\(u : unit) -&gt; i)
--                       (\(u : unit) -&gt; addInteger
--                           (rec (subtractInteger i 1))
--                           (rec (subtractInteger i 2)))
--           i0
--   </pre>
naiveFib :: Integer -> Term TyName Name DefaultUni DefaultFun ()

-- | Generate a term that computes the ith Fibonacci number and return it
--   along with the corresponding <a>Integer</a> computed on the Haskell
--   side.
genNaiveFib :: TermGen Integer

-- | Generate an <a>Integer</a>, turn it into a Scott-encoded PLC
--   <tt>Nat</tt> (see <tt>Nat</tt>), turn that <tt>Nat</tt> into the
--   corresponding PLC <tt>integer</tt> using a fold (see <tt>FoldNat</tt>)
--   defined in terms of generic fix (see <tt>Fix</tt>) and return the
--   result along with the original <a>Integer</a>
genNatRoundtrip :: TermGen Integer

-- | <tt>sumNat</tt> as a PLC term.
natSum :: Term TyName Name DefaultUni DefaultFun ()

-- | Generate a list of <a>Integer</a>s, turn it into a Scott-encoded PLC
--   <tt>List</tt> (see <tt>List</tt>), sum elements of the list (see
--   <tt>Sum</tt>) and return it along with the sum of the original list.
genListSum :: TermGen Integer

-- | Generate a <tt>boolean</tt> and two <tt>integer</tt>s and check
--   whether <tt>if b then i1 else i2</tt> means the same thing in Haskell
--   and PLC. Terms are generated using <a>genTermLoose</a>.
genIfIntegers :: TermGen Integer

-- | Apply a function to all interesting generators and collect the
--   results.
fromInterestingTermGens :: (forall a. KnownType (Term TyName Name DefaultUni DefaultFun ()) a => String -> TermGen a -> c) -> [c]


-- | This module defines functions useful for testing.
module PlutusCore.Generators.Test

-- | The type of errors that can occur during type-eval checking.
data TypeEvalCheckError uni fun
TypeEvalCheckErrorIllFormed :: Error uni fun () -> TypeEvalCheckError uni fun
TypeEvalCheckErrorIllTyped :: Normalized (Type TyName uni ()) -> Normalized (Type TyName uni ()) -> TypeEvalCheckError uni fun
TypeEvalCheckErrorException :: String -> TypeEvalCheckError uni fun

-- | The former is an expected result of evaluation, the latter -- is an
--   actual one.
TypeEvalCheckErrorIllEvaled :: EvaluationResult (Term TyName Name uni fun ()) -> EvaluationResult (Term TyName Name uni fun ()) -> TypeEvalCheckError uni fun

-- | Type-eval checking of a term results in a value of this type.
data TypeEvalCheckResult uni fun
TypeEvalCheckResult :: Normalized (Type TyName uni ()) -> EvaluationResult (Term TyName Name uni fun ()) -> TypeEvalCheckResult uni fun

-- | The type of the term.
[_termCheckResultType] :: TypeEvalCheckResult uni fun -> Normalized (Type TyName uni ())

-- | The result of evaluation of the term.
[_termCheckResultValue] :: TypeEvalCheckResult uni fun -> EvaluationResult (Term TyName Name uni fun ())

-- | The monad type-eval checking runs in.
type TypeEvalCheckM uni fun = Either (TypeEvalCheckError uni fun)

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one.
typeEvalCheckBy :: (uni ~ DefaultUni, fun ~ DefaultFun, KnownType (Term TyName Name uni fun ()) a, PrettyPlc internal) => (Term TyName Name uni fun () -> Either (EvaluationException user internal (Term TyName Name uni fun ())) (Term TyName Name uni fun ())) -> TermOf (Term TyName Name uni fun ()) a -> TypeEvalCheckM uni fun (TermOf (Term TyName Name uni fun ()) (TypeEvalCheckResult uni fun))

-- | Type check and evaluate a term and check that the expected result is
--   equal to the actual one. Throw an error in case something goes wrong.
unsafeTypeEvalCheck :: (uni ~ DefaultUni, fun ~ DefaultFun, KnownType (Term TyName Name uni fun ()) a) => TermOf (Term TyName Name uni fun ()) a -> TermOf (Term TyName Name uni fun ()) (EvaluationResult (Term TyName Name uni fun ()))

-- | Generate a term using a given generator and check that it's well-typed
--   and evaluates correctly.
getSampleTermValue :: (uni ~ DefaultUni, fun ~ DefaultFun, KnownType (Term TyName Name uni fun ()) a) => TermGen a -> IO (TermOf (Term TyName Name uni fun ()) (EvaluationResult (Term TyName Name uni fun ())))

-- | Generate a program using a given generator and check that it's
--   well-typed and evaluates correctly.
getSampleProgramAndValue :: (uni ~ DefaultUni, fun ~ DefaultFun, KnownType (Term TyName Name uni fun ()) a) => TermGen a -> IO (Program TyName Name uni fun (), EvaluationResult (Term TyName Name uni fun ()))

-- | Generate a program using a given generator, check that it's well-typed
--   and evaluates correctly and pretty-print it to stdout using the
--   default pretty-printing mode.
printSampleProgramAndValue :: KnownType (Term TyName Name DefaultUni DefaultFun ()) a => TermGen a -> IO ()

-- | Generate a pair of files: <tt><a>folder</a>.<a>name</a>.plc</tt> and
--   <tt><a>folder</a>.<a>name</a>.plc.golden</tt>. The first file contains
--   a term generated by a term generator (wrapped in <a>Program</a>), the
--   second file contains the result of evaluation of the term.
sampleProgramValueGolden :: KnownType (Term TyName Name DefaultUni DefaultFun ()) a => String -> String -> TermGen a -> IO ()

-- | A property-based testing procedure for evaluators. Checks whether a
--   term generated along with the value it's supposed to compute to indeed
--   computes to that value according to the provided evaluate.
propEvaluate :: (uni ~ DefaultUni, fun ~ DefaultFun, KnownType (Term TyName Name uni fun ()) a, PrettyPlc internal) => (Term TyName Name uni fun () -> Either (EvaluationException user internal (Term TyName Name uni fun ())) (Term TyName Name uni fun ())) -> TermGen a -> Property

module PlutusCore

-- | Parse a PLC program. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseProgram :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program TyName Name DefaultUni DefaultFun AlexPosn)

-- | Parse a PLC term. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseTerm :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Term TyName Name DefaultUni DefaultFun AlexPosn)

-- | Parse a PLC type. The resulting program will have fresh names. The
--   underlying monad must be capable of handling any parse errors.
parseType :: (AsParseError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Type TyName DefaultUni AlexPosn)

-- | Parse and rewrite so that names are globally unique, not just unique
--   within their scope.
parseScoped :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program TyName Name DefaultUni DefaultFun AlexPosn)
topAlexPosn :: AlexPosn
data Some (tag :: k -> Type)
pattern Some :: forall k tag (a :: k). () => tag a -> Some tag

-- | A particular type from a universe.
data SomeTypeIn uni
SomeTypeIn :: !uni (Esc a) -> SomeTypeIn uni
data Kinded uni ta
[Kinded] :: Typeable k => !uni (Esc a) -> Kinded uni (Esc (a :: k))

-- | A value of a particular type from a universe.
data ValueOf uni a
ValueOf :: !uni (Esc a) -> !a -> ValueOf uni a

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, given its explicit type
--   tag.
someValueOf :: forall a uni. uni (Esc a) -> a -> Some (ValueOf uni)

-- | Wrap a value into <tt>Some (ValueOf uni)</tt>, provided its type is in
--   the universe.
someValue :: forall a uni. uni `Includes` a => a -> Some (ValueOf uni)

-- | "Escapes" a type of an arbitrary kind to fit into <a>Type</a>.
data Esc a

-- | A class for enumerating types and fully instantiated type formers that
--   <tt>uni</tt> contains. For example, a particular <tt>ExampleUni</tt>
--   may have monomorphic types in it:
--   
--   instance ExampleUni <a>Contains</a> Integer where <a>...</a> instance
--   ExampleUni <a>Contains</a> Bool where <a>...</a>
--   
--   as well as polymorphic ones:
--   
--   instance ExampleUni <a>Contains</a> [] where <a>...</a> instance
--   ExampleUni <a>Contains</a> (,) where <a>...</a>
--   
--   as well as their instantiations:
--   
--   instance ExampleUni <a>Contains</a> a =&gt; ExampleUni <a>Contains</a>
--   [a] where <a>...</a> instance (ExampleUni <a>Contains</a> a,
--   ExampleUni <a>Contains</a> b) =&gt; ExampleUni <a>Contains</a> (a, b)
--   where <a>...</a>
--   
--   (a universe can have any subset of the mentioned sorts of types, for
--   example it's fine to have instantiated polymorphic types and not have
--   uninstantiated ones and vice versa)
--   
--   Note that when used as a constraint of a function <a>Contains</a> does
--   not allow you to directly express things like "<tt>uni</tt> has the
--   <tt>Integer</tt>, <tt>Bool</tt> and <tt>[]</tt> types and type
--   formers", because <tt>[]</tt> is not fully instantiated. So you can
--   only say "<tt>uni</tt> has <tt>Integer</tt>, <tt>Bool</tt>,
--   <tt>[Integer]</tt>, <tt>[Bool]</tt>, <tt>[[Integer]]</tt>,
--   <tt>[[Bool]]</tt> etc" and such manual enumeration is annoying, so
--   we'd really like to be able to say that <tt>uni</tt> has lists of
--   arbitrary built-in types (including lists of lists etc).
--   <a>Contains</a> does not allow that, but <a>Includes</a> does. For
--   example, in the body of the following definition:
--   
--   foo :: (uni <a>Includes</a> Integer, uni <a>Includes</a> Bool, uni
--   <a>Includes</a> []) =&gt; <a>...</a> foo = <a>...</a>
--   
--   you can make use of the fact that <tt>uni</tt> has lists of arbitrary
--   included types (integers, booleans and lists).
--   
--   Hence most of the time opt for using the more flexible
--   <a>Includes</a>.
--   
--   <a>Includes</a> is defined in terms of <a>Contains</a>, so you only
--   need to provide a <a>Contains</a> instance per type from the universe
--   and you'll get <a>Includes</a> for free.
class uni `Contains` a
knownUni :: Contains uni a => uni (Esc a)

-- | <tt>uni <a>Includes</a> a</tt> reads as "<tt>a</tt> is in the
--   <tt>uni</tt>". <tt>a</tt> can be of a higher-kind, see the docs of
--   <a>Contains</a> on why you might want that.
type Includes uni = Permits (Contains uni)

-- | A universe is <a>Closed</a>, if it's known how to constrain every type
--   from the universe and every type can be encoded to / decoded from a
--   sequence of integer tags. The universe doesn't have to be finite and
--   providing support for infinite universes is the reason why we encode a
--   type as a sequence of integer tags as opposed to a single integer tag.
--   For example, given
--   
--   <pre>
--   data U a where
--       UList :: !(U a) -&gt; U [a]
--       UInt  :: U Int
--   </pre>
--   
--   <tt>UList (UList UInt)</tt> can be encoded to <tt>[0,0,1]</tt> where
--   <tt>0</tt> and <tt>1</tt> are the integer tags of the <tt>UList</tt>
--   and <tt>UInt</tt> constructors, respectively.
class Closed uni where {
    
    -- | A constrant for "<tt>constr a</tt> holds for any <tt>a</tt> from
    --   <tt>uni</tt>".
    type family Everywhere uni (constr :: Type -> Constraint) :: Constraint;
}

-- | Encode a type as a sequence of <a>Int</a> tags. The opposite of
--   <tt>decodeUni</tt>.
encodeUni :: Closed uni => uni a -> [Int]

-- | Decode a type and feed it to the continuation.
withDecodedUni :: Closed uni => (forall k (a :: k). Typeable k => uni (Esc a) -> DecodeUniM r) -> DecodeUniM r

-- | Bring a <tt>constr a</tt> instance in scope, provided <tt>a</tt> is a
--   type from the universe and <tt>constr</tt> holds for any type from the
--   universe.
bring :: (Closed uni, uni `Everywhere` constr) => proxy constr -> uni (Esc a) -> (constr a => r) -> r
type family uni `EverywhereAll` constrs

-- | Same as <a>knownUni</a>, but receives a <tt>proxy</tt>.
knownUniOf :: uni `Contains` a => proxy a -> uni (Esc a)
class GShow (t :: k -> Type)
gshowsPrec :: forall (a :: k). GShow t => Int -> t a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String
class GEq (f :: k -> Type)
geq :: forall (a :: k) (b :: k). GEq f => f a -> f b -> Maybe (a :~: b)
deriveGEq :: DeriveGEQ t => t -> Q [Dec]

-- | A class for "<tt>uni</tt> has general type application".
class HasUniApply (uni :: Type -> Type)

-- | Deconstruct a type application into the function and the argument and
--   feed them to the continuation. If the type is not an application, then
--   return the default value.
matchUniApply :: HasUniApply uni => uni tb -> r -> (forall k l (f :: k -> l) a. tb ~ Esc (f a) => uni (Esc f) -> uni (Esc a) -> r) -> r

-- | Check if the kind of the given type from the universe is <a>Type</a>.
checkStar :: forall uni a (x :: a). Typeable a => uni (Esc x) -> Maybe (a :~: Type)

-- | Check if one type from the universe can be applied to another (i.e.
--   check that the expected kind of the argument matches the actual one)
--   and call the continuation in the refined context. Fail with
--   <a>mzero</a> otherwise.
withApplicable :: forall (a :: Type) (ab :: Type) f x uni m r. (Typeable ab, Typeable a, MonadPlus m) => uni (Esc (f :: ab)) -> uni (Esc (x :: a)) -> (forall (b :: Type). (Typeable b, ab ~ (a -> b)) => m r) -> m r

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
data (a :: k) :~: (b :: k)
[Refl] :: forall k (a :: k). a :~: a
infix 4 :~:

-- | A constraint for "<tt>uni1</tt> is a subuniverse of <tt>uni2</tt>".
type uni1 <: uni2 = uni1 `Everywhere` Includes uni2

-- | The universe used by default.
data DefaultUni a
[DefaultUniInteger] :: DefaultUni (Esc Integer)
[DefaultUniByteString] :: DefaultUni (Esc ByteString)
[DefaultUniChar] :: DefaultUni (Esc Char)
[DefaultUniUnit] :: DefaultUni (Esc ())
[DefaultUniBool] :: DefaultUni (Esc Bool)
[DefaultUniProtoList] :: DefaultUni (Esc [])
[DefaultUniProtoPair] :: DefaultUni (Esc (,))
[DefaultUniApply] :: !DefaultUni (Esc f) -> !DefaultUni (Esc a) -> DefaultUni (Esc (f a))
pattern DefaultUniList :: forall a k1 k2 (f :: k1 -> k2) (a1 :: k1). () => (a ~ Esc (f a1), Esc f ~ Esc []) => DefaultUni (Esc a1) -> DefaultUni a
pattern DefaultUniPair :: forall a k1 k2 (f1 :: k1 -> k2) (a1 :: k1) k3 k4 (f2 :: k3 -> k4) (a2 :: k3). () => (a ~ Esc (f1 a1), Esc f1 ~ Esc (f2 a2), Esc f2 ~ Esc (,)) => DefaultUni (Esc a2) -> DefaultUni (Esc a1) -> DefaultUni a
pattern DefaultUniString :: forall a k1 k2 (f :: k1 -> k2) (a1 :: k1). () => (a ~ Esc (f a1), Esc f ~ Esc [], Esc a1 ~ Esc Char) => DefaultUni a

-- | Default built-in functions.
data DefaultFun
AddInteger :: DefaultFun
SubtractInteger :: DefaultFun
MultiplyInteger :: DefaultFun
DivideInteger :: DefaultFun
QuotientInteger :: DefaultFun
RemainderInteger :: DefaultFun
ModInteger :: DefaultFun
LessThanInteger :: DefaultFun
LessThanEqInteger :: DefaultFun
GreaterThanInteger :: DefaultFun
GreaterThanEqInteger :: DefaultFun
EqInteger :: DefaultFun
Concatenate :: DefaultFun
TakeByteString :: DefaultFun
DropByteString :: DefaultFun
SHA2 :: DefaultFun
SHA3 :: DefaultFun
VerifySignature :: DefaultFun
EqByteString :: DefaultFun
LtByteString :: DefaultFun
GtByteString :: DefaultFun
IfThenElse :: DefaultFun
CharToString :: DefaultFun
Append :: DefaultFun
EqualsString :: DefaultFun
EncodeUtf8 :: DefaultFun
DecodeUtf8 :: DefaultFun
Trace :: DefaultFun
Nop1 :: DefaultFun
Nop2 :: DefaultFun
Nop3 :: DefaultFun
data Term tyname name uni fun ann

-- | a named variable
Var :: ann -> name -> Term tyname name uni fun ann
TyAbs :: ann -> tyname -> Kind ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
LamAbs :: ann -> name -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
Apply :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann

-- | a constant term
Constant :: ann -> Some (ValueOf uni) -> Term tyname name uni fun ann
Builtin :: ann -> fun -> Term tyname name uni fun ann
TyInst :: ann -> Term tyname name uni fun ann -> Type tyname uni ann -> Term tyname name uni fun ann
Unwrap :: ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
IWrap :: ann -> Type tyname uni ann -> Type tyname uni ann -> Term tyname name uni fun ann -> Term tyname name uni fun ann
Error :: ann -> Type tyname uni ann -> Term tyname name uni fun ann

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>.
termSubterms :: Traversal' (Term tyname name uni fun ann) (Term tyname name uni fun ann)

-- | Get all the direct child <a>Type</a>s of the given <a>Term</a>.
termSubtypes :: Traversal' (Term tyname name uni fun ann) (Type tyname uni ann)

-- | A <a>Type</a> assigned to expressions.
data Type tyname uni ann
TyVar :: ann -> tyname -> Type tyname uni ann
TyFun :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Fix-point type, for constructing self-recursive types
TyIFix :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann
TyForall :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Builtin type
TyBuiltin :: ann -> SomeTypeIn uni -> Type tyname uni ann
TyLam :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann
TyApp :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Get all the direct child <a>Type</a>s of the given <a>Type</a>.
typeSubtypes :: Traversal' (Type tyname uni ann) (Type tyname uni ann)
data Kind ann
Type :: ann -> Kind ann
KindArrow :: ann -> Kind ann -> Kind ann -> Kind ann

-- | An error encountered during parsing.
data ParseError ann
LexErr :: String -> ParseError ann
Unexpected :: Token ann -> ParseError ann
UnknownBuiltinType :: ann -> Text -> ParseError ann
BuiltinTypeNotAStar :: ann -> Text -> ParseError ann
UnknownBuiltinFunction :: ann -> Text -> ParseError ann
InvalidBuiltinConstant :: ann -> Text -> Text -> ParseError ann

-- | Version of Plutus Core to be used for the program.
data Version ann
Version :: ann -> Natural -> Natural -> Natural -> Version ann

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a <a>Version</a>
--   of the core language.
data Program tyname name uni fun ann
Program :: ann -> Version ann -> Term tyname name uni fun ann -> Program tyname name uni fun ann

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name
Name :: Text -> Unique -> Name

-- | The identifier name, for use in error messages.
[nameString] :: Name -> Text

-- | A <a>Unique</a> assigned to the name, allowing for cheap comparisons
--   in the compiler.
[nameUnique] :: Name -> Unique

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName
TyName :: Name -> TyName
[unTyName] :: TyName -> Name

-- | A unique identifier
newtype Unique
Unique :: Int -> Unique
[unUnique] :: Unique -> Int

-- | A mapping from uniques to values of type <tt>a</tt>.
newtype UniqueMap unique a
UniqueMap :: IntMap a -> UniqueMap unique a
[unUniqueMap] :: UniqueMap unique a -> IntMap a
newtype Normalized a
Normalized :: a -> Normalized a
[unNormalized] :: Normalized a -> a

-- | The default version of Plutus Core supported by this library.
defaultVersion :: ann -> Version ann

-- | The list of all <a>Keyword</a>s.
allKeywords :: [Keyword]
toTerm :: Program tyname name uni fun ann -> Term tyname name uni fun ann
termAnn :: Term tyname name uni fun ann -> ann
typeAnn :: Type tyname uni ann -> ann

-- | Map a function over the set of built-in functions.
mapFun :: (fun -> fun') -> Term tyname name uni fun ann -> Term tyname name uni fun' ann

-- | A term name as a de Bruijn index, without the name string.
newtype DeBruijn
DeBruijn :: Index -> DeBruijn
[dbnIndex] :: DeBruijn -> Index

-- | A term name as a de Bruijn index.
data NamedDeBruijn
NamedDeBruijn :: Text -> Index -> NamedDeBruijn
[ndbnString] :: NamedDeBruijn -> Text
[ndbnIndex] :: NamedDeBruijn -> Index

-- | Convert a <a>Program</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Program</a> with <a>NamedTyDeBruijn</a>s and <a>NamedDeBruijn</a>s.
deBruijnProgram :: (AsFreeVariableError e, MonadError e m) => Program TyName Name uni fun ann -> m (Program NamedTyDeBruijn NamedDeBruijn uni fun ann)

-- | Convert a <a>Term</a> with <a>TyName</a>s and <a>Name</a>s into a
--   <a>Term</a> with <a>NamedTyDeBruijn</a>s and <a>NamedDeBruijn</a>s.
deBruijnTerm :: (AsFreeVariableError e, MonadError e m) => Term TyName Name uni fun ann -> m (Term NamedTyDeBruijn NamedDeBruijn uni fun ann)

-- | Convert a <a>Program</a> with <a>NamedTyDeBruijn</a>s and
--   <a>NamedDeBruijn</a>s into a <a>Program</a> with <a>TyName</a>s and
--   <a>Name</a>s.
unDeBruijnProgram :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Program NamedTyDeBruijn NamedDeBruijn uni fun ann -> m (Program TyName Name uni fun ann)

-- | Convert a <a>Term</a> with <a>NamedTyDeBruijn</a>s and
--   <a>NamedDeBruijn</a>s into a <a>Term</a> with <a>TyName</a>s and
--   <a>Name</a>s.
unDeBruijnTerm :: (MonadQuote m, AsFreeVariableError e, MonadError e m) => Term NamedTyDeBruijn NamedDeBruijn uni fun ann -> m (Term TyName Name uni fun ann)
data AlexPosn
AlexPn :: !Int -> !Int -> !Int -> AlexPosn
format :: (AsParseError e AlexPosn, MonadError e m) => PrettyConfigPlc -> ByteString -> m Text
formatDoc :: (AsParseError e AlexPosn, MonadError e m) => PrettyConfigPlc -> ByteString -> m (Doc a)

-- | All kinds of uniques an entity contains.
type family HasUniques a :: Constraint

-- | For getting the Plutus kind of a type from the universe.
class ToKind (uni :: Type -> Type)
toKind :: forall k (a :: k). ToKind uni => uni (Esc a) -> Kind ()

-- | The class of things that can be renamed. I.e. things that are capable
--   of satisfying the global uniqueness condition.
class Rename a

-- | Rename <a>Unique</a>s so that they're globally unique. In case there
--   are any free variables, they must be left untouched and bound
--   variables must not get renamed to free ones. Must always assign new
--   names to bound variables, so that <tt>rename</tt> can be used for
--   alpha-renaming as well.
rename :: (Rename a, MonadQuote m) => a -> m a
type Typecheckable uni fun = (ToKind uni, HasUniApply uni, ToBuiltinMeaning uni fun)

-- | Mapping from <a>Builtin</a>s to their <a>Type</a>s.
newtype BuiltinTypes uni fun
BuiltinTypes :: Maybe (Array fun (Dupable (Normalized (Type TyName uni ())))) -> BuiltinTypes uni fun
[unBuiltinTypes] :: BuiltinTypes uni fun -> Maybe (Array fun (Dupable (Normalized (Type TyName uni ()))))

-- | Configuration of the type checker.
newtype TypeCheckConfig uni fun
TypeCheckConfig :: BuiltinTypes uni fun -> TypeCheckConfig uni fun
[_tccBuiltinTypes] :: TypeCheckConfig uni fun -> BuiltinTypes uni fun
tccBuiltinTypes :: HasTypeCheckConfig c_a3y6w uni_a3y5j fun_a3y5k => Lens' c_a3y6w (BuiltinTypes uni_a3y5j fun_a3y5k)

-- | Extract the <a>TypeScheme</a> from a <a>BuiltinMeaning</a> and convert
--   it to the corresponding <a>Type</a> for each built-in function.
builtinMeaningsToTypes :: (MonadError err m, AsTypeError err term uni fun ann, Typecheckable uni fun) => ann -> m (BuiltinTypes uni fun)

-- | Get the default type checking config.
getDefTypeCheckConfig :: (MonadError err m, AsTypeError err term uni fun ann, Typecheckable uni fun) => ann -> m (TypeCheckConfig uni fun)

-- | Infer the kind of a type.
inferKind :: (MonadQuote m, MonadError err m, AsTypeError err term uni fun ann, ToKind uni) => TypeCheckConfig uni fun -> Type TyName uni ann -> m (Kind ())

-- | Check a type against a kind. Infers the kind of the type and checks
--   that it's equal to the given kind throwing a <a>TypeError</a>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
checkKind :: (MonadQuote m, MonadError err m, AsTypeError err term uni fun ann, ToKind uni) => TypeCheckConfig uni fun -> ann -> Type TyName uni ann -> Kind () -> m ()

-- | Infer the type of a term.
inferType :: (MonadError err m, MonadQuote m, AsTypeError err (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, GEq uni, Ix fun) => TypeCheckConfig uni fun -> Term TyName Name uni fun ann -> m (Normalized (Type TyName uni ()))

-- | Check a term against a type. Infers the type of the term and checks
--   that it's equal to the given type throwing a <a>TypeError</a>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
checkType :: (MonadError err m, MonadQuote m, AsTypeError err (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, GEq uni, Ix fun) => TypeCheckConfig uni fun -> ann -> Term TyName Name uni fun ann -> Normalized (Type TyName uni ()) -> m ()

-- | Infer the type of a program.
inferTypeOfProgram :: (MonadError err m, MonadQuote m, AsTypeError err (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, GEq uni, Ix fun) => TypeCheckConfig uni fun -> Program TyName Name uni fun ann -> m (Normalized (Type TyName uni ()))

-- | Check a program against a type. Infers the type of the program and
--   checks that it's equal to the given type throwing a <a>TypeError</a>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
checkTypeOfProgram :: (MonadError err m, MonadQuote m, AsTypeError err (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, GEq uni, Ix fun) => TypeCheckConfig uni fun -> ann -> Program TyName Name uni fun ann -> Normalized (Type TyName uni ()) -> m ()

-- | Given a file at <tt>fibonacci.plc</tt>, <tt>fileType
--   "fibonacci.plc"</tt> will display its type or an error message.
fileType :: FilePath -> IO Text

-- | Given a file, display its type or an error message, optionally dumping
--   annotations and debug information.
fileTypeCfg :: PrettyConfigPlc -> FilePath -> IO Text

-- | Print the type of a program contained in a <tt>ByteString</tt>
printType :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, AsTypeError e (Term TyName Name DefaultUni DefaultFun ()) DefaultUni DefaultFun AlexPosn, MonadError e m) => ByteString -> m Text

-- | Normalize every <a>Type</a> in a <a>Term</a>.
normalizeTypesIn :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadQuote m, HasUniApply uni) => Term tyname name uni fun ann -> m (Term tyname name uni fun ann)

-- | Normalize every <a>Type</a> in a <a>Program</a>.
normalizeTypesInProgram :: (HasUnique tyname TypeUnique, HasUnique name TermUnique, MonadQuote m, HasUniApply uni) => Program tyname name uni fun ann -> m (Program tyname name uni fun ann)
class AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 | r_a3mHv -> term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0
_TypeError :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (TypeError term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0)
_KindMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Type TyName uni_a3mcY (), Kind (), Kind ())
_TypeMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, term_a3mcX, Type TyName uni_a3mcY (), Normalized (Type TyName uni_a3mcY ()))
_FreeTypeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, TyName)
_FreeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Name)
_UnknownBuiltinFunctionE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, fun_a3mcZ)
data TypeError term uni fun ann

-- | Parse a program and typecheck it.
parseTypecheck :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, AsTypeError e (Term TyName Name DefaultUni DefaultFun ()) DefaultUni DefaultFun AlexPosn, MonadError e m, MonadQuote m) => TypeCheckConfig DefaultUni DefaultFun -> ByteString -> m (Normalized (Type TyName DefaultUni ()))

-- | Typecheck a program.
typecheckPipeline :: (AsTypeError e (Term TyName Name DefaultUni DefaultFun ()) DefaultUni DefaultFun a, MonadError e m, MonadQuote m) => TypeCheckConfig DefaultUni DefaultFun -> Program TyName Name DefaultUni DefaultFun a -> m (Normalized (Type TyName DefaultUni ()))
data Error uni fun ann
ParseErrorE :: ParseError ann -> Error uni fun ann
UniqueCoherencyErrorE :: UniqueError ann -> Error uni fun ann
TypeErrorE :: TypeError (Term TyName Name uni fun ()) uni fun ann -> Error uni fun ann
NormCheckErrorE :: NormCheckError TyName Name uni fun ann -> Error uni fun ann
FreeVariableErrorE :: FreeVariableError -> Error uni fun ann
class AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk | r_a3n86 -> uni_a3mIi fun_a3mIj ann_a3mIk
_Error :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (Error uni_a3mIi fun_a3mIj ann_a3mIk)
_ParseErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (ParseError ann_a3mIk)
_UniqueCoherencyErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (UniqueError ann_a3mIk)
_TypeErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (TypeError (Term TyName Name uni_a3mIi fun_a3mIj ()) uni_a3mIi fun_a3mIj ann_a3mIk)
_NormCheckErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 (NormCheckError TyName Name uni_a3mIi fun_a3mIj ann_a3mIk)
_FreeVariableErrorE :: AsError r_a3n86 uni_a3mIi fun_a3mIj ann_a3mIk => Prism' r_a3n86 FreeVariableError
data NormCheckError tyname name uni fun ann
BadType :: ann -> Type tyname uni ann -> Text -> NormCheckError tyname name uni fun ann
BadTerm :: ann -> Term tyname name uni fun ann -> Text -> NormCheckError tyname name uni fun ann
class AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM | r_a3mcw -> tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM
_NormCheckError :: AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM => Prism' r_a3mcw (NormCheckError tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM)
_BadType :: AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM => Prism' r_a3mcw (ann_a3lSM, Type tyname_a3lSI uni_a3lSK ann_a3lSM, Text)
_BadTerm :: AsNormCheckError r_a3mcw tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM => Prism' r_a3mcw (ann_a3lSM, Term tyname_a3lSI name_a3lSJ uni_a3lSK fun_a3lSL ann_a3lSM, Text)
data UniqueError ann
MultiplyDefined :: Unique -> ann -> ann -> UniqueError ann
IncoherentUsage :: Unique -> ann -> ann -> UniqueError ann
FreeVariable :: Unique -> ann -> UniqueError ann
class AsUniqueError r_a3lSg ann_a3lwa | r_a3lSg -> ann_a3lwa
_UniqueError :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (UniqueError ann_a3lwa)
_MultiplyDefined :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa, ann_a3lwa)
_IncoherentUsage :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa, ann_a3lwa)
_FreeVariable :: AsUniqueError r_a3lSg ann_a3lwa => Prism' r_a3lSg (Unique, ann_a3lwa)

-- | We cannot do a correct translation to or from de Bruijn indices if the
--   program is not well-scoped. So we throw an error in such a case.
data FreeVariableError
FreeUnique :: Unique -> FreeVariableError
FreeIndex :: Index -> FreeVariableError
class AsFreeVariableError r_aVzL
_FreeVariableError :: AsFreeVariableError r_aVzL => Prism' r_aVzL FreeVariableError
_FreeUnique :: AsFreeVariableError r_aVzL => Prism' r_aVzL Unique
_FreeIndex :: AsFreeVariableError r_aVzL => Prism' r_aVzL Index
data TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
VarF :: ann_aYOK -> name_aYOH -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
TyAbsF :: ann_aYOK -> tyname_aYOG -> Kind ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
LamAbsF :: ann_aYOK -> name_aYOH -> Type tyname_aYOG uni_aYOI ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
ApplyF :: ann_aYOK -> r_a1aX9 -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
ConstantF :: ann_aYOK -> Some (ValueOf uni_aYOI) -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
BuiltinF :: ann_aYOK -> fun_aYOJ -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
TyInstF :: ann_aYOK -> r_a1aX9 -> Type tyname_aYOG uni_aYOI ann_aYOK -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
UnwrapF :: ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
IWrapF :: ann_aYOK -> Type tyname_aYOG uni_aYOI ann_aYOK -> Type tyname_aYOG uni_aYOI ann_aYOK -> r_a1aX9 -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
ErrorF :: ann_aYOK -> Type tyname_aYOG uni_aYOI ann_aYOK -> TermF (tyname_aYOG :: Type) (name_aYOH :: Type) (uni_aYOI :: Type -> Type) (fun_aYOJ :: Type) (ann_aYOK :: Type) r_a1aX9
data TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyVarF :: ann_aYON -> tyname_aYOL -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyFunF :: ann_aYON -> r_a1aSR -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyIFixF :: ann_aYON -> r_a1aSR -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyForallF :: ann_aYON -> tyname_aYOL -> Kind ann_aYON -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyBuiltinF :: ann_aYON -> SomeTypeIn uni_aYOM -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyLamF :: ann_aYON -> tyname_aYOL -> Kind ann_aYON -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR
TyAppF :: ann_aYON -> r_a1aSR -> r_a1aSR -> TypeF (tyname_aYOL :: Type) (uni_aYOM :: Type -> Type) (ann_aYON :: Type) r_a1aSR

-- | A non-transformer version of <a>QuoteT</a>.
type Quote = QuoteT Identity

-- | See <a>runQuoteT</a>.
runQuote :: Quote a -> a

-- | The "quotation" monad transformer. Within this monad you can do safe
--   construction of PLC terms using quasiquotation, fresh-name generation,
--   and parsing.
data QuoteT m a

-- | Run a quote from an empty identifier state. Note that the resulting
--   term cannot necessarily be safely combined with other terms - that
--   should happen inside <a>QuoteT</a>.
runQuoteT :: Monad m => QuoteT m a -> m a

-- | A monad that allows lifting of quoted expressions.
class Monad m => MonadQuote m
liftQuote :: MonadQuote m => Quote a -> m a

-- | Get a fresh <a>Unique</a>.
freshUnique :: MonadQuote m => m Unique

-- | Get a fresh <a>Name</a>, given the annotation and the <a>Text</a>
--   name.
freshName :: MonadQuote m => Text -> m Name

-- | Get a fresh <a>TyName</a>, given the annotation and the <a>Text</a>
--   name.
freshTyName :: MonadQuote m => Text -> m TyName

-- | The parameterized type of results various evaluation engines return.
--   On the PLC side this becomes (via <tt>makeKnown</tt>) either a call to
--   <tt>Error</tt> or a value of the PLC counterpart of type <tt>a</tt>.
data EvaluationResult a
EvaluationSuccess :: a -> EvaluationResult a
EvaluationFailure :: EvaluationResult a

-- | Take one PLC program and apply it to another.
applyProgram :: Program tyname name uni fun () -> Program tyname name uni fun () -> Program tyname name uni fun ()

-- | Count the number of AST nodes in a term.
termSize :: Term tyname name uni fun ann -> Integer

-- | Count the number of AST nodes in a type.
typeSize :: Type tyname uni ann -> Integer

-- | Count the number of AST nodes in a kind.
kindSize :: Kind a -> Integer

-- | Count the number of AST nodes in a program.
programSize :: Program tyname name uni fun ann -> Integer

-- | Compute the size of the serializabled form of a value.
serialisedSize :: Serialise a => a -> Integer

-- | The default cost model for built-in functions.
defaultBuiltinCostModel :: BuiltinCostModel
defaultBuiltinsRuntime :: HasConstantIn DefaultUni term => BuiltinsRuntime DefaultFun term
defaultCekCostModel :: CostModel CekMachineCosts BuiltinCostModel

-- | Default costs for CEK machine instructions.
defaultCekMachineCosts :: CekMachineCosts
defaultCekParameters :: MachineParameters CekMachineCosts CekValue DefaultUni DefaultFun

-- | The default cost model data. This is exposed to the ledger, so let's
--   not confuse anybody by mentioning the CEK machine
defaultCostModelParams :: Maybe CostModelParams
unitCekParameters :: MachineParameters CekMachineCosts CekValue DefaultUni DefaultFun

-- | The prefix of the field names in the CekMachineCosts type, used for
--   extracting the CekMachineCosts component of the ledger's cost model
--   parameters. See Note [Cost model parameters] in CostModelInterface.
cekMachineCostsPrefix :: Text

-- | Costs for evaluating AST nodes. Times should be specified in
--   picoseconds, memory sizes in bytes.
data CekMachineCosts
CekMachineCosts :: ExBudget -> ExBudget -> ExBudget -> ExBudget -> ExBudget -> ExBudget -> ExBudget -> ExBudget -> CekMachineCosts
[cekStartupCost] :: CekMachineCosts -> ExBudget
[cekVarCost] :: CekMachineCosts -> ExBudget
[cekConstCost] :: CekMachineCosts -> ExBudget
[cekLamCost] :: CekMachineCosts -> ExBudget
[cekDelayCost] :: CekMachineCosts -> ExBudget
[cekForceCost] :: CekMachineCosts -> ExBudget
[cekApplyCost] :: CekMachineCosts -> ExBudget

-- | Just the cost of evaluating a Builtin node, not the builtin itself.
--   There's no entry for Error since we'll be exiting anyway; also, what
--   would happen if calling <tt>Error</tt> caused the budget to be
--   exceeded?
[cekBuiltinCost] :: CekMachineCosts -> ExBudget

module PlutusIR.Core.Type

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName
TyName :: Name -> TyName
[unTyName] :: TyName -> Name

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name
Name :: Text -> Unique -> Name

-- | The identifier name, for use in error messages.
[nameString] :: Name -> Text

-- | A <a>Unique</a> assigned to the name, allowing for cheap comparisons
--   in the compiler.
[nameUnique] :: Name -> Unique

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl tyname name uni fun ann
VarDecl :: ann -> name -> Type tyname uni ann -> VarDecl tyname name uni fun ann
[varDeclAnn] :: VarDecl tyname name uni fun ann -> ann
[varDeclName] :: VarDecl tyname name uni fun ann -> name
[varDeclType] :: VarDecl tyname name uni fun ann -> Type tyname uni ann

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl tyname ann
TyVarDecl :: ann -> tyname -> Kind ann -> TyVarDecl tyname ann
[tyVarDeclAnn] :: TyVarDecl tyname ann -> ann
[tyVarDeclName] :: TyVarDecl tyname ann -> tyname
[tyVarDeclKind] :: TyVarDecl tyname ann -> Kind ann
varDeclNameString :: VarDecl tyname Name uni fun a -> String
tyVarDeclNameString :: TyVarDecl TyName a -> String
data Kind ann
Type :: ann -> Kind ann
KindArrow :: ann -> Kind ann -> Kind ann -> Kind ann

-- | A <a>Type</a> assigned to expressions.
data Type tyname uni ann
TyVar :: ann -> tyname -> Type tyname uni ann
TyFun :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Fix-point type, for constructing self-recursive types
TyIFix :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann
TyForall :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Builtin type
TyBuiltin :: ann -> SomeTypeIn uni -> Type tyname uni ann
TyLam :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann
TyApp :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann
data Datatype tyname name uni fun a
Datatype :: a -> TyVarDecl tyname a -> [TyVarDecl tyname a] -> name -> [VarDecl tyname name uni fun a] -> Datatype tyname name uni fun a
datatypeNameString :: Datatype TyName Name uni fun a -> String

-- | Each multi-let-group has to be marked with its scoping: *
--   <a>NonRec</a>: the identifiers introduced by this multi-let are only
--   linearly-scoped, i.e. an identifer cannot refer to itself or
--   later-introduced identifiers of the group. * <a>Rec</a>: an
--   identifiers introduced by this multi-let group can use all other
--   multi-lets of the same group (including itself), thus permitting
--   (mutual) recursion.
data Recursivity
NonRec :: Recursivity
Rec :: Recursivity
data Strictness
NonStrict :: Strictness
Strict :: Strictness
data Binding tyname name uni fun a
TermBind :: a -> Strictness -> VarDecl tyname name uni fun a -> Term tyname name uni fun a -> Binding tyname name uni fun a
TypeBind :: a -> TyVarDecl tyname a -> Type tyname uni a -> Binding tyname name uni fun a
DatatypeBind :: a -> Datatype tyname name uni fun a -> Binding tyname name uni fun a
data Term tyname name uni fun a
Let :: a -> Recursivity -> NonEmpty (Binding tyname name uni fun a) -> Term tyname name uni fun a -> Term tyname name uni fun a
Var :: a -> name -> Term tyname name uni fun a
TyAbs :: a -> tyname -> Kind a -> Term tyname name uni fun a -> Term tyname name uni fun a
LamAbs :: a -> name -> Type tyname uni a -> Term tyname name uni fun a -> Term tyname name uni fun a
Apply :: a -> Term tyname name uni fun a -> Term tyname name uni fun a -> Term tyname name uni fun a
Constant :: a -> Some (ValueOf uni) -> Term tyname name uni fun a
Builtin :: a -> fun -> Term tyname name uni fun a
TyInst :: a -> Term tyname name uni fun a -> Type tyname uni a -> Term tyname name uni fun a
Error :: a -> Type tyname uni a -> Term tyname name uni fun a
IWrap :: a -> Type tyname uni a -> Type tyname uni a -> Term tyname name uni fun a -> Term tyname name uni fun a
Unwrap :: a -> Term tyname name uni fun a -> Term tyname name uni fun a
data Program tyname name uni fun a
Program :: a -> Term tyname name uni fun a -> Program tyname name uni fun a
instance GHC.Generics.Generic (PlutusIR.Core.Type.Datatype tyname name uni fun a)
instance (GHC.Show.Show a, GHC.Show.Show tyname, GHC.Show.Show name, Data.GADT.Internal.GShow uni) => GHC.Show.Show (PlutusIR.Core.Type.Datatype tyname name uni fun a)
instance GHC.Base.Functor (PlutusIR.Core.Type.Datatype tyname name uni fun)
instance GHC.Classes.Ord PlutusIR.Core.Type.Recursivity
instance GHC.Generics.Generic PlutusIR.Core.Type.Recursivity
instance GHC.Classes.Eq PlutusIR.Core.Type.Recursivity
instance GHC.Show.Show PlutusIR.Core.Type.Recursivity
instance GHC.Generics.Generic PlutusIR.Core.Type.Strictness
instance GHC.Classes.Eq PlutusIR.Core.Type.Strictness
instance GHC.Show.Show PlutusIR.Core.Type.Strictness
instance GHC.Generics.Generic (PlutusIR.Core.Type.Binding tyname name uni fun a)
instance (Universe.Core.Everywhere uni GHC.Show.Show, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, GHC.Show.Show a, GHC.Show.Show name, GHC.Show.Show tyname, GHC.Show.Show fun) => GHC.Show.Show (PlutusIR.Core.Type.Binding tyname name uni fun a)
instance GHC.Base.Functor (PlutusIR.Core.Type.Binding tyname name uni fun)
instance GHC.Generics.Generic (PlutusIR.Core.Type.Term tyname name uni fun a)
instance (Universe.Core.Everywhere uni GHC.Show.Show, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, GHC.Show.Show a, GHC.Show.Show name, GHC.Show.Show tyname, GHC.Show.Show fun) => GHC.Show.Show (PlutusIR.Core.Type.Term tyname name uni fun a)
instance GHC.Base.Functor (PlutusIR.Core.Type.Term tyname name uni fun)
instance GHC.Generics.Generic (PlutusIR.Core.Type.Program tyname name uni fun a)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat fun, Flat.Class.Flat a, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusIR.Core.Type.Program tyname name uni fun a)
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat fun, Flat.Class.Flat a, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusIR.Core.Type.Binding tyname name uni fun a)
instance PlutusCore.Constant.Typed.AsConstant (PlutusIR.Core.Type.Term tyname name uni fun ann)
instance PlutusCore.Constant.Typed.FromConstant (PlutusIR.Core.Type.Term tyname name uni fun ())
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat fun, Flat.Class.Flat a, Flat.Class.Flat tyname, Flat.Class.Flat name) => Flat.Class.Flat (PlutusIR.Core.Type.Term tyname name uni fun a)
instance PlutusCore.MkPlc.TermLike (PlutusIR.Core.Type.Term tyname name uni fun) tyname name uni fun
instance Flat.Class.Flat PlutusIR.Core.Type.Strictness
instance GHC.Base.Semigroup PlutusIR.Core.Type.Recursivity
instance Flat.Class.Flat PlutusIR.Core.Type.Recursivity
instance (Universe.Core.Closed uni, Universe.Core.Everywhere uni Flat.Class.Flat, Flat.Class.Flat a, Flat.Class.Flat tyname, Flat.Class.Flat name, Flat.Class.Flat fun) => Flat.Class.Flat (PlutusIR.Core.Type.Datatype tyname name uni fun a)

module PlutusIR.Core.Plated

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>,
--   including those within <a>Binding</a>s.
termSubterms :: Traversal' (Term tyname name uni fun a) (Term tyname name uni fun a)

-- | Get all the transitive child <a>Term</a>s of the given <a>Term</a>.
termSubtermsDeep :: Fold (Term tyname name uni fun ann) (Term tyname name uni fun ann)

-- | Get all the direct child <a>Type</a>s of the given <a>Term</a>,
--   including those within <a>Binding</a>s.
termSubtypes :: Traversal' (Term tyname name uni fun a) (Type tyname uni a)

-- | Get all the transitive child <a>Type</a>s of the given <a>Term</a>.
termSubtypesDeep :: Fold (Term tyname name uni fun ann) (Type tyname uni ann)

-- | Get all the direct child <a>Binding</a>s of the given <a>Term</a>.
termBindings :: Traversal' (Term tyname name uni fun a) (Binding tyname name uni fun a)

-- | Get all the direct child <a>Type</a>s of the given <a>Type</a>.
typeSubtypes :: Traversal' (Type tyname uni ann) (Type tyname uni ann)

-- | Get all the transitive child <a>Type</a>s of the given <a>Type</a>.
typeSubtypesDeep :: Fold (Type tyname uni ann) (Type tyname uni ann)

-- | Get all the direct child <a>Unique</a>s of the given <a>Type</a> from
--   binders <a>TyVar</a>s.
typeUniques :: HasUniques (Type tyname uni ann) => Traversal' (Type tyname uni ann) Unique

-- | Get all the transitive child <a>Unique</a>s of the given <a>Type</a>.
typeUniquesDeep :: HasUniques (Type tyname uni ann) => Fold (Type tyname uni ann) Unique

-- | Get all the direct child <a>Type</a>s of the given <a>Datatype</a>.
datatypeSubtypes :: Traversal' (Datatype tyname name uni fun a) (Type tyname uni a)

-- | Get all the direct child <a>Term</a>s of the given <a>Binding</a>.
bindingSubterms :: Traversal' (Binding tyname name uni fun a) (Term tyname name uni fun a)

-- | Get all the direct child <a>Type</a>s of the given <a>Binding</a>.
bindingSubtypes :: Traversal' (Binding tyname name uni fun a) (Type tyname uni a)

-- | All the identifiers/names introduced by this binding In case of a
--   datatype-binding it has multiple identifiers: the type, constructors,
--   match function
bindingIds :: (HasUnique tyname TypeUnique, HasUnique name TermUnique) => Traversal' (Binding tyname name uni fun a) Unique

-- | Get all the direct child <tt>Unique</tt>s of the given <a>Term</a>
--   (including the type-level ones).
termUniques :: HasUniques (Term tyname name uni fun ann) => Traversal' (Term tyname name uni fun ann) Unique

-- | Get all the transitive child <tt>Unique</tt>s of the given <a>Term</a>
--   (including the type-level ones).
termUniquesDeep :: HasUniques (Term tyname name uni fun ann) => Fold (Term tyname name uni fun ann) Unique

module PlutusIR.Core.Instance.Pretty
instance (PlutusCore.Pretty.Classic.PrettyClassicBy configName tyname, PlutusCore.Pretty.Classic.PrettyClassicBy configName name, Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst) => Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (PlutusCore.MkPlc.VarDecl tyname name uni fun a)
instance PlutusCore.Pretty.Classic.PrettyClassicBy configName tyname => Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (PlutusCore.MkPlc.TyVarDecl tyname a)
instance Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) PlutusIR.Core.Type.Recursivity
instance Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) PlutusIR.Core.Type.Strictness
instance (PlutusCore.Pretty.Classic.PrettyClassicBy configName tyname, PlutusCore.Pretty.Classic.PrettyClassicBy configName name, Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst) => Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (PlutusIR.Core.Type.Datatype tyname name uni fun a)
instance (PlutusCore.Pretty.Classic.PrettyClassicBy configName tyname, PlutusCore.Pretty.Classic.PrettyClassicBy configName name, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (PlutusIR.Core.Type.Binding tyname name uni fun a)
instance (PlutusCore.Pretty.Classic.PrettyClassicBy configName tyname, PlutusCore.Pretty.Classic.PrettyClassicBy configName name, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (PlutusIR.Core.Type.Term tyname name uni fun a)
instance (PlutusCore.Pretty.Classic.PrettyClassicBy configName tyname, PlutusCore.Pretty.Classic.PrettyClassicBy configName name, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun) => Text.PrettyBy.Internal.PrettyBy (PlutusCore.Pretty.Classic.PrettyConfigClassic configName) (PlutusIR.Core.Type.Program tyname name uni fun a)
instance PlutusCore.Pretty.Classic.PrettyClassic tyname => Prettyprinter.Internal.Pretty (PlutusCore.MkPlc.TyVarDecl tyname a)
instance (PlutusCore.Pretty.Classic.PrettyClassic tyname, PlutusCore.Pretty.Classic.PrettyClassic name, Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst) => Prettyprinter.Internal.Pretty (PlutusCore.MkPlc.VarDecl tyname name uni fun a)
instance (PlutusCore.Pretty.Classic.PrettyClassic tyname, PlutusCore.Pretty.Classic.PrettyClassic name, Data.GADT.Internal.GShow uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst) => Prettyprinter.Internal.Pretty (PlutusIR.Core.Type.Datatype tyname name uni fun a)
instance (PlutusCore.Pretty.Classic.PrettyClassic tyname, PlutusCore.Pretty.Classic.PrettyClassic name, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun) => Prettyprinter.Internal.Pretty (PlutusIR.Core.Type.Binding tyname name uni fun a)
instance (PlutusCore.Pretty.Classic.PrettyClassic tyname, PlutusCore.Pretty.Classic.PrettyClassic name, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun) => Prettyprinter.Internal.Pretty (PlutusIR.Core.Type.Term tyname name uni fun a)
instance (PlutusCore.Pretty.Classic.PrettyClassic tyname, PlutusCore.Pretty.Classic.PrettyClassic name, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun) => Prettyprinter.Internal.Pretty (PlutusIR.Core.Type.Program tyname name uni fun a)

module PlutusIR.Core.Instance

module PlutusIR.Core

module PlutusIR.Subst
uniquesTerm :: HasUniques (Term tyname name uni fun ann) => Term tyname name uni fun ann -> Set Unique

-- | Get all the uniques in a type.
uniquesType :: HasUniques (Type tyname uni ann) => Type tyname uni ann -> Set Unique

module PlutusIR.Mark

-- | Marks all the <tt>Unique</tt>s in a term as used, so they will not be
--   generated in future. Useful if you have a term which was not generated
--   in <a>Quote</a>.
markNonFreshTerm :: (HasUniques (Term tyname name uni fun ann), MonadQuote m) => Term tyname name uni fun ann -> m ()

-- | Marks all the <tt>Unique</tt>s in a type as used, so they will not be
--   generated in future. Useful if you have a type which was not generated
--   in <a>Quote</a>.
markNonFreshType :: (HasUniques (Type tyname uni ann), MonadQuote m) => Type tyname uni ann -> m ()

-- | Marks all the <tt>Unique</tt>s in a program as used, so they will not
--   be generated in future. Useful if you have a program which was not
--   generated in <a>Quote</a>.
markNonFreshProgram :: (HasUniques (Program tyname name uni fun ann), MonadQuote m) => Program tyname name uni fun ann -> m ()

module PlutusIR
data Term tyname name uni fun a
Let :: a -> Recursivity -> NonEmpty (Binding tyname name uni fun a) -> Term tyname name uni fun a -> Term tyname name uni fun a
Var :: a -> name -> Term tyname name uni fun a
TyAbs :: a -> tyname -> Kind a -> Term tyname name uni fun a -> Term tyname name uni fun a
LamAbs :: a -> name -> Type tyname uni a -> Term tyname name uni fun a -> Term tyname name uni fun a
Apply :: a -> Term tyname name uni fun a -> Term tyname name uni fun a -> Term tyname name uni fun a
Constant :: a -> Some (ValueOf uni) -> Term tyname name uni fun a
Builtin :: a -> fun -> Term tyname name uni fun a
TyInst :: a -> Term tyname name uni fun a -> Type tyname uni a -> Term tyname name uni fun a
Error :: a -> Type tyname uni a -> Term tyname name uni fun a
IWrap :: a -> Type tyname uni a -> Type tyname uni a -> Term tyname name uni fun a -> Term tyname name uni fun a
Unwrap :: a -> Term tyname name uni fun a -> Term tyname name uni fun a

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>,
--   including those within <a>Binding</a>s.
termSubterms :: Traversal' (Term tyname name uni fun a) (Term tyname name uni fun a)

-- | Get all the direct child <a>Type</a>s of the given <a>Term</a>,
--   including those within <a>Binding</a>s.
termSubtypes :: Traversal' (Term tyname name uni fun a) (Type tyname uni a)

-- | Get all the direct child <a>Binding</a>s of the given <a>Term</a>.
termBindings :: Traversal' (Term tyname name uni fun a) (Binding tyname name uni fun a)

-- | A <a>Type</a> assigned to expressions.
data Type tyname uni ann
TyVar :: ann -> tyname -> Type tyname uni ann
TyFun :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Fix-point type, for constructing self-recursive types
TyIFix :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann
TyForall :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann

-- | Builtin type
TyBuiltin :: ann -> SomeTypeIn uni -> Type tyname uni ann
TyLam :: ann -> tyname -> Kind ann -> Type tyname uni ann -> Type tyname uni ann
TyApp :: ann -> Type tyname uni ann -> Type tyname uni ann -> Type tyname uni ann

-- | Get all the direct child <a>Type</a>s of the given <a>Type</a>.
typeSubtypes :: Traversal' (Type tyname uni ann) (Type tyname uni ann)
data Datatype tyname name uni fun a
Datatype :: a -> TyVarDecl tyname a -> [TyVarDecl tyname a] -> name -> [VarDecl tyname name uni fun a] -> Datatype tyname name uni fun a
datatypeNameString :: Datatype TyName Name uni fun a -> String

-- | Get all the direct child <a>Type</a>s of the given <a>Datatype</a>.
datatypeSubtypes :: Traversal' (Datatype tyname name uni fun a) (Type tyname uni a)
data Kind ann
Type :: ann -> Kind ann
KindArrow :: ann -> Kind ann -> Kind ann -> Kind ann

-- | Each multi-let-group has to be marked with its scoping: *
--   <a>NonRec</a>: the identifiers introduced by this multi-let are only
--   linearly-scoped, i.e. an identifer cannot refer to itself or
--   later-introduced identifiers of the group. * <a>Rec</a>: an
--   identifiers introduced by this multi-let group can use all other
--   multi-lets of the same group (including itself), thus permitting
--   (mutual) recursion.
data Recursivity
NonRec :: Recursivity
Rec :: Recursivity
data Strictness
NonStrict :: Strictness
Strict :: Strictness
data Binding tyname name uni fun a
TermBind :: a -> Strictness -> VarDecl tyname name uni fun a -> Term tyname name uni fun a -> Binding tyname name uni fun a
TypeBind :: a -> TyVarDecl tyname a -> Type tyname uni a -> Binding tyname name uni fun a
DatatypeBind :: a -> Datatype tyname name uni fun a -> Binding tyname name uni fun a

-- | Get all the direct child <a>Term</a>s of the given <a>Binding</a>.
bindingSubterms :: Traversal' (Binding tyname name uni fun a) (Term tyname name uni fun a)

-- | Get all the direct child <a>Type</a>s of the given <a>Binding</a>.
bindingSubtypes :: Traversal' (Binding tyname name uni fun a) (Type tyname uni a)

-- | All the identifiers/names introduced by this binding In case of a
--   datatype-binding it has multiple identifiers: the type, constructors,
--   match function
bindingIds :: (HasUnique tyname TypeUnique, HasUnique name TermUnique) => Traversal' (Binding tyname name uni fun a) Unique
data Program tyname name uni fun a
Program :: a -> Term tyname name uni fun a -> Program tyname name uni fun a

-- | We use a <tt>newtype</tt> to enforce separation between names used for
--   types and those used for terms.
newtype TyName
TyName :: Name -> TyName
[unTyName] :: TyName -> Name

-- | A <a>Name</a> represents variables/names in Plutus Core.
data Name
Name :: Text -> Unique -> Name

-- | The identifier name, for use in error messages.
[nameString] :: Name -> Text

-- | A <a>Unique</a> assigned to the name, allowing for cheap comparisons
--   in the compiler.
[nameUnique] :: Name -> Unique

-- | A "variable declaration", i.e. a name and a type for a variable.
data VarDecl tyname name uni fun ann
VarDecl :: ann -> name -> Type tyname uni ann -> VarDecl tyname name uni fun ann
[varDeclAnn] :: VarDecl tyname name uni fun ann -> ann
[varDeclName] :: VarDecl tyname name uni fun ann -> name
[varDeclType] :: VarDecl tyname name uni fun ann -> Type tyname uni ann

-- | A "type variable declaration", i.e. a name and a kind for a type
--   variable.
data TyVarDecl tyname ann
TyVarDecl :: ann -> tyname -> Kind ann -> TyVarDecl tyname ann
[tyVarDeclAnn] :: TyVarDecl tyname ann -> ann
[tyVarDeclName] :: TyVarDecl tyname ann -> tyname
[tyVarDeclKind] :: TyVarDecl tyname ann -> Kind ann
varDeclNameString :: VarDecl tyname Name uni fun a -> String
tyVarDeclNameString :: TyVarDecl TyName a -> String


-- | A trivial simplification that cancels unwrap/wrap pairs.
--   
--   This can only occur if we've inlined both datatype constructors and
--   destructors and we're deconstructing something we just constructed.
--   This is probably rare, and should anyway better be handled by
--   something like case-of-known constructor. But it's so simple we might
--   as well include it just in case.
module PlutusIR.Transform.Unwrap

-- | Recursively apply wrap/unwrap cancellation.
unwrapCancel :: Term tyname name uni fun a -> Term tyname name uni fun a


-- | Implements a PIR-to-PIR transformation that makes all recursive term
--   definitions compilable to PLC. See Note [Thunking recursions] for
--   details.
module PlutusIR.Transform.ThunkRecursions
thunkRecursions :: Term tyname name uni fun a -> Term tyname name uni fun a


-- | Implements naive substitution functions for replacing type and term
--   variables.
module PlutusIR.Transform.Substitute

-- | Replace a variable using the given function.
substVar :: (name -> Maybe (Term tyname name uni fun a)) -> Term tyname name uni fun a -> Maybe (Term tyname name uni fun a)

-- | Replace a type variable using the given function.
substTyVar :: (tyname -> Maybe (Type tyname uni ann)) -> Type tyname uni ann -> Type tyname uni ann

-- | Naively substitute type names (i.e. do not substitute binders).
typeSubstTyNames :: (tyname -> Maybe (Type tyname uni ann)) -> Type tyname uni ann -> Type tyname uni ann

-- | Naively substitute names using the given functions (i.e. do not
--   substitute binders).
termSubstNames :: (name -> Maybe (Term tyname name uni fun a)) -> Term tyname name uni fun a -> Term tyname name uni fun a

-- | Naively substitute type names using the given functions (i.e. do not
--   substitute binders).
termSubstTyNames :: (tyname -> Maybe (Type tyname uni a)) -> Term tyname name uni fun a -> Term tyname name uni fun a

-- | Naively substitute names using the given functions (i.e. do not
--   substitute binders).
bindingSubstNames :: (name -> Maybe (Term tyname name uni fun a)) -> Binding tyname name uni fun a -> Binding tyname name uni fun a

-- | Naively substitute type names using the given functions (i.e. do not
--   substitute binders).
bindingSubstTyNames :: (tyname -> Maybe (Type tyname uni a)) -> Binding tyname name uni fun a -> Binding tyname name uni fun a


-- | Renaming of PIR terms. Import this module to bring the <tt>PLC.Rename
--   (Term tyname name uni fun ann)</tt> instance in scope.
module PlutusIR.Transform.Rename
instance PlutusCore.Core.Type.HasUniques (PlutusIR.Core.Type.Term tyname name uni fun ann) => PlutusCore.Rename.Rename (PlutusIR.Core.Type.Term tyname name uni fun ann)


-- | Compile non-strict bindings into strict bindings.
module PlutusIR.Transform.NonStrict

-- | Compile all the non-strict bindings in a term into strict bindings.
--   Note: requires globally unique names.
compileNonStrictBindings :: MonadQuote m => Term TyName Name uni fun a -> m (Term TyName Name uni fun a)


-- | A simple beta-reduction pass.
module PlutusIR.Transform.Beta

-- | Recursively apply the beta transformation on the code, both for the
--   terms
--   
--   <pre>
--   ( (x : A). M) N
--   ==&gt;
--   let x : A = N in M
--   </pre>
--   
--   and types
--   
--   <pre>
--   (/ a. (x : a) . x) {A}
--   ==&gt;
--   let a : * = A in
--   ( (x : A). x)
--   </pre>
beta :: Term tyname name uni fun a -> Term tyname name uni fun a

module PlutusIR.Purity

-- | Will evaluating this term have side effects (looping or error)?. This
--   is slightly wider than the definition of a value, as it includes
--   things that can't be returned from the machine (as they'd be
--   ill-scoped).
isPure :: ToBuiltinMeaning uni fun => (name -> Strictness) -> Term tyname name uni fun a -> Bool

module PlutusIR.MkPir

-- | A datatype definition as a type variable.
type DatatypeDef tyname name uni fun a = Def (TyVarDecl tyname a) (Datatype tyname name uni fun a)

-- | Make a let binding, unless the list of bindings is empty, in which
--   case just return the underlying term.
mkLet :: a -> Recursivity -> [Binding tyname name uni fun a] -> Term tyname name uni fun a -> Term tyname name uni fun a

module PlutusIR.Error
data Error uni fun a

-- | A generic compilation error.
CompilationError :: a -> Text -> Error uni fun a

-- | An error relating specifically to an unsupported feature.
UnsupportedError :: a -> Text -> Error uni fun a

-- | An error from running some PLC function, lifted into this error type
--   for convenience.
PLCError :: Error uni fun a -> Error uni fun a
PLCTypeError :: TypeError (Term TyName Name uni fun ()) uni fun a -> Error uni fun a
PIRTypeError :: TypeErrorExt uni a -> Error uni fun a
class AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 | r_a3mHv -> term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0
_TypeError :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (TypeError term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0)
_KindMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Type TyName uni_a3mcY (), Kind (), Kind ())
_TypeMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, term_a3mcX, Type TyName uni_a3mcY (), Normalized (Type TyName uni_a3mcY ()))
_FreeTypeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, TyName)
_FreeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Name)
_UnknownBuiltinFunctionE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, fun_a3mcZ)
data TypeError term uni fun ann
class AsTypeErrorExt r_a5DfA uni_a5D9U ann_a5D9V | r_a5DfA -> uni_a5D9U ann_a5D9V
_TypeErrorExt :: AsTypeErrorExt r_a5DfA uni_a5D9U ann_a5D9V => Prism' r_a5DfA (TypeErrorExt uni_a5D9U ann_a5D9V)
_MalformedDataConstrResType :: AsTypeErrorExt r_a5DfA uni_a5D9U ann_a5D9V => Prism' r_a5DfA (ann_a5D9V, Type TyName uni_a5D9U ann_a5D9V)
class AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT | r_a5DkE -> uni_a5DfR fun_a5DfS a_a5DfT
_Error :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (Error uni_a5DfR fun_a5DfS a_a5DfT)
_CompilationError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (a_a5DfT, Text)
_UnsupportedError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (a_a5DfT, Text)
_PLCError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (Error uni_a5DfR fun_a5DfS a_a5DfT)
_PLCTypeError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (TypeError (Term TyName Name uni_a5DfR fun_a5DfS ()) uni_a5DfR fun_a5DfS a_a5DfT)
_PIRTypeError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (TypeErrorExt uni_a5DfR a_a5DfT)
data TypeErrorExt uni ann
MalformedDataConstrResType :: ann -> Type TyName uni ann -> TypeErrorExt uni ann
newtype Normalized a
Normalized :: a -> Normalized a
[unNormalized] :: Normalized a -> a
instance (PlutusIR.Error.PrettyUni uni ann, Data.Typeable.Internal.Typeable uni, Data.Typeable.Internal.Typeable fun, Data.Typeable.Internal.Typeable ann, Prettyprinter.Internal.Pretty fun) => GHC.Exception.Type.Exception (PlutusIR.Error.Error uni fun ann)
instance PlutusIR.Error.PrettyUni uni ann => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusIR.Error.TypeErrorExt uni ann)
instance (PlutusIR.Error.PrettyUni uni ann, Prettyprinter.Internal.Pretty fun) => GHC.Show.Show (PlutusIR.Error.Error uni fun ann)
instance PlutusIR.Error.AsError (PlutusIR.Error.Error uni fun a) uni fun a
instance PlutusCore.Error.AsTypeError (PlutusIR.Error.Error uni fun a) (PlutusIR.Core.Type.Term PlutusCore.Name.TyName PlutusCore.Name.Name uni fun ()) uni fun a
instance PlutusIR.Error.AsTypeErrorExt (PlutusIR.Error.Error uni fun a) uni a
instance PlutusCore.DeBruijn.Internal.AsFreeVariableError (PlutusIR.Error.Error uni fun a)
instance ErrorCode.HasErrorCode (PlutusIR.Error.Error _a _b _c)
instance (Prettyprinter.Internal.Pretty ann, Prettyprinter.Internal.Pretty fun, Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst) => Prettyprinter.Internal.Pretty (PlutusIR.Error.Error uni fun ann)
instance (Data.GADT.Internal.GShow uni, Universe.Core.Closed uni, Universe.Core.Everywhere uni PlutusCore.Pretty.PrettyConst.PrettyConst, Prettyprinter.Internal.Pretty fun, Prettyprinter.Internal.Pretty ann) => Text.PrettyBy.Internal.PrettyBy PlutusCore.Pretty.Plc.PrettyConfigPlc (PlutusIR.Error.Error uni fun ann)
instance PlutusIR.Error.AsTypeErrorExt (PlutusIR.Error.TypeErrorExt uni ann) uni ann
instance ErrorCode.HasErrorCode (PlutusIR.Error.TypeErrorExt _a _b)
instance (Control.DeepSeq.NFData ann, Universe.Core.Closed uni) => Control.DeepSeq.NFData (PlutusIR.Error.TypeErrorExt uni ann)
instance GHC.Generics.Generic (PlutusIR.Error.TypeErrorExt uni ann)
instance (GHC.Classes.Eq ann, Data.GADT.Internal.GEq uni) => GHC.Classes.Eq (PlutusIR.Error.TypeErrorExt uni ann)
instance (GHC.Show.Show ann, Data.GADT.Internal.GShow uni) => GHC.Show.Show (PlutusIR.Error.TypeErrorExt uni ann)


-- | Support for generating PIR with global definitions with dependencies
--   between them.
module PlutusIR.Compiler.Definitions
data DefT key uni fun ann m a
class (Monad m, Ord key) => MonadDefs key uni fun ann m | m -> key uni fun ann
liftDef :: MonadDefs key uni fun ann m => DefT key uni fun ann Identity a -> m a
liftDef :: (MonadDefs key uni fun ann m, MonadDefs key uni fun ann n, MonadTrans t, t n ~ m) => DefT key uni fun ann Identity a -> m a
type TermDefWithStrictness uni fun ann = Def (VarDecl TyName Name uni fun ann) (Term TyName Name uni fun ann, Strictness)
runDefT :: (Monad m, Ord key) => ann -> DefT key uni fun ann m (Term TyName Name uni fun ann) -> m (Term TyName Name uni fun ann)
defineTerm :: MonadDefs key uni fun ann m => key -> TermDefWithStrictness uni fun ann -> Set key -> m ()
defineType :: MonadDefs key uni fun ann m => key -> TypeDef TyName uni ann -> Set key -> m ()
defineDatatype :: forall key uni fun ann m. MonadDefs key uni fun ann m => key -> DatatypeDef TyName Name uni fun ann -> Set key -> m ()
recordAlias :: forall key uni fun ann m. MonadDefs key uni fun ann m => key -> m ()
lookupTerm :: MonadDefs key uni fun ann m => ann -> key -> m (Maybe (Term TyName Name uni fun ann))
lookupOrDefineTerm :: MonadDefs key uni fun ann m => ann -> key -> m (TermDefWithStrictness uni fun ann, Set key) -> m (Term TyName Name uni fun ann)
lookupType :: MonadDefs key uni fun ann m => ann -> key -> m (Maybe (Type TyName uni ann))
lookupOrDefineType :: MonadDefs key uni fun ann m => ann -> key -> m (TypeDef TyName uni ann, Set key) -> m (Type TyName uni ann)
lookupConstructors :: MonadDefs key uni fun ann m => ann -> key -> m (Maybe [Term TyName Name uni fun ann])
lookupDestructor :: forall key uni fun ann m. MonadDefs key uni fun ann m => ann -> key -> m (Maybe (Term TyName Name uni fun ann))
instance PlutusCore.Quote.MonadQuote m => PlutusCore.Quote.MonadQuote (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)
instance Control.Monad.Morph.MFunctor (PlutusIR.Compiler.Definitions.DefT key uni fun ann)
instance Control.Monad.Trans.Class.MonadTrans (PlutusIR.Compiler.Definitions.DefT key uni fun ann)
instance GHC.Base.Monad m => GHC.Base.Monad (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)
instance GHC.Base.Monad m => GHC.Base.Applicative (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)
instance GHC.Base.Functor m => GHC.Base.Functor (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)
instance (GHC.Classes.Ord key, GHC.Base.Monad m) => PlutusIR.Compiler.Definitions.MonadDefs key uni fun ann (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)
instance PlutusIR.Compiler.Definitions.MonadDefs key uni fun ann m => PlutusIR.Compiler.Definitions.MonadDefs key uni fun ann (Control.Monad.Trans.State.Lazy.StateT s m)
instance PlutusIR.Compiler.Definitions.MonadDefs key uni fun ann m => PlutusIR.Compiler.Definitions.MonadDefs key uni fun ann (Control.Monad.Trans.Except.ExceptT e m)
instance PlutusIR.Compiler.Definitions.MonadDefs key uni fun ann m => PlutusIR.Compiler.Definitions.MonadDefs key uni fun ann (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (PlutusIR.Compiler.Definitions.DefT key uni fun ann m)

module PlutusIR.Compiler.Names
safeFreshName :: MonadQuote m => Text -> m Name
safeFreshTyName :: MonadQuote m => Text -> m TyName


-- | Kind<i>type inference</i>checking, mirroring PlutusCore.TypeCheck
module PlutusIR.TypeCheck

-- | Mapping from <a>Builtin</a>s to their <a>Type</a>s.
newtype BuiltinTypes uni fun
BuiltinTypes :: Maybe (Array fun (Dupable (Normalized (Type TyName uni ())))) -> BuiltinTypes uni fun
[unBuiltinTypes] :: BuiltinTypes uni fun -> Maybe (Array fun (Dupable (Normalized (Type TyName uni ()))))

-- | extending theh plc typecheck config with AllowEscape
data PirTCConfig uni fun
PirTCConfig :: TypeCheckConfig uni fun -> AllowEscape -> PirTCConfig uni fun
[_pirConfigTCConfig] :: PirTCConfig uni fun -> TypeCheckConfig uni fun
[_pirConfigAllowEscape] :: PirTCConfig uni fun -> AllowEscape
tccBuiltinTypes :: HasTypeCheckConfig c_a3y6w uni_a3y5j fun_a3y5k => Lens' c_a3y6w (BuiltinTypes uni_a3y5j fun_a3y5k)

-- | The default <a>TypeCheckConfig</a>.
getDefTypeCheckConfig :: forall uni fun m err ann. (MonadError err m, AsTypeError err (Term TyName Name uni fun ()) uni fun ann, Typecheckable uni fun) => ann -> m (PirTCConfig uni fun)

-- | Infer the type of a term. Note: The "inferred type" can escape its
--   scope if YesEscape config is passed, see [PIR vs Paper Escaping Types
--   Difference]
inferType :: (AsTypeError e (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, AsTypeErrorExt e uni ann, MonadError e m, MonadQuote m, GEq uni, Ix fun) => PirTCConfig uni fun -> Term TyName Name uni fun ann -> m (Normalized (Type TyName uni ()))

-- | Check a term against a type. Infers the type of the term and checks
--   that it's equal to the given type throwing a <a>TypeError</a>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
--   Note: this may allow witnessing a type that escapes its scope, see
--   [PIR vs Paper Escaping Types Difference]
checkType :: (AsTypeError e (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, AsTypeErrorExt e uni ann, MonadError e m, MonadQuote m, GEq uni, Ix fun) => PirTCConfig uni fun -> ann -> Term TyName Name uni fun ann -> Normalized (Type TyName uni ()) -> m ()

-- | Infer the type of a program. Note: The "inferred type" can escape its
--   scope if YesEscape config is passed, see [PIR vs Paper Escaping Types
--   Difference]
inferTypeOfProgram :: (AsTypeError e (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, AsTypeErrorExt e uni ann, MonadError e m, MonadQuote m, GEq uni, Ix fun) => PirTCConfig uni fun -> Program TyName Name uni fun ann -> m (Normalized (Type TyName uni ()))

-- | Check a program against a type. Infers the type of the program and
--   checks that it's equal to the given type throwing a <a>TypeError</a>
--   (annotated with the value of the <tt>ann</tt> argument) otherwise.
--   Note: this may allow witnessing a type that escapes its scope, see
--   [PIR vs Paper Escaping Types Difference]
checkTypeOfProgram :: (AsTypeError e (Term TyName Name uni fun ()) uni fun ann, ToKind uni, HasUniApply uni, AsTypeErrorExt e uni ann, MonadError e m, MonadQuote m, GEq uni, Ix fun) => PirTCConfig uni fun -> ann -> Program TyName Name uni fun ann -> Normalized (Type TyName uni ()) -> m ()

module PlutusIR.Transform.LetFloat

-- | The main transformation function (Term -&gt; Term) to "float" all lets
--   of a term under their closest-surrounding lambda/Lambda. Is comprised
--   of two AST "passes": 1stpass: to collect the ranks (future positions)
--   of all lets 2ndpass: to remove all its lets and place them back (float
--   them) to their ranks (new positions). See Note [Float algorithm]
--   
--   NB: This transformation requires that the PLC.rename compiler-pass has
--   prior been run.
floatTerm :: forall name tyname uni fun a. (HasUnique tyname TypeUnique, HasUnique name TermUnique, Semigroup a, ToBuiltinMeaning uni fun) => Term tyname name uni fun a -> Term tyname name uni fun a
instance GHC.Classes.Eq PlutusIR.Transform.LetFloat.Rank
instance GHC.Classes.Ord PlutusIR.Transform.LetFloat.Rank


-- | A simple inlining pass.
--   
--   The point of this pass is mainly to tidy up the code, not to
--   particularly optimize performance. In particular, we want to get rid
--   of "trivial" let bindings which the Plutus Tx compiler sometimes
--   creates.
module PlutusIR.Transform.Inline

-- | Inline simple bindings. Relies on global uniqueness, and preserves it.
--   See Note [Inlining and global uniqueness]
inline :: ExternalConstraints tyname name uni fun => Term tyname name uni fun a -> Term tyname name uni fun a
instance GHC.Base.Monoid (PlutusIR.Transform.Inline.TermEnv tyname name uni fun a)
instance GHC.Base.Semigroup (PlutusIR.Transform.Inline.TermEnv tyname name uni fun a)
instance GHC.Base.Monoid (PlutusIR.Transform.Inline.TypeEnv tyname uni a)
instance GHC.Base.Semigroup (PlutusIR.Transform.Inline.TypeEnv tyname uni a)
instance GHC.Base.Monoid (PlutusIR.Transform.Inline.Subst tyname name uni fun a)
instance GHC.Base.Semigroup (PlutusIR.Transform.Inline.Subst tyname name uni fun a)
instance GHC.Generics.Generic (PlutusIR.Transform.Inline.Subst tyname name uni fun a)


-- | Optimization passes for removing dead code, mainly dead let bindings.
module PlutusIR.Transform.DeadCode

-- | Remove all the dead let bindings in a term.
removeDeadBindings :: (HasUnique name TermUnique, HasUnique tyname TypeUnique, ToBuiltinMeaning uni fun) => Term tyname name uni fun a -> Term tyname name uni fun a

module PlutusIR.Compiler
compileTerm :: Compiling m e uni fun a => Term TyName Name uni fun a -> m (PLCTerm uni fun a)

-- | The 1st half of the PIR compiler pipeline up to floating/merging the
--   lets. We stop momentarily here to give a chance to the tx-plugin to
--   dump a "readable" version of pir (i.e. floated).
compileToReadable :: Compiling m e uni fun a => Term TyName Name uni fun a -> m (Term TyName Name uni fun (Provenance a))

-- | The 2nd half of the PIR compiler pipeline. Compiles a <a>Term</a> into
--   a PLC Term, by removing/translating step-by-step the PIR's language
--   construsts to PLC. Note: the result *does* have globally unique names.
compileReadableToPlc :: Compiling m e uni fun a => Term TyName Name uni fun (Provenance a) -> m (PLCTerm uni fun a)
type Compiling m e uni fun a = (Monad m, MonadReader (CompilationCtx uni fun a) m, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance a), AsTypeErrorExt e uni (Provenance a), AsError e uni fun (Provenance a), MonadError e m, MonadQuote m, Ord a, Typecheckable uni fun, GEq uni)
data Error uni fun a

-- | A generic compilation error.
CompilationError :: a -> Text -> Error uni fun a

-- | An error relating specifically to an unsupported feature.
UnsupportedError :: a -> Text -> Error uni fun a

-- | An error from running some PLC function, lifted into this error type
--   for convenience.
PLCError :: Error uni fun a -> Error uni fun a
PLCTypeError :: TypeError (Term TyName Name uni fun ()) uni fun a -> Error uni fun a
PIRTypeError :: TypeErrorExt uni a -> Error uni fun a
class AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT | r_a5DkE -> uni_a5DfR fun_a5DfS a_a5DfT
_Error :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (Error uni_a5DfR fun_a5DfS a_a5DfT)
_CompilationError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (a_a5DfT, Text)
_UnsupportedError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (a_a5DfT, Text)
_PLCError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (Error uni_a5DfR fun_a5DfS a_a5DfT)
_PLCTypeError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (TypeError (Term TyName Name uni_a5DfR fun_a5DfS ()) uni_a5DfR fun_a5DfS a_a5DfT)
_PIRTypeError :: AsError r_a5DkE uni_a5DfR fun_a5DfS a_a5DfT => Prism' r_a5DkE (TypeErrorExt uni_a5DfR a_a5DfT)
class AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 | r_a3mHv -> term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0
_TypeError :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (TypeError term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0)
_KindMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Type TyName uni_a3mcY (), Kind (), Kind ())
_TypeMismatch :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, term_a3mcX, Type TyName uni_a3mcY (), Normalized (Type TyName uni_a3mcY ()))
_FreeTypeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, TyName)
_FreeVariableE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, Name)
_UnknownBuiltinFunctionE :: AsTypeError r_a3mHv term_a3mcX uni_a3mcY fun_a3mcZ ann_a3md0 => Prism' r_a3mHv (ann_a3md0, fun_a3mcZ)
class AsTypeErrorExt r_a5DfA uni_a5D9U ann_a5D9V | r_a5DfA -> uni_a5D9U ann_a5D9V
_TypeErrorExt :: AsTypeErrorExt r_a5DfA uni_a5D9U ann_a5D9V => Prism' r_a5DfA (TypeErrorExt uni_a5D9U ann_a5D9V)
_MalformedDataConstrResType :: AsTypeErrorExt r_a5DfA uni_a5D9U ann_a5D9V => Prism' r_a5DfA (ann_a5D9V, Type TyName uni_a5D9U ann_a5D9V)

-- | Indicates where a value comes from.
--   
--   This is either an original annotation or a pieces of context
--   explaining how the term relates to a previous <a>Provenance</a>. We
--   also provide <tt>NoProvenance</tt> for convenience.
--   
--   The provenance should always be just the original annotation, if we
--   have one. It should only be another kind of provenance if we're in the
--   process of generating some term that doesn't correspond directly to a
--   term in the original AST.
data Provenance a
Original :: a -> Provenance a
LetBinding :: Recursivity -> Provenance a -> Provenance a
TermBinding :: String -> Provenance a -> Provenance a
TypeBinding :: String -> Provenance a -> Provenance a
DatatypeComponent :: DatatypeComponent -> Provenance a -> Provenance a

-- | Added for accumulating difference provenances when floating lets
MultipleSources :: Set (Provenance a) -> Provenance a
noProvenance :: Provenance a
data CompilationOpts
coOptimize :: Iso' CompilationOpts Bool
defaultCompilationOpts :: CompilationOpts
data CompilationCtx uni fun a
ccOpts :: forall uni_a5NLs fun_a5NLt a_a5NLu. Lens' (CompilationCtx uni_a5NLs fun_a5NLt a_a5NLu) CompilationOpts
ccEnclosing :: forall uni_a5NLs fun_a5NLt a_a5NLu a_a5NMO. Lens (CompilationCtx uni_a5NLs fun_a5NLt a_a5NLu) (CompilationCtx uni_a5NLs fun_a5NLt a_a5NMO) (Provenance a_a5NLu) (Provenance a_a5NMO)
ccTypeCheckConfig :: forall uni_a5NLs fun_a5NLt a_a5NLu uni_a5NMP fun_a5NMQ. Lens (CompilationCtx uni_a5NLs fun_a5NLt a_a5NLu) (CompilationCtx uni_a5NMP fun_a5NMQ a_a5NLu) (Maybe (PirTCConfig uni_a5NLs fun_a5NLt)) (Maybe (PirTCConfig uni_a5NMP fun_a5NMQ))

-- | extending theh plc typecheck config with AllowEscape
data PirTCConfig uni fun
PirTCConfig :: TypeCheckConfig uni fun -> AllowEscape -> PirTCConfig uni fun
[_pirConfigTCConfig] :: PirTCConfig uni fun -> TypeCheckConfig uni fun
[_pirConfigAllowEscape] :: PirTCConfig uni fun -> AllowEscape

-- | Extra flag to be passed in the TypeCheckM Reader context, to signal if
--   the PIR expression currently being typechecked is at the top-level and
--   thus its type can escape, or nested and thus not allowed to escape.
data AllowEscape
YesEscape :: AllowEscape
NoEscape :: AllowEscape
toDefaultCompilationCtx :: TypeCheckConfig uni fun -> CompilationCtx uni fun a

module PlutusIR.Parser
topSourcePos :: SourcePos
parse :: Parser a -> String -> Text -> Either (ParseErrorBundle Text ParseError) a
parseQuoted :: Parser a -> String -> Text -> Quote (Either (ParseErrorBundle Text ParseError) a)
term :: (Parsable (SomeTypeIn (Kinded uni)), Closed uni, uni `Everywhere` Parsable, Bounded fun, Enum fun, Pretty fun) => Parser (Term TyName Name uni fun SourcePos)
typ :: Parsable (SomeTypeIn (Kinded uni)) => Parser (Type TyName uni SourcePos)
program :: (Parsable (SomeTypeIn (Kinded uni)), Closed uni, uni `Everywhere` Parsable, Bounded fun, Enum fun, Pretty fun) => Parser (Program TyName Name uni fun SourcePos)
plcTerm :: (Parsable (SomeTypeIn (Kinded uni)), Closed uni, uni `Everywhere` Parsable, Bounded fun, Enum fun, Pretty fun) => Parser (Term TyName Name uni fun SourcePos)
plcProgram :: (Parsable (SomeTypeIn (Kinded uni)), Closed uni, uni `Everywhere` Parsable, Bounded fun, Enum fun, Pretty fun) => Parser (Program TyName Name uni fun SourcePos)
type Parser = ParsecT ParseError Text (StateT ParserState Quote)
data ParseError
UnknownBuiltinType :: Text -> ParseError
BuiltinTypeNotAStar :: Text -> ParseError
InvalidConstant :: Text -> Text -> ParseError
type Error = ParseError Char ParseError
data SourcePos

module PlutusCore.Generators.NEAT.Type
newtype Neutral a
Neutral :: a -> Neutral a
[unNeutral] :: Neutral a -> a
data TypeBuiltinG
TyByteStringG :: TypeBuiltinG
TyIntegerG :: TypeBuiltinG
TyBoolG :: TypeBuiltinG
TyUnitG :: TypeBuiltinG
TyCharG :: TypeBuiltinG
TyListG :: TypeBuiltinG
data TypeG n
TyVarG :: n -> TypeG n
TyFunG :: TypeG n -> TypeG n -> TypeG n
TyIFixG :: TypeG n -> Kind () -> TypeG n -> TypeG n
TyForallG :: Kind () -> TypeG (S n) -> TypeG n
TyBuiltinG :: TypeBuiltinG -> TypeG n
TyLamG :: TypeG (S n) -> TypeG n
TyAppG :: TypeG n -> TypeG n -> Kind () -> TypeG n
type ClosedTypeG = TypeG Z
ext :: (m -> n) -> S m -> S n
ren :: (m -> n) -> TypeG m -> TypeG n
exts :: (n -> TypeG m) -> S n -> TypeG (S m)
sub :: (n -> TypeG m) -> TypeG n -> TypeG m
instance Control.Enumerable.Enumerable n => Control.Enumerable.Enumerable (PlutusCore.Generators.NEAT.Type.TypeG n)
instance GHC.Base.Functor PlutusCore.Generators.NEAT.Type.TypeG
instance GHC.Base.Monad PlutusCore.Generators.NEAT.Type.TypeG
instance GHC.Base.Applicative PlutusCore.Generators.NEAT.Type.TypeG
instance Control.Enumerable.Enumerable ann => Control.Enumerable.Enumerable (PlutusCore.Core.Type.Kind ann)
instance GHC.Show.Show n => GHC.Show.Show (PlutusCore.Generators.NEAT.Type.TypeG n)
instance GHC.Classes.Ord n => GHC.Classes.Ord (PlutusCore.Generators.NEAT.Type.TypeG n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (PlutusCore.Generators.NEAT.Type.TypeG n)
instance GHC.Classes.Ord (PlutusCore.Core.Type.Kind ())
instance Control.Enumerable.Enumerable PlutusCore.Generators.NEAT.Type.TypeBuiltinG
instance GHC.Classes.Ord PlutusCore.Generators.NEAT.Type.TypeBuiltinG
instance GHC.Classes.Eq PlutusCore.Generators.NEAT.Type.TypeBuiltinG
instance GHC.Show.Show PlutusCore.Generators.NEAT.Type.TypeBuiltinG


-- | This file contains 1. A duplicate of the Plutus Core Abstract Syntax
--   (types and terms) 2. A kind checker and a type checker 3. Reduction
--   semantics for types
module PlutusCore.Generators.NEAT.Term
data TypeBuiltinG
TyByteStringG :: TypeBuiltinG
TyIntegerG :: TypeBuiltinG
TyBoolG :: TypeBuiltinG
TyUnitG :: TypeBuiltinG
TyCharG :: TypeBuiltinG
TyListG :: TypeBuiltinG
data TypeG n
TyVarG :: n -> TypeG n
TyFunG :: TypeG n -> TypeG n -> TypeG n
TyIFixG :: TypeG n -> Kind () -> TypeG n -> TypeG n
TyForallG :: Kind () -> TypeG (S n) -> TypeG n
TyBuiltinG :: TypeBuiltinG -> TypeG n
TyLamG :: TypeG (S n) -> TypeG n
TyAppG :: TypeG n -> TypeG n -> Kind () -> TypeG n
type ClosedTypeG = TypeG Z

-- | Convert generated closed types to Plutus types.
convertClosedType :: (MonadQuote m, MonadError GenError m) => Stream Text -> Kind () -> ClosedTypeG -> m (Type TyName DefaultUni ())
data TermG tyname name
VarG :: name -> TermG tyname name
LamAbsG :: TermG tyname (S name) -> TermG tyname name
ApplyG :: TermG tyname name -> TermG tyname name -> TypeG tyname -> TermG tyname name
TyAbsG :: TermG (S tyname) name -> TermG tyname name
TyInstG :: TermG tyname name -> TypeG (S tyname) -> TypeG tyname -> Kind () -> TermG tyname name
ConstantG :: TermConstantG -> TermG tyname name
BuiltinG :: DefaultFun -> TermG tyname name
WrapG :: TermG tyname name -> TermG tyname name
UnWrapG :: TypeG tyname -> Kind () -> TypeG tyname -> TermG tyname name -> TermG tyname name
ErrorG :: TypeG tyname -> TermG tyname name
type ClosedTermG = TermG Z Z

-- | Convert generated closed terms to Plutus terms.
convertClosedTerm :: (MonadQuote m, MonadError GenError m) => Stream Text -> Stream Text -> ClosedTypeG -> ClosedTermG -> m (Term TyName Name DefaultUni DefaultFun ())
class Check t a
check :: Check t a => t -> a -> Cool

-- | Reduce a generated type by a single step, or fail.
stepTypeG :: TypeG n -> Maybe (TypeG n)

-- | Normalise a generated type.
normalizeTypeG :: TypeG n -> TypeG n
data GenError
BadTypeG :: Kind () -> TypeG tyname -> GenError
BadTermG :: TypeG tyname -> TermG tyname name -> GenError
newtype Neutral a
Neutral :: a -> Neutral a
[unNeutral] :: Neutral a -> a
instance GHC.Show.Show PlutusCore.Generators.NEAT.Term.GenError
instance PlutusCore.Generators.NEAT.Term.Check (PlutusCore.Core.Type.Kind ()) PlutusCore.Generators.NEAT.Type.TypeBuiltinG
instance PlutusCore.Generators.NEAT.Term.Check (PlutusCore.Core.Type.Kind ()) PlutusCore.Generators.NEAT.Type.ClosedTypeG
instance PlutusCore.Generators.NEAT.Term.Check (PlutusCore.Core.Type.Kind ()) (PlutusCore.Core.Type.Normalized PlutusCore.Generators.NEAT.Type.ClosedTypeG)
instance PlutusCore.Generators.NEAT.Term.Check (PlutusCore.Generators.NEAT.Type.TypeG n) PlutusCore.Generators.NEAT.Term.TermConstantG
instance GHC.Classes.Ord tyname => PlutusCore.Generators.NEAT.Term.Check (PlutusCore.Generators.NEAT.Type.TypeG tyname) PlutusCore.Default.Builtins.DefaultFun
instance PlutusCore.Generators.NEAT.Term.Check PlutusCore.Generators.NEAT.Type.ClosedTypeG PlutusCore.Generators.NEAT.Term.ClosedTermG
instance (Control.Enumerable.Enumerable tyname, Control.Enumerable.Enumerable name) => Control.Enumerable.Enumerable (PlutusCore.Generators.NEAT.Term.TermG tyname name)
instance Data.Bifunctor.Bifunctor PlutusCore.Generators.NEAT.Term.TermG
instance (GHC.Show.Show name, GHC.Show.Show tyname) => GHC.Show.Show (PlutusCore.Generators.NEAT.Term.TermG tyname name)
instance (GHC.Classes.Eq name, GHC.Classes.Eq tyname) => GHC.Classes.Eq (PlutusCore.Generators.NEAT.Term.TermG tyname name)
instance Control.Enumerable.Enumerable PlutusCore.Default.Builtins.DefaultFun
instance Control.Enumerable.Enumerable PlutusCore.Generators.NEAT.Term.TermConstantG
instance GHC.Classes.Eq PlutusCore.Generators.NEAT.Term.TermConstantG
instance GHC.Show.Show PlutusCore.Generators.NEAT.Term.TermConstantG
instance Control.Enumerable.Enumerable tyname => Control.Enumerable.Enumerable (PlutusCore.Core.Type.Normalized (PlutusCore.Generators.NEAT.Type.TypeG tyname))
instance Control.Enumerable.Enumerable tyname => Control.Enumerable.Enumerable (PlutusCore.Generators.NEAT.Type.Neutral (PlutusCore.Generators.NEAT.Type.TypeG tyname))
instance Control.Enumerable.Enumerable Data.ByteString.Internal.ByteString

module PlutusCore.Generators.AST
simpleRecursive :: MonadGen m => [m a] -> [m a] -> m a

-- | The monad that generators run in. The environment is a list of names
--   to choose from for generation of variables and binders.
type AstGen = GenT (Reader [Name])
runAstGen :: MonadGen m => AstGen a -> m a
genVersion :: MonadGen m => m (Version ())

-- | Generate a fixed set of names which we will use, of only up to a short
--   size to make it likely that we get reuse. We do not attempt not to
--   generate reserved words such as <tt>all</tt> or <tt>abs</tt> as the
--   classic syntax parsers (both PLC and PIR ones) can handle names of
--   variables clashing with reserved words. In the readable syntax that
--   would be troubling, though, but we don't have a parser for that
--   anyway.
genNames :: MonadGen m => m [Name]
genName :: AstGen Name
genTyName :: AstGen TyName
genKind :: AstGen (Kind ())
genBuiltin :: (Bounded fun, Enum fun) => AstGen fun
genConstant :: AstGen (Some (ValueOf DefaultUni))
genType :: AstGen (Type TyName DefaultUni ())
genTerm :: AstGen (Term TyName Name DefaultUni DefaultFun ())
genProgram :: AstGen (Program TyName Name DefaultUni DefaultFun ())
mangleNames :: Term TyName Name DefaultUni DefaultFun () -> AstGen (Maybe (Term TyName Name DefaultUni DefaultFun ()))


-- | This module defines generators for PIR syntax trees for testing
--   purposes. It should only contain those generators that can't be reused
--   from PLC (PIR-exclusive constructs, Term, and Program)
module PlutusIR.Generators.AST

-- | The monad that generators run in. The environment is a list of names
--   to choose from for generation of variables and binders.
type AstGen = GenT (Reader [Name])
simpleRecursive :: MonadGen m => [m a] -> [m a] -> m a
runAstGen :: MonadGen m => AstGen a -> m a
genVersion :: MonadGen m => m (Version ())
genKind :: AstGen (Kind ())
genBuiltin :: (Bounded fun, Enum fun) => AstGen fun
genConstant :: AstGen (Some (ValueOf DefaultUni))
genProgram :: AstGen (Program TyName Name DefaultUni DefaultFun ())
genTerm :: AstGen (Term TyName Name DefaultUni DefaultFun ())
genBinding :: AstGen (Binding TyName Name DefaultUni DefaultFun ())
genDatatype :: AstGen (Datatype TyName Name DefaultUni DefaultFun ())
genTyVarDecl :: AstGen (TyVarDecl TyName ())
genVarDecl :: AstGen (VarDecl TyName Name DefaultUni DefaultFun ())
genRecursivity :: MonadGen m => m Recursivity

module PlutusCore.Examples.Builtins
size :: forall a. (Bounded a, Enum a) => Int
data ExtensionFun
Factorial :: ExtensionFun
Const :: ExtensionFun
Id :: ExtensionFun
IdFInteger :: ExtensionFun
IdList :: ExtensionFun
IdRank2 :: ExtensionFun
FailingSucc :: ExtensionFun
ExpensiveSucc :: ExtensionFun
FailingPlus :: ExtensionFun
ExpensivePlus :: ExtensionFun
Absurd :: ExtensionFun
Cons :: ExtensionFun
Null :: ExtensionFun
Head :: ExtensionFun
Tail :: ExtensionFun
Fst :: ExtensionFun
Snd :: ExtensionFun
Swap :: ExtensionFun
SwapEls :: ExtensionFun
defBuiltinsRuntimeExt :: HasConstantIn DefaultUni term => BuiltinsRuntime (Either DefaultFun ExtensionFun) term
data PlcListRep (a :: Type)
data BuiltinErrorCall
BuiltinErrorCall :: BuiltinErrorCall
instance PlutusCore.Evaluation.Machine.ExMemory.ExMemoryUsage PlutusCore.Examples.Builtins.ExtensionFun
instance Data.Hashable.Class.Hashable PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Generics.Generic PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Ix.Ix PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Enum.Bounded PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Enum.Enum PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Classes.Ord PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Classes.Eq PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Show.Show PlutusCore.Examples.Builtins.ExtensionFun
instance GHC.Exception.Type.Exception PlutusCore.Examples.Builtins.BuiltinErrorCall
instance GHC.Classes.Eq PlutusCore.Examples.Builtins.BuiltinErrorCall
instance GHC.Show.Show PlutusCore.Examples.Builtins.BuiltinErrorCall
instance (uni GHC.Types.~ PlutusCore.Default.Universe.DefaultUni) => PlutusCore.Constant.Meaning.ToBuiltinMeaning uni PlutusCore.Examples.Builtins.ExtensionFun
instance PlutusCore.Constant.Typed.KnownTypeAst uni a => PlutusCore.Constant.Typed.KnownTypeAst uni (PlutusCore.Examples.Builtins.PlcListRep a)
instance Prettyprinter.Internal.Pretty PlutusCore.Examples.Builtins.ExtensionFun
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (Data.Either.Either a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Enum a, GHC.Enum.Enum b) => GHC.Enum.Enum (Data.Either.Either a b)
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Ix.Ix a, GHC.Ix.Ix b) => GHC.Ix.Ix (Data.Either.Either a b)
instance (PlutusCore.Constant.Meaning.ToBuiltinMeaning uni fun1, PlutusCore.Constant.Meaning.ToBuiltinMeaning uni fun2) => PlutusCore.Constant.Meaning.ToBuiltinMeaning uni (Data.Either.Either fun1 fun2)
instance PlutusCore.Constant.Typed.KnownTypeAst uni Data.Void.Void
instance PlutusCore.Constant.Typed.KnownType term Data.Void.Void


-- | This module exports all available examples via a data type which
--   allows to test various procedures (pretty-printing, type checking,
--   etc) over the entire set of examples in a convenient way: each time a
--   function / data type is added to examples, none of the tests is
--   required to be adapted, instead you just add the new definition to
--   <a>examples</a> defined below and all the tests see it automatically.
module PlutusCore.Examples.Everything

-- | All examples exported as a single value.
examples :: PlcFolderContents DefaultUni DefaultFun
builtins :: PlcFolderContents DefaultUni ExtensionFun

module UntypedPlutusCore
simplifyTerm :: Term name uni fun a -> Term name uni fun a
simplifyProgram :: Program name uni fun a -> Program name uni fun a

-- | Applicatively replace a variable using the given function.
substVarA :: Applicative f => (name -> f (Maybe (Term name uni fun ann))) -> Term name uni fun ann -> f (Term name uni fun ann)

-- | Replace a variable using the given function.
substVar :: (name -> Maybe (Term name uni fun ann)) -> Term name uni fun ann -> Term name uni fun ann

-- | Naively monadically substitute names using the given function (i.e. do
--   not substitute binders).
termSubstNamesM :: Monad m => (name -> m (Maybe (Term name uni fun ann))) -> Term name uni fun ann -> m (Term name uni fun ann)

-- | Naively substitute names using the given function (i.e. do not
--   substitute binders).
termSubstNames :: (name -> Maybe (Term name uni fun ann)) -> Term name uni fun ann -> Term name uni fun ann

-- | Applicatively substitute *free* names using the given function.
termSubstFreeNamesA :: (Applicative f, HasUnique name TermUnique) => (name -> f (Maybe (Term name uni fun ann))) -> Term name uni fun ann -> f (Term name uni fun ann)

-- | Substitute *free* names using the given function.
termSubstFreeNames :: HasUnique name TermUnique => (name -> Maybe (Term name uni fun ann)) -> Term name uni fun ann -> Term name uni fun ann

-- | Completely replace the names with a new name type.
termMapNames :: forall name name' uni fun ann. (name -> name') -> Term name uni fun ann -> Term name' uni fun ann
programMapNames :: forall name name' uni fun ann. (name -> name') -> Program name uni fun ann -> Program name' uni fun ann

-- | Get all the uniques in a term
uniquesTerm :: HasUniques (Term name uni fun ann) => Term name uni fun ann -> Set Unique

-- | Get all the term variables in a term.
vTerm :: Ord name => Term name uni fun ann -> Set name

-- | Count the number of AST nodes in a term.
termSize :: Term name uni fun ann -> Integer

-- | Count the number of AST nodes in a program.
programSize :: Program name uni fun ann -> Integer

-- | Compute the size of the serializabled form of a value.
serialisedSize :: Serialise a => a -> Integer

-- | Using 4 bits to encode term tags.
termTagWidth :: NumBits
encodeTerm :: Word8 -> Encoding
decodeTerm :: Get Word8
newtype OmitUnitAnnotations name uni fun
OmitUnitAnnotations :: Program name uni fun () -> OmitUnitAnnotations name uni fun
[restoreUnitAnnotations] :: OmitUnitAnnotations name uni fun -> Program name uni fun ()

-- | Convenience functions for serialisation/deserialisation without units
serialiseOmittingUnits :: (Closed uni, Serialise name, uni `Everywhere` Serialise, Serialise fun) => Program name uni fun () -> ByteString
deserialiseRestoringUnits :: (Closed uni, Serialise name, uni `Everywhere` Serialise, Serialise fun) => ByteString -> Program name uni fun ()
deserialiseRestoringUnitsOrFail :: (Closed uni, Serialise name, uni `Everywhere` Serialise, Serialise fun) => ByteString -> Either DeserialiseFailure (Program name uni fun ())

-- | Extract the universe from a type.
type family UniOf a :: Type -> Type

-- | Version of Plutus Core to be used for the program.
data Version ann
Version :: ann -> Natural -> Natural -> Natural -> Version ann

-- | The type of Untyped Plutus Core terms. Mirrors the type of Typed
--   Plutus Core terms except
--   
--   <ol>
--   <li>all types are removed</li>
--   <li><tt>IWrap</tt> and <tt>Unwrap</tt> are removed</li>
--   <li>type abstractions are replaced with <a>Delay</a></li>
--   <li>type instantiations are replaced with <a>Force</a></li>
--   </ol>
--   
--   The latter two are due to the fact that we don't have value
--   restriction in Typed Plutus Core and hence a computation can be stuck
--   expecting only a single type argument for the computation to become
--   unstuck. Therefore we can't just silently remove type abstractions and
--   instantions and need to replace them with something else that also
--   blocks evaluation (in order for the semantics of an erased program to
--   match with the semantics of the original typed one). <a>Delay</a> and
--   <a>Force</a> serve exactly this purpose.
data Term name uni fun ann
Constant :: !ann -> !Some (ValueOf uni) -> Term name uni fun ann
Builtin :: !ann -> !fun -> Term name uni fun ann
Var :: !ann -> !name -> Term name uni fun ann
LamAbs :: !ann -> !name -> !Term name uni fun ann -> Term name uni fun ann
Apply :: !ann -> !Term name uni fun ann -> !Term name uni fun ann -> Term name uni fun ann
Delay :: !ann -> !Term name uni fun ann -> Term name uni fun ann
Force :: !ann -> !Term name uni fun ann -> Term name uni fun ann
Error :: !ann -> Term name uni fun ann

-- | A <a>Program</a> is simply a <a>Term</a> coupled with a
--   <tt>Version</tt> of the core language.
data Program name uni fun ann
Program :: ann -> Version ann -> Term name uni fun ann -> Program name uni fun ann
toTerm :: Program name uni fun ann -> Term name uni fun ann
bindFunM :: Monad m => (ann -> fun -> m (Term name uni fun' ann)) -> Term name uni fun ann -> m (Term name uni fun' ann)
bindFun :: (ann -> fun -> Term name uni fun' ann) -> Term name uni fun ann -> Term name uni fun' ann
mapFun :: (ann -> fun -> fun') -> Term name uni fun ann -> Term name uni fun' ann

-- | Return the outermost annotation of a <a>Term</a>.
termAnn :: Term name uni fun ann -> ann

-- | Erase a Typed Plutus Core term to its untyped counterpart.
erase :: Term tyname name uni fun ann -> Term name uni fun ann

-- | Erase a Typed Plutus Core Program to its untyped counterpart.
eraseProgram :: Program tyname name uni fun ann -> Program name uni fun ann

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>LamAbs</a>es.
termBinds :: Traversal' (Term name uni fun ann) name

-- | Get all the direct child 'name a's of the given <a>Term</a> from
--   <a>Var</a>s.
termVars :: Traversal' (Term name uni fun ann) name

-- | Get all the direct child <a>Unique</a>s of the given <a>Term</a>.
termUniques :: HasUniques (Term name uni fun ann) => Traversal' (Term name uni fun ann) Unique

-- | Get all the direct child <a>Term</a>s of the given <a>Term</a>.
termSubterms :: Traversal' (Term name uni fun ann) (Term name uni fun ann)

-- | Get all the transitive child <a>Term</a>s of the given <a>Term</a>.
termSubtermsDeep :: Fold (Term name uni fun ann) (Term name uni fun ann)

-- | Get all the transitive child <a>Unique</a>s of the given <a>Term</a>.
termUniquesDeep :: HasUniques (Term name uni fun ann) => Fold (Term name uni fun ann) Unique
data TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
ConstantF :: !ann_a4FPH -> !Some (ValueOf uni_a4FPF) -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
BuiltinF :: !ann_a4FPH -> !fun_a4FPG -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
VarF :: !ann_a4FPH -> !name_a4FPE -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
LamAbsF :: !ann_a4FPH -> !name_a4FPE -> !r_a4Kix -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
ApplyF :: !ann_a4FPH -> !r_a4Kix -> !r_a4Kix -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
DelayF :: !ann_a4FPH -> !r_a4Kix -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
ForceF :: !ann_a4FPH -> !r_a4Kix -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix
ErrorF :: !ann_a4FPH -> TermF (name_a4FPE :: Type) (uni_a4FPF :: Type -> Type) (fun_a4FPG :: Type) (ann_a4FPH :: Type) r_a4Kix

-- | Check equality of two <a>Term</a>s.
eqTermM :: (GEq uni, Closed uni, uni `Everywhere` Eq, Eq fun, HasUnique name TermUnique) => Term name uni fun ann -> Term name uni fun ann -> EqRename (Renaming TermUnique)

-- | Take one PLC program and apply it to another.
applyProgram :: Program name uni fun () -> Program name uni fun () -> Program name uni fun ()

-- | Parse and rewrite so that names are globally unique, not just unique
--   within their scope.
parseScoped :: (AsParseError e AlexPosn, AsUniqueError e AlexPosn, MonadError e m, MonadQuote m) => ByteString -> m (Program Name DefaultUni DefaultFun AlexPosn)


-- | This file contains the tests and some associated machinery but not the
--   generators.
module PlutusCore.Generators.NEAT.Spec
tests :: GenOptions -> TestTree
data GenOptions
GenOptions :: Int -> Options -> GenOptions

-- | Search depth, measured in program size
[genDepth] :: GenOptions -> Int

-- | Search strategy
[genMode] :: GenOptions -> Options
defaultGenOptions :: GenOptions
data Options
D :: Options
O :: Options
F :: Options
OF :: Options
OS :: Options
OSF :: Options
data TestFail
GenError :: GenError -> TestFail
TypeError :: TypeError (Term TyName Name DefaultUni DefaultFun ()) DefaultUni DefaultFun () -> TestFail
AgdaErrorP :: () -> TestFail
FVErrorP :: FreeVariableError -> TestFail
CkP :: CkEvaluationException DefaultUni DefaultFun -> TestFail
UCekP :: CekEvaluationException DefaultUni DefaultFun -> TestFail
Ctrex :: Ctrex -> TestFail

-- | Create a generator test, searching for a counter-example to the given
--   predicate.
testCaseGen :: (Check t a, Enumerable a, Show e) => TestName -> GenOptions -> t -> (t -> a -> ExceptT e Quote ()) -> TestTree

-- | generate examples using <tt>search</tt>` and then generate one big
--   test that applies the given test to each of them.
bigTest :: (Check t a, Enumerable a) => String -> GenOptions -> t -> (t -> a -> Assertion) -> TestTree
bigTestTermG_NO_LIST :: String -> GenOptions -> ClosedTypeG -> (ClosedTypeG -> ClosedTermG -> Assertion) -> TestTree
bigTestTypeG_NO_LIST :: String -> GenOptions -> Kind () -> (Kind () -> ClosedTypeG -> Assertion) -> TestTree

-- | given a prop, generate one test
packAssertion :: Show e => (t -> a -> ExceptT e Quote ()) -> t -> a -> Assertion

-- | Stream of type names t0, t1, t2, ..
tynames :: Stream Text

-- | Stream of names x0, x1, x2, ..
names :: Stream Text

-- | Throw a counter-example.
throwCtrex :: Ctrex -> ExceptT TestFail Quote ()
data Ctrex
CtrexNormalizeConvertCommuteTypes :: Kind () -> ClosedTypeG -> Type TyName DefaultUni () -> Type TyName DefaultUni () -> Ctrex
CtrexNormalTypesCannotReduce :: Kind () -> ClosedTypeG -> Ctrex
CtrexKindCheckFail :: Kind () -> ClosedTypeG -> Ctrex
CtrexKindPreservationFail :: Kind () -> ClosedTypeG -> Ctrex
CtrexKindMismatch :: Kind () -> ClosedTypeG -> Kind () -> Kind () -> Ctrex
CtrexTypeNormalizationFail :: Kind () -> ClosedTypeG -> Ctrex
CtrexTypeNormalizationMismatch :: Kind () -> ClosedTypeG -> Type TyName DefaultUni () -> Type TyName DefaultUni () -> Ctrex
CtrexTypeCheckFail :: ClosedTypeG -> ClosedTermG -> Ctrex
CtrexTypePreservationFail :: ClosedTypeG -> ClosedTermG -> Term TyName Name DefaultUni DefaultFun () -> Term TyName Name DefaultUni DefaultFun () -> Ctrex
CtrexTermEvaluationFail :: ClosedTypeG -> ClosedTermG -> Ctrex
CtrexTermEvaluationMismatch :: ClosedTypeG -> ClosedTermG -> [Term TyName Name DefaultUni DefaultFun ()] -> Ctrex
CtrexUntypedTermEvaluationMismatch :: ClosedTypeG -> ClosedTermG -> [Term Name DefaultUni DefaultFun ()] -> Ctrex
handleError :: Type TyName DefaultUni () -> ErrorWithCause (EvaluationError user internal) term -> Either (ErrorWithCause (EvaluationError user internal) term) (Term TyName Name DefaultUni DefaultFun ())
instance GHC.Show.Show PlutusCore.Generators.NEAT.Spec.TestFail
instance GHC.Show.Show PlutusCore.Generators.NEAT.Spec.Ctrex

module PlcTestUtils

-- | Class for ad-hoc overloading of things which can be turned into a PLC
--   program. Any errors from the process should be caught.
class ToTPlc a uni fun | a -> uni fun
toTPlc :: ToTPlc a uni fun => a -> ExceptT SomeException IO (Program TyName Name uni fun ())
class ToUPlc a uni fun | a -> uni fun
toUPlc :: ToUPlc a uni fun => a -> ExceptT SomeException IO (Program Name uni fun ())
pureTry :: Exception e => a -> Either e a
catchAll :: a -> ExceptT SomeException IO a
rethrow :: ExceptT SomeException IO a -> IO a
runTPlc :: ToTPlc a DefaultUni DefaultFun => [a] -> ExceptT SomeException IO (EvaluationResult (Term TyName Name DefaultUni DefaultFun ()))
runUPlc :: ToUPlc a DefaultUni DefaultFun => [a] -> ExceptT SomeException IO (EvaluationResult (Term Name DefaultUni DefaultFun ()))
goldenTPlc :: ToTPlc a DefaultUni DefaultFun => String -> a -> TestNested
goldenTPlcCatch :: ToTPlc a DefaultUni DefaultFun => String -> a -> TestNested
goldenUPlc :: ToUPlc a DefaultUni DefaultFun => String -> a -> TestNested
goldenUPlcCatch :: ToUPlc a DefaultUni DefaultFun => String -> a -> TestNested
goldenTEval :: ToTPlc a DefaultUni DefaultFun => String -> [a] -> TestNested
goldenUEval :: ToUPlc a DefaultUni DefaultFun => String -> [a] -> TestNested
goldenTEvalCatch :: ToTPlc a DefaultUni DefaultFun => String -> [a] -> TestNested
goldenUEvalCatch :: ToUPlc a DefaultUni DefaultFun => String -> [a] -> TestNested
instance PlcTestUtils.ToUPlc a uni fun => PlcTestUtils.ToUPlc (Control.Monad.Trans.Except.ExceptT GHC.Exception.Type.SomeException GHC.Types.IO a) uni fun
instance PlcTestUtils.ToUPlc (UntypedPlutusCore.Core.Type.Program PlutusCore.Name.Name uni fun ()) uni fun
instance PlcTestUtils.ToUPlc (UntypedPlutusCore.Core.Type.Program PlutusCore.DeBruijn.Internal.NamedDeBruijn uni fun ()) uni fun
instance PlcTestUtils.ToTPlc a uni fun => PlcTestUtils.ToTPlc (Control.Monad.Trans.Except.ExceptT GHC.Exception.Type.SomeException GHC.Types.IO a) uni fun
instance PlcTestUtils.ToTPlc (PlutusCore.Core.Type.Program PlutusCore.Name.TyName PlutusCore.Name.Name uni fun ()) uni fun
