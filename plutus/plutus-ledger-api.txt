-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interface to the Plutus ledger for the Cardano ledger.
--   
--   Interface to the Plutus scripting support for the Cardano ledger.
@package plutus-ledger-api
@version 0.1.0.0


-- | Encoding and decoding of <tt>ByteString</tt> and serialisable values
--   as base16 encoded JSON strings
module Data.Aeson.Extras
encodeByteString :: ByteString -> Text
decodeByteString :: Value -> Parser ByteString
encodeSerialise :: Serialise a => a -> Text
decodeSerialise :: Serialise a => Value -> Parser a
tryDecode :: Text -> Either String ByteString

module Data.Either.Extras
unsafeFromEither :: Either String a -> a

module Data.Text.Prettyprint.Doc.Extras

-- | Newtype wrapper for deriving <a>Pretty</a> via a <a>Show</a> instance
newtype PrettyShow a
PrettyShow :: a -> PrettyShow a
[unPrettyShow] :: PrettyShow a -> a
class Pretty a
pretty :: Pretty a => a -> Doc ann
prettyList :: Pretty a => [a] -> Doc ann

-- | Newtype wrapper for deriving <a>Pretty</a> for a <a>Foldable</a>
--   container by calling <a>toList</a>.
newtype PrettyFoldable f a
PrettyFoldable :: f a -> PrettyFoldable f a
[unPrettyFoldable] :: PrettyFoldable f a -> f a
newtype Tagged (s :: k) b
Tagged :: b -> Tagged (s :: k) b
instance (Data.Foldable.Foldable f, Prettyprinter.Internal.Pretty a) => Prettyprinter.Internal.Pretty (Data.Text.Prettyprint.Doc.Extras.PrettyFoldable f a)
instance GHC.Show.Show a => Prettyprinter.Internal.Pretty (Data.Text.Prettyprint.Doc.Extras.PrettyShow a)
instance (GHC.TypeLits.KnownSymbol a, Prettyprinter.Internal.Pretty b) => Prettyprinter.Internal.Pretty (Data.Tagged.Tagged a b)

module Plutus.V1.Ledger.Bytes

-- | 'Bultins.SizedByteString 32' with various useful JSON and servant
--   instances for the Playground, and a convenient bridge type for
--   PureScript.
newtype LedgerBytes
LedgerBytes :: ByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> ByteString
fromHex :: ByteString -> Either String LedgerBytes
bytes :: LedgerBytes -> ByteString
fromBytes :: ByteString -> LedgerBytes
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Bytes.LedgerBytes
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Bytes.LedgerBytes
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Bytes.LedgerBytes
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Bytes.LedgerBytes
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Generics.Generic Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Classes.Ord Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Classes.Eq Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.String.IsString Plutus.V1.Ledger.Bytes.LedgerBytes
instance GHC.Show.Show Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Bytes.LedgerBytes
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Bytes.LedgerBytes


-- | A type for intervals and associated functions.
module Plutus.V1.Ledger.Interval

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | Check whether a value is in an interval.
member :: Ord a => a -> Interval a -> Bool

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than <tt>b</tt>. Therefore it includes
--   <tt>a</tt> but not it does not include <tt>b</tt>.
interval :: a -> a -> Interval a

-- | <tt>from a</tt> is an <a>Interval</a> that includes all values that
--   are greater than or equal to <tt>a</tt>.
from :: a -> Interval a

-- | <tt>to a</tt> is an <a>Interval</a> that includes all values that are
--   smaller than <tt>a</tt>.
to :: a -> Interval a

-- | An <a>Interval</a> that covers every slot.
always :: Interval a

-- | An <a>Interval</a> that is empty.
never :: Interval a
singleton :: a -> Interval a

-- | 'hull a b' is the smallest interval containing <tt>a</tt> and
--   <tt>b</tt>.
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | 'intersection a b' is the largest interval that is contained in
--   <tt>a</tt> and in <tt>b</tt>, if it exists.
intersection :: Ord a => Interval a -> Interval a -> Interval a

-- | Check whether two intervals overlap, that is, whether there is a value
--   that is a member of both intervals.
overlaps :: Ord a => Interval a -> Interval a -> Bool

-- | <tt>a <a>contains</a> b</tt> is true if the <a>Interval</a> <tt>b</tt>
--   is entirely contained in <tt>a</tt>. That is, <tt>a <a>contains</a>
--   b</tt> if for every entry <tt>s</tt>, if <tt>member s b</tt> then
--   <tt>member s a</tt>.
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Check if an <a>Interval</a> is empty.
isEmpty :: Ord a => Interval a -> Bool

-- | Check if a value is earlier than the beginning of an <a>Interval</a>.
before :: Ord a => a -> Interval a -> Bool

-- | Check if a value is later than the end of a <a>Interval</a>.
after :: Ord a => a -> Interval a -> Bool
strictLowerBound :: a -> LowerBound a
strictUpperBound :: a -> UpperBound a
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.Interval
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.LowerBound a), PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.UpperBound a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.JoinSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.BoundedJoinSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.MeetSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Ord.Ord a => PlutusTx.Lattice.BoundedMeetSemiLattice (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.UpperBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.LowerBound
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Extended a)) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Interval.Extended
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (Plutus.V1.Ledger.Interval.Extended a)
instance PlutusTx.IsData.Class.IsData a => PlutusTx.IsData.Class.IsData (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.IsData.Class.IsData a => PlutusTx.IsData.Class.IsData (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.IsData.Class.IsData a => PlutusTx.IsData.Class.IsData (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.IsData.Class.IsData a => PlutusTx.IsData.Class.IsData (Plutus.V1.Ledger.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.Extended a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.Extended a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.Extended a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.Extended a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.Extended a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.Extended a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.UpperBound a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.UpperBound a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.UpperBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.UpperBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.LowerBound a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.LowerBound a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.LowerBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.LowerBound a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Plutus.V1.Ledger.Interval.Interval a)
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.V1.Ledger.Interval.Interval a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Generics.Generic (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.V1.Ledger.Interval.Interval a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.V1.Ledger.Interval.Interval a)
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.Interval
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.LowerBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.LowerBound a)
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.UpperBound
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.UpperBound a)
instance PlutusTx.Functor.Functor Plutus.V1.Ledger.Interval.Extended
instance Prettyprinter.Internal.Pretty a => Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.Extended a)

module Plutus.V1.Ledger.Orphans
instance Codec.Serialise.Class.Serialise (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.ToJSON.ToJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.FromJSON.FromJSON (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Internal.ByteString
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Internal.ByteString


-- | Functions for working with scripts on the ledger.
module Plutus.V1.Ledger.Scripts

-- | A script on the chain. This is an opaque type as far as the chain is
--   concerned.
newtype Script
Script :: Program DeBruijn DefaultUni DefaultFun () -> Script
[unScript] :: Script -> Program DeBruijn DefaultUni DefaultFun ()

-- | The size of a <a>Script</a>. No particular interpretation is given to
--   this, other than that it is proportional to the serialized size of the
--   script.
scriptSize :: Script -> Integer

-- | Turn a <a>CompiledCode</a> (usually produced by <tt>compile</tt>) into
--   a <a>Script</a> for use with this package.
fromCompiledCode :: CompiledCode a -> Script
data ScriptError

-- | Expected behavior of the engine (e.g. user-provided error)
EvaluationError :: [String] -> ScriptError

-- | Unexpected behavior of the engine (a bug)
EvaluationException :: String -> ScriptError

-- | Script is wrong in some way
MalformedScript :: String -> ScriptError

-- | Evaluate a script, returning the trace log.
evaluateScript :: forall m. MonadError ScriptError m => Script -> m [String]

-- | Evaluate a validator script with the given arguments, returning the
--   log.
runScript :: MonadError ScriptError m => Context -> Validator -> Datum -> Redeemer -> m [String]

-- | Evaluate a monetary policy script with just the validation context,
--   returning the log.
runMonetaryPolicyScript :: MonadError ScriptError m => Context -> MonetaryPolicy -> m [String]

-- | Apply a validator script to its arguments
applyValidator :: Context -> Validator -> Datum -> Redeemer -> Script

-- | Apply a validation <a>Context</a> to the <a>MonetaryPolicy</a>
applyMonetaryPolicyScript :: Context -> MonetaryPolicy -> Script
mkValidatorScript :: CompiledCode (Data -> Data -> Data -> ()) -> Validator

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
newtype Validator
Validator :: Script -> Validator
[getValidator] :: Validator -> Script
unValidatorScript :: Validator -> Script

-- | <a>Redeemer</a> is a wrapper around <a>Data</a> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: Data -> Redeemer
[getRedeemer] :: Redeemer -> Data

-- | <a>Datum</a> is a wrapper around <a>Data</a> values which are used as
--   data in transaction outputs.
newtype Datum
Datum :: Data -> Datum
[getDatum] :: Datum -> Data
mkMonetaryPolicyScript :: CompiledCode (Data -> ()) -> MonetaryPolicy

-- | <a>MonetaryPolicy</a> is a wrapper around <a>Script</a>s which are
--   used as validators for forging constraints.
newtype MonetaryPolicy
MonetaryPolicy :: Script -> MonetaryPolicy
[getMonetaryPolicy] :: MonetaryPolicy -> Script
unMonetaryPolicyScript :: MonetaryPolicy -> Script

-- | Information about the state of the blockchain and about the
--   transaction that is currently being validated, represented as a value
--   in <a>Data</a>.
newtype Context
Context :: Data -> Context

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: ByteString -> DatumHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype RedeemerHash
RedeemerHash :: ByteString -> RedeemerHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ValidatorHash
ValidatorHash :: ByteString -> ValidatorHash

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype MonetaryPolicyHash
MonetaryPolicyHash :: ByteString -> MonetaryPolicyHash
datumHash :: Datum -> DatumHash
redeemerHash :: Redeemer -> RedeemerHash
validatorHash :: Validator -> ValidatorHash
monetaryPolicyHash :: MonetaryPolicy -> MonetaryPolicyHash

-- | <tt>()</tt> as a redeemer.
unitRedeemer :: Redeemer

-- | <tt>()</tt> as a datum.
unitDatum :: Datum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Script
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ScriptError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ScriptError
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.ScriptError
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.ScriptError
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.ScriptError
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.ScriptError
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.Validator
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Validator
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Validator
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Validator
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Validator
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.Validator
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.Validator
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Validator
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Validator
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Validator
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.Datum
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Datum
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Datum
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Scripts.Datum
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.Datum
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.Datum
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Datum
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Datum
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Datum
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Datum
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Redeemer
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Redeemer
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Redeemer
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.Redeemer
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Redeemer
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Redeemer
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.ValidatorHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.ValidatorHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.ValidatorHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.ValidatorHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.ValidatorHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.DatumHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.DatumHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.DatumHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.DatumHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.DatumHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.DatumHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.DatumHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.RedeemerHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.RedeemerHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.RedeemerHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.RedeemerHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.RedeemerHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Data.String.IsString Plutus.V1.Ledger.Scripts.MonetaryPolicyHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Context
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Context
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Context
instance GHC.Generics.Generic Plutus.V1.Ledger.Scripts.Context
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance Data.ByteArray.Types.ByteArrayAccess Plutus.V1.Ledger.Scripts.MonetaryPolicy
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Scripts.Redeemer
instance Data.ByteArray.Types.ByteArrayAccess Plutus.V1.Ledger.Scripts.Redeemer
instance Data.ByteArray.Types.ByteArrayAccess Plutus.V1.Ledger.Scripts.Datum
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Validator
instance Data.ByteArray.Types.ByteArrayAccess Plutus.V1.Ledger.Scripts.Validator
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Scripts.Script
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Scripts.Script
instance GHC.Classes.Eq Plutus.V1.Ledger.Scripts.Script
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Scripts.Script
instance GHC.Classes.Ord Plutus.V1.Ledger.Scripts.Script
instance GHC.Show.Show Plutus.V1.Ledger.Scripts.Script
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Scripts.Script
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Scripts.Script
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Scripts.Script
instance Data.Aeson.Types.ToJSON.ToJSON PlutusTx.Data.Data
instance Data.Aeson.Types.FromJSON.FromJSON PlutusTx.Data.Data


-- | Slots and slot ranges.
module Plutus.V1.Ledger.Slot

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
newtype Slot
Slot :: Integer -> Slot
[getSlot] :: Slot -> Integer

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | Number of <a>Slot</a>s covered by the interval, if finite. <tt>width
--   (from x) == Nothing</tt>.
width :: SlotRange -> Maybe Integer
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Slot.Slot
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Slot.Slot
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Slot.Slot
instance Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.Interval Plutus.V1.Ledger.Slot.Slot)
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Slot.Slot
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Slot.Slot
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Slot.Slot
instance GHC.Real.Integral Plutus.V1.Ledger.Slot.Slot
instance GHC.Real.Real Plutus.V1.Ledger.Slot.Slot
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Slot.Slot
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Slot.Slot
instance GHC.Enum.Enum Plutus.V1.Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveGroup Plutus.V1.Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveMonoid Plutus.V1.Ledger.Slot.Slot
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.V1.Ledger.Slot.Slot
instance GHC.Num.Num Plutus.V1.Ledger.Slot.Slot
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Slot.Slot
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Slot.Slot
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Slot.Slot
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Slot.Slot
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Slot.Slot
instance GHC.Generics.Generic Plutus.V1.Ledger.Slot.Slot
instance GHC.Show.Show Plutus.V1.Ledger.Slot.Slot
instance GHC.Classes.Ord Plutus.V1.Ledger.Slot.Slot
instance GHC.Classes.Eq Plutus.V1.Ledger.Slot.Slot


-- | UTCTime and UTCTime ranges.
module Plutus.V1.Ledger.Time

-- | POSIX time is measured as the number of seconds since 1970-01-01 00:00
--   UTC
newtype POSIXTime
POSIXTime :: Integer -> POSIXTime
[getPOSIXTime] :: POSIXTime -> Integer

-- | An <a>Interval</a> of <a>POSIXTime</a>s.
type POSIXTimeRange = Interval POSIXTime
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Time.POSIXTime
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Time.POSIXTime
instance Prettyprinter.Internal.Pretty (Plutus.V1.Ledger.Interval.Interval Plutus.V1.Ledger.Time.POSIXTime)
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Time.POSIXTime
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Time.POSIXTime
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Real.Integral Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Real.Real Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Enum.Enum Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveGroup Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveMonoid Plutus.V1.Ledger.Time.POSIXTime
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Num.Num Plutus.V1.Ledger.Time.POSIXTime
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Time.POSIXTime
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Generics.Generic Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Show.Show Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Classes.Ord Plutus.V1.Ledger.Time.POSIXTime
instance GHC.Classes.Eq Plutus.V1.Ledger.Time.POSIXTime


-- | The type of transaction IDs
module Plutus.V1.Ledger.TxId

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: ByteString -> TxId
[getTxId] :: TxId -> ByteString
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.TxId.TxId
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.TxId.TxId
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.TxId.TxId
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.TxId.TxId
instance GHC.Show.Show Plutus.V1.Ledger.TxId.TxId
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.TxId.TxId
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.TxId.TxId
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.TxId.TxId
instance Control.DeepSeq.NFData Plutus.V1.Ledger.TxId.TxId
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.TxId.TxId
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.TxId.TxId
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.TxId.TxId
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.TxId.TxId
instance GHC.Generics.Generic Plutus.V1.Ledger.TxId.TxId
instance GHC.Classes.Ord Plutus.V1.Ledger.TxId.TxId
instance GHC.Classes.Eq Plutus.V1.Ledger.TxId.TxId

module Plutus.V1.Ledger.Crypto

-- | A cryptographic public key.
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself.
newtype PubKeyHash
PubKeyHash :: ByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> ByteString

-- | Compute the hash of a public key.
pubKeyHash :: PubKey -> PubKeyHash

-- | A cryptographic private key.
newtype PrivateKey
PrivateKey :: LedgerBytes -> PrivateKey
[getPrivateKey] :: PrivateKey -> LedgerBytes

-- | A message with a cryptographic signature.
newtype Signature
Signature :: ByteString -> Signature
[getSignature] :: Signature -> ByteString

-- | Check whether the given <a>Signature</a> was signed by the private key
--   corresponding to the given public key.
signedBy :: Signature -> PubKey -> TxId -> Bool

-- | Sign a message using a private key.
sign :: ByteArrayAccess a => a -> PrivateKey -> Signature

-- | Sign the hash of a transaction using a private key.
signTx :: TxId -> PrivateKey -> Signature
fromHex :: ByteString -> Either String PrivateKey
toPublicKey :: PrivateKey -> PubKey

-- | A list of 10 private keys. TODO: Generate random private keys (I
--   couldn't find a way to do this in <a>Ed25519Donna</a> in
--   'cardano-crypto')
knownPrivateKeys :: [PrivateKey]
privateKey1 :: PrivateKey
privateKey2 :: PrivateKey
privateKey3 :: PrivateKey
privateKey4 :: PrivateKey
privateKey5 :: PrivateKey
privateKey6 :: PrivateKey
privateKey7 :: PrivateKey
privateKey8 :: PrivateKey
privateKey9 :: PrivateKey
privateKey10 :: PrivateKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.Signature
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.Signature
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Crypto.Signature
instance GHC.Show.Show Plutus.V1.Ledger.Crypto.Signature
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Crypto.Signature
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Crypto.Signature
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Crypto.Signature
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Crypto.Signature
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Crypto.Signature
instance GHC.Generics.Generic Plutus.V1.Ledger.Crypto.Signature
instance GHC.Classes.Ord Plutus.V1.Ledger.Crypto.Signature
instance GHC.Classes.Eq Plutus.V1.Ledger.Crypto.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Crypto.Signature
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Crypto.Signature
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PrivateKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PrivateKey
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Crypto.PrivateKey
instance GHC.Show.Show Plutus.V1.Ledger.Crypto.PrivateKey
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Crypto.PrivateKey
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Crypto.PrivateKey
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Crypto.PrivateKey
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Crypto.PrivateKey
instance Control.Newtype.Generics.Newtype Plutus.V1.Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Crypto.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Crypto.PrivateKey
instance GHC.Generics.Generic Plutus.V1.Ledger.Crypto.PrivateKey
instance GHC.Classes.Ord Plutus.V1.Ledger.Crypto.PrivateKey
instance GHC.Classes.Eq Plutus.V1.Ledger.Crypto.PrivateKey
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PubKeyHash
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Show.Show Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.String.IsString Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Crypto.PubKeyHash
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Crypto.PubKeyHash
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Crypto.PubKeyHash
instance Control.Newtype.Generics.Newtype Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Crypto.PubKeyHash
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Generics.Generic Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Classes.Ord Plutus.V1.Ledger.Crypto.PubKeyHash
instance GHC.Classes.Eq Plutus.V1.Ledger.Crypto.PubKeyHash
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PubKey
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Crypto.PubKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Crypto.PubKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Crypto.PubKey
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Crypto.PubKey
instance GHC.Show.Show Plutus.V1.Ledger.Crypto.PubKey
instance Data.String.IsString Plutus.V1.Ledger.Crypto.PubKey
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Crypto.PubKey
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Crypto.PubKey
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Crypto.PubKey
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Crypto.PubKey
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Crypto.PubKey
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Crypto.PubKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Crypto.PubKey
instance Control.Newtype.Generics.Newtype Plutus.V1.Ledger.Crypto.PubKey
instance GHC.Generics.Generic Plutus.V1.Ledger.Crypto.PubKey
instance GHC.Classes.Ord Plutus.V1.Ledger.Crypto.PubKey
instance GHC.Classes.Eq Plutus.V1.Ledger.Crypto.PubKey

module Plutus.V1.Ledger.Credential

-- | Staking credential used to assign rewards
data StakingCredential
StakingHash :: ByteString -> StakingCredential
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credential required to unlock a transaction output
data Credential

-- | The transaction that spends this output must be signed by the private
--   key
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator.
ScriptCredential :: ValidatorHash -> Credential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Credential.StakingCredential
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Credential.StakingCredential
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Credential.StakingCredential
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Credential.StakingCredential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Credential.StakingCredential
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Generics.Generic Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Show.Show Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Classes.Ord Plutus.V1.Ledger.Credential.StakingCredential
instance GHC.Classes.Eq Plutus.V1.Ledger.Credential.StakingCredential
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Credential.Credential
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Credential.Credential
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Credential.Credential
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Credential.Credential
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Credential.Credential
instance GHC.Generics.Generic Plutus.V1.Ledger.Credential.Credential
instance GHC.Show.Show Plutus.V1.Ledger.Credential.Credential
instance GHC.Classes.Ord Plutus.V1.Ledger.Credential.Credential
instance GHC.Classes.Eq Plutus.V1.Ledger.Credential.Credential
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Credential.Credential
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Credential.Credential
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Credential.StakingCredential
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Credential.StakingCredential

module Plutus.V1.Ledger.DCert

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retiremant certificate and the Epoch N
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.DCert.DCert
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.DCert.DCert
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.DCert.DCert
instance Control.DeepSeq.NFData Plutus.V1.Ledger.DCert.DCert
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.DCert.DCert
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.DCert.DCert
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.DCert.DCert
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.DCert.DCert
instance GHC.Generics.Generic Plutus.V1.Ledger.DCert.DCert
instance GHC.Show.Show Plutus.V1.Ledger.DCert.DCert
instance GHC.Classes.Ord Plutus.V1.Ledger.DCert.DCert
instance GHC.Classes.Eq Plutus.V1.Ledger.DCert.DCert
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.DCert.DCert

module Plutus.V1.Ledger.Address

-- | Address with two kinds of credentials, normal and staking
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The address that should be targeted by a transaction output locked by
--   the given public key.
pubKeyAddress :: PubKey -> Address

-- | The address that should be targeted by a transaction output locked by
--   the public key with the given hash.
pubKeyHashAddress :: PubKeyHash -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script.
scriptAddress :: Validator -> Address

-- | The address that should be used by a transaction output locked by the
--   given validator script hash.
scriptHashAddress :: ValidatorHash -> Address

-- | The PubKeyHash of the address, if any
toPubKeyHash :: Address -> Maybe PubKeyHash

-- | The validator hash of the address, if any
toValidatorHash :: Address -> Maybe ValidatorHash

-- | The staking credential of an address (if any)
stakingCredential :: Address -> Maybe StakingCredential
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Address.Address
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Address.Address
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Address.Address
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Address.Address
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Address.Address
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Address.Address
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Address.Address
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Address.Address
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Address.Address
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Address.Address
instance GHC.Generics.Generic Plutus.V1.Ledger.Address.Address
instance GHC.Show.Show Plutus.V1.Ledger.Address.Address
instance GHC.Classes.Ord Plutus.V1.Ledger.Address.Address
instance GHC.Classes.Eq Plutus.V1.Ledger.Address.Address
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Address.Address
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Address.Address


-- | Functions for working with <a>Value</a>.
module Plutus.V1.Ledger.Value
newtype CurrencySymbol
CurrencySymbol :: ByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> ByteString
currencySymbol :: ByteString -> CurrencySymbol

-- | The currency symbol of a monetay policy hash
mpsSymbol :: MonetaryPolicyHash -> CurrencySymbol

-- | The monetary policy hash of a currency symbol
currencyMPSHash :: CurrencySymbol -> MonetaryPolicyHash

-- | ByteString of a name of a token, shown as UTF-8 string when possible
newtype TokenName
TokenName :: ByteString -> TokenName
[unTokenName] :: TokenName -> ByteString
tokenName :: ByteString -> TokenName
toString :: TokenName -> String

-- | An asset class, identified by currency symbol and token name.
newtype AssetClass
AssetClass :: (CurrencySymbol, TokenName) -> AssetClass
[unAssetClass] :: AssetClass -> (CurrencySymbol, TokenName)
assetClass :: CurrencySymbol -> TokenName -> AssetClass

-- | A <a>Value</a> containing the given amount of the asset class.
assetClassValue :: AssetClass -> Integer -> Value

-- | Get the quantity of the given <a>AssetClass</a> class in the
--   <a>Value</a>.
assetClassValueOf :: Value -> AssetClass -> Integer

-- | A cryptocurrency value. This is a map from <a>CurrencySymbol</a>s to a
--   quantity of that currency.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   See note [Currencies] for more details.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | Get the quantity of the given currency in the <a>Value</a>.
valueOf :: Value -> CurrencySymbol -> TokenName -> Integer
scale :: Module s v => s -> v -> v

-- | The list of <a>CurrencySymbol</a>s of a <a>Value</a>.
symbols :: Value -> [CurrencySymbol]

-- | Check whether one <a>Value</a> is greater than or equal to another.
--   See <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
geq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly greater than another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
gt :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is less than or equal to another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
leq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly less than another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
lt :: Value -> Value -> Bool

-- | Check whether a <a>Value</a> is zero.
isZero :: Value -> Bool

-- | Split a value into its positive and negative parts. The first element
--   of the tuple contains the negative parts of the value, the second
--   element contains the positive parts.
--   
--   <pre>
--   negate (fst (split a)) <tt>plus</tt> (snd (split a)) == a
--   </pre>
split :: Value -> (Value, Value)
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | Convert a value to a simple list, keeping only the non-zero amounts.
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.V1.Ledger.Value.Value
instance PlutusTx.Numeric.AdditiveMonoid Plutus.V1.Ledger.Value.Value
instance PlutusTx.Numeric.AdditiveGroup Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.Value
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.Value
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.Value
instance GHC.Base.Semigroup Plutus.V1.Ledger.Value.Value
instance PlutusTx.Semigroup.Semigroup Plutus.V1.Ledger.Value.Value
instance GHC.Base.Monoid Plutus.V1.Ledger.Value.Value
instance PlutusTx.Monoid.Monoid Plutus.V1.Ledger.Value.Value
instance PlutusTx.Monoid.Group Plutus.V1.Ledger.Value.Value
instance PlutusTx.Numeric.Module GHC.Integer.Type.Integer Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lattice.JoinSemiLattice Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lattice.MeetSemiLattice Plutus.V1.Ledger.Value.Value
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.Value
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Value.Value
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.Value
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.Value
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.Value
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.Value
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.Value
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.Value
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (PlutusTx.AssocMap.Map k v)
instance (Codec.Serialise.Class.Serialise k, Codec.Serialise.Class.Serialise v) => Codec.Serialise.Class.Serialise (PlutusTx.AssocMap.Map k v)
instance GHC.Show.Show Plutus.V1.Ledger.Value.Value
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.AssetClass
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSON k) => Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.AssocMap.Map k v)
instance (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSON k) => Data.Aeson.Types.FromJSON.FromJSON (PlutusTx.AssocMap.Map k v)
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.AssetClass
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.AssetClass
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.AssetClass
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.AssetClass
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.AssetClass
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.AssetClass
instance GHC.Show.Show Plutus.V1.Ledger.Value.AssetClass
instance GHC.Classes.Ord Plutus.V1.Ledger.Value.AssetClass
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.AssetClass
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.AssetClass
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.TokenName
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.TokenName
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.TokenName
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.TokenName
instance GHC.Classes.Ord Plutus.V1.Ledger.Value.TokenName
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.TokenName
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.TokenName
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.TokenName
instance Data.String.IsString Plutus.V1.Ledger.Value.TokenName
instance GHC.Show.Show Plutus.V1.Ledger.Value.TokenName
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.TokenName
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.TokenName
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Value.CurrencySymbol
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Hashable.Class.Hashable Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Value.CurrencySymbol
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Classes.Ord Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Classes.Eq Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Generics.Generic Plutus.V1.Ledger.Value.CurrencySymbol
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Value.CurrencySymbol
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Value.CurrencySymbol
instance GHC.Show.Show Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.String.IsString Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Value.CurrencySymbol
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Value.CurrencySymbol

module Plutus.V1.Ledger.Tx

-- | A transaction, including witnesses for its inputs.
data Tx
Tx :: Set TxIn -> Set TxIn -> [TxOut] -> !Value -> !Value -> !SlotRange -> Set MonetaryPolicy -> Map PubKey Signature -> Map DatumHash Datum -> Tx

-- | The inputs to this transaction.
[txInputs] :: Tx -> Set TxIn

-- | The collateral inputs to cover the fees in case validation of the
--   transaction fails.
[txCollateral] :: Tx -> Set TxIn

-- | The outputs of this transaction, ordered so they can be referenced by
--   index.
[txOutputs] :: Tx -> [TxOut]

-- | The <a>Value</a> forged by this transaction.
[txForge] :: Tx -> !Value

-- | The fee for this transaction.
[txFee] :: Tx -> !Value

-- | The <a>SlotRange</a> during which this transaction may be validated.
[txValidRange] :: Tx -> !SlotRange

-- | The scripts that must be run to check forging conditions.
[txForgeScripts] :: Tx -> Set MonetaryPolicy

-- | Signatures of this transaction.
[txSignatures] :: Tx -> Map PubKey Signature

-- | Datum objects recorded on this transaction.
[txData] :: Tx -> Map DatumHash Datum

-- | The inputs of a transaction.
inputs :: Lens' Tx (Set TxIn)

-- | The collateral inputs of a transaction for paying fees when validating
--   the transaction fails.
collateralInputs :: Lens' Tx (Set TxIn)

-- | The outputs of a transaction.
outputs :: Lens' Tx [TxOut]

-- | A list of a transaction's outputs paired with a <a>TxOutRef</a>s
--   referring to them.
txOutRefs :: Tx -> [(TxOut, TxOutRef)]

-- | The unspent outputs of a transaction.
unspentOutputsTx :: Tx -> Map TxOutRef TxOut

-- | The transaction output references consumed by a transaction.
spentOutputs :: Tx -> Set TxOutRef

-- | Update a map of unspent transaction outputs and signatures based on
--   the inputs and outputs of a transaction.
updateUtxo :: Tx -> Map TxOutRef TxOut -> Map TxOutRef TxOut

-- | Update a map of unspent transaction outputs and signatures for a
--   failed transaction using its collateral inputs.
updateUtxoCollateral :: Tx -> Map TxOutRef TxOut -> Map TxOutRef TxOut

-- | Check that all values in a transaction are non-negative.
validValuesTx :: Tx -> Bool
forgeScripts :: Lens' Tx (Set MonetaryPolicy)
signatures :: Lens' Tx (Map PubKey Signature)
datumWitnesses :: Lens' Tx (Map DatumHash Datum)
lookupSignature :: PubKey -> Tx -> Maybe Signature
lookupDatum :: Tx -> DatumHash -> Maybe Datum

-- | Sign the transaction with a <a>PrivateKey</a> and add the signature to
--   the transaction's list of signatures.
addSignature :: PrivateKey -> Tx -> Tx
forge :: Lens' Tx Value
fee :: Lens' Tx Value

-- | Compute the id of a transaction.
txId :: Tx -> TxId

-- | A transaction without witnesses for its inputs.
data TxStripped
TxStripped :: Set TxOutRef -> [TxOut] -> !Value -> !Value -> TxStripped

-- | The inputs to this transaction, as transaction output references only.
[txStrippedInputs] :: TxStripped -> Set TxOutRef

-- | The outputs of this transation.
[txStrippedOutputs] :: TxStripped -> [TxOut]

-- | The <a>Value</a> forged by this transaction.
[txStrippedForge] :: TxStripped -> !Value

-- | The fee for this transaction.
[txStrippedFee] :: TxStripped -> !Value
strip :: Tx -> TxStripped

-- | A transaction output, consisting of a target address, a value, and
--   optionally a datum hash.
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A <a>TxOut</a> along with the <a>Tx</a> it comes from, which may have
--   additional information e.g. the full data script that goes with the
--   <a>TxOut</a>.
data TxOutTx
TxOutTx :: Tx -> TxOut -> TxOutTx
[txOutTxTx] :: TxOutTx -> Tx
[txOutTxOut] :: TxOutTx -> TxOut

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | Whether the output is a pay-to-pubkey output.
isPubKeyOut :: TxOut -> Bool

-- | Whether the output is a pay-to-script output.
isPayToScriptOut :: TxOut -> Bool

-- | The address of a transaction output.
outAddress :: Lens' TxOut Address

-- | The value of a transaction output. | TODO: Compute address again
outValue :: Lens' TxOut Value

-- | The public key attached to a <a>TxOut</a>, if there is one.
txOutPubKey :: TxOut -> Maybe PubKeyHash

-- | The datum attached to a <a>TxOut</a>, if there is one.
txOutDatum :: TxOut -> Maybe DatumHash

-- | Create a transaction output locked by a public key.
pubKeyTxOut :: Value -> PubKey -> TxOut

-- | Create a transaction output locked by a public key.
pubKeyHashTxOut :: Value -> PubKeyHash -> TxOut

-- | Create a transaction output locked by a validator script and with the
--   given data script attached.
scriptTxOut :: Value -> Validator -> Datum -> TxOut

-- | Create a transaction output locked by a validator script hash with the
--   given data script attached.
scriptTxOut' :: Value -> Address -> Datum -> TxOut
txOutTxDatum :: TxOutTx -> Maybe Datum

-- | The type of a transaction input.
data TxInType

-- | A transaction input that consumes a script address with the given
--   validator, redeemer, and datum.
ConsumeScriptAddress :: !Validator -> !Redeemer -> !Datum -> TxInType

-- | A transaction input that consumes a public key address.
ConsumePublicKeyAddress :: TxInType

-- | A transaction input, consisting of a transaction output reference and
--   an input type.
data TxIn
TxIn :: !TxOutRef -> Maybe TxInType -> TxIn
[txInRef] :: TxIn -> !TxOutRef
[txInType] :: TxIn -> Maybe TxInType

-- | The <a>TxOutRef</a> spent by a transaction input.
inRef :: Lens' TxIn TxOutRef

-- | The type of a transaction input.
inType :: Lens' TxIn (Maybe TxInType)

-- | Validator, redeemer, and data scripts of a transaction input that
--   spends a "pay to script" output.
inScripts :: TxIn -> Maybe (Validator, Redeemer, Datum)

-- | The validity range of a transaction.
validRange :: Lens' Tx SlotRange

-- | A transaction input that spends a "pay to public key" output, given
--   the witness.
pubKeyTxIn :: TxOutRef -> TxIn

-- | A transaction input that spends a "pay to script" output, given
--   witnesses.
scriptTxIn :: TxOutRef -> Validator -> Redeemer -> Datum -> TxIn

-- | Filter to get only the pubkey inputs.
pubKeyTxIns :: Fold (Set TxIn) TxIn

-- | Filter to get only the script inputs.
scriptTxIns :: Fold (Set TxIn) TxIn

-- | Address with two kinds of credentials, normal and staking
data Address
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Tx.TxOut
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxOutRef
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxOutRef
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxOutRef
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxOutRef
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxInType
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxInType
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxInType
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxInType
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxInType
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.TxInType
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxInType
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxInType
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxIn
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxIn
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxIn
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxIn
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxIn
instance GHC.Classes.Ord Plutus.V1.Ledger.Tx.TxIn
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxIn
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxIn
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.TxOut
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxOut
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxOut
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxOut
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxOut
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxOut
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxOut
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxStripped
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxStripped
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxStripped
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxStripped
instance Control.DeepSeq.NFData Plutus.V1.Ledger.Tx.Tx
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.Tx
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.Tx
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.Tx
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.Tx
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.Tx
instance GHC.Show.Show Plutus.V1.Ledger.Tx.Tx
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Tx.TxOutTx
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Tx.TxOutTx
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Tx.TxOutTx
instance GHC.Generics.Generic Plutus.V1.Ledger.Tx.TxOutTx
instance GHC.Classes.Eq Plutus.V1.Ledger.Tx.TxOutTx
instance GHC.Show.Show Plutus.V1.Ledger.Tx.TxOutTx
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.Tx
instance GHC.Base.Semigroup Plutus.V1.Ledger.Tx.Tx
instance GHC.Base.Monoid Plutus.V1.Ledger.Tx.Tx
instance Data.ByteArray.Types.ByteArrayAccess Plutus.V1.Ledger.Tx.Tx
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.TxOut
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Tx.TxOut
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.TxIn
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Tx.TxOutRef
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Tx.TxOutRef


-- | Functions for working with <a>Ada</a> in Template Haskell.
module Plutus.V1.Ledger.Ada

-- | ADA, the special currency on the Cardano blockchain. The unit of Ada
--   is Lovelace, and 1M Lovelace is one Ada. See note [Currencies] in
--   <a>TH</a>.
newtype Ada
Lovelace :: Integer -> Ada
[getLovelace] :: Ada -> Integer

-- | Get the amount of Ada (the unit of the currency Ada) in this
--   <a>Ada</a> value.
getAda :: Ada -> Micro

-- | The <a>CurrencySymbol</a> of the <a>Ada</a> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <a>Ada</a> currency.
adaToken :: TokenName

-- | Get the <a>Ada</a> in the given <a>Value</a>.
fromValue :: Value -> Ada

-- | Create a <a>Value</a> containing only the given <a>Ada</a>.
toValue :: Ada -> Value

-- | Create <a>Ada</a> representing the given quantity of Lovelace (the
--   unit of the currency Ada).
lovelaceOf :: Integer -> Ada

-- | Create <a>Ada</a> representing the given quantity of Ada (1M
--   Lovelace).
adaOf :: Micro -> Ada

-- | A <a>Value</a> with the given amount of Lovelace (the currency unit).
--   
--   <pre>
--   lovelaceValueOf == toValue . lovelaceOf
--   </pre>
lovelaceValueOf :: Integer -> Value

-- | A <a>Value</a> with the given amount of Ada (the currency unit).
--   
--   <pre>
--   adaValueOf == toValue . adaOf
--   </pre>
adaValueOf :: Micro -> Value

-- | Divide one <a>Ada</a> value by another.
divide :: Ada -> Ada -> Ada

-- | Check whether an <a>Ada</a> value is zero.
isZero :: Ada -> Bool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Ada.Ada
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Ada.Ada
instance Codec.Serialise.Class.Serialise Plutus.V1.Ledger.Ada.Ada
instance GHC.Real.Real Plutus.V1.Ledger.Ada.Ada
instance GHC.Real.Integral Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeMonoid Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeSemigroup Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Numeric.AdditiveGroup Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Numeric.AdditiveMonoid Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.V1.Ledger.Ada.Ada
instance GHC.Num.Num Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Ord.Ord Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Eq.Eq Plutus.V1.Ledger.Ada.Ada
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.V1.Ledger.Ada.Ada
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.V1.Ledger.Ada.Ada
instance GHC.Generics.Generic Plutus.V1.Ledger.Ada.Ada
instance GHC.Show.Show Plutus.V1.Ledger.Ada.Ada
instance GHC.Classes.Ord Plutus.V1.Ledger.Ada.Ada
instance GHC.Classes.Eq Plutus.V1.Ledger.Ada.Ada
instance GHC.Enum.Enum Plutus.V1.Ledger.Ada.Ada
instance GHC.Base.Semigroup Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Semigroup.Semigroup Plutus.V1.Ledger.Ada.Ada
instance GHC.Base.Monoid Plutus.V1.Ledger.Ada.Ada
instance PlutusTx.Monoid.Monoid Plutus.V1.Ledger.Ada.Ada

module Plutus.V1.Ledger.Contexts

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> forged by this transaction.
[txInfoForge] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction output, consisting of a target address, a value, and
--   optionally a datum hash.
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Finds all the outputs that pay to the same script address that we are
--   currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | The <a>CurrencySymbol</a> of a <a>MonetaryPolicy</a>
scriptCurrencySymbol :: MonetaryPolicy -> CurrencySymbol

-- | Compute the hash of a public key.
pubKeyHash :: PubKey -> PubKeyHash

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get the public key hash that locks the transaction output, if any.
pubKeyOutput :: TxOut -> Maybe PubKeyHash

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(DatumHash, Value)]

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ValidatorHash -> Value

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> PubKeyHash -> Value

-- | Get the total amount of <a>Ada</a> locked by the given validator in
--   this transaction.
adaLockedBy :: TxInfo -> ValidatorHash -> Ada

-- | Check if the provided signature is the result of signing the pending
--   transaction (without witnesses) with the given public key.
signsTransaction :: Signature -> PubKey -> TxInfo -> Bool

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Get the validator and datum hashes of the output that is curently
--   being validated
ownHashes :: ScriptContext -> (ValidatorHash, DatumHash)

-- | Get the hash of the validator script that is currently being
--   validated.
ownHash :: ScriptContext -> ValidatorHash

-- | Convert a <a>CurrencySymbol</a> to a <a>ValidatorHash</a>
fromSymbol :: CurrencySymbol -> ValidatorHash
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptPurpose
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.ScriptContext
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInfo
instance PlutusTx.IsData.Class.IsData Plutus.V1.Ledger.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInInfo
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.V1.Ledger.Contexts.TxInInfo
instance GHC.Generics.Generic Plutus.V1.Ledger.Contexts.TxInInfo
instance GHC.Generics.Generic Plutus.V1.Ledger.Contexts.TxInfo


-- | The interface to Plutus V1 for the ledger.
module Plutus.V1.Ledger.Api

-- | Scripts to the ledger are serialised bytestrings.
type SerializedScript = ShortByteString

-- | Check if a <a>Script</a> is "valid". At the moment this just means
--   "deserialises correctly", which in particular implies that it is
--   (almost certainly) an encoded script and cannot be interpreted as some
--   other kind of encoded data.
validateScript :: SerializedScript -> Bool
validateCostModelParams :: CostModelParams -> Bool

-- | The default cost model data. This is exposed to the ledger, so let's
--   not confuse anybody by mentioning the CEK machine
defaultCostModelParams :: Maybe CostModelParams
type CostModelParams = Map Text Integer

-- | Evaluates a script, with a cost model and a budget that restricts how
--   many resources it can use according to the cost model. There's a
--   default cost model in <a>defaultBuiltinCostModel</a> and a budget
--   called <tt>enormousBudget</tt> in <a>ExBudgetMode</a> which should be
--   large enough to evaluate any sensible program.
evaluateScriptRestricting :: VerboseMode -> CostModelParams -> ExBudget -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ())

-- | Evaluates a script, returning the minimum budget that the script would
--   need to evaluate successfully.
evaluateScriptCounting :: VerboseMode -> CostModelParams -> SerializedScript -> [Data] -> (LogOutput, Either EvaluationError ExBudget)
plutusScriptEnvelopeType :: Text

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A typeclass for types that can be converted to and from <a>Data</a>.
class IsData a
toData :: IsData a => a -> Data
fromData :: IsData a => Data -> Maybe a
data ExBudget
ExBudget :: ExCPU -> ExMemory -> ExBudget
[_exBudgetCPU] :: ExBudget -> ExCPU
[_exBudgetMemory] :: ExBudget -> ExMemory

-- | Counts CPU units in picoseconds: maximum value for SatInt is 2^63 ps,
--   or appproximately 106 days.
newtype ExCPU
ExCPU :: CostingInteger -> ExCPU

-- | Counts size in machine words.
newtype ExMemory
ExMemory :: CostingInteger -> ExMemory
data VerboseMode
Verbose :: VerboseMode
Quiet :: VerboseMode
type LogOutput = [Text]
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | 'Bultins.SizedByteString 32' with various useful JSON and servant
--   instances for the Playground, and a convenient bridge type for
--   PureScript.
newtype LedgerBytes
LedgerBytes :: ByteString -> LedgerBytes
[getLedgerBytes] :: LedgerBytes -> ByteString
fromBytes :: ByteString -> LedgerBytes

-- | A representation of the ledger DCert. Some information is digested,
--   and not included
data DCert
DCertDelegRegKey :: StakingCredential -> DCert
DCertDelegDeRegKey :: StakingCredential -> DCert
DCertDelegDelegate :: StakingCredential -> PubKeyHash -> DCert

-- | A digest of the PoolParams
DCertPoolRegister :: PubKeyHash -> PubKeyHash -> DCert

-- | The retiremant certificate and the Epoch N
DCertPoolRetire :: PubKeyHash -> Integer -> DCert

-- | A really terse Digest
DCertGenesis :: DCert

-- | Another really terse Digest
DCertMir :: DCert

-- | Staking credential used to assign rewards
data StakingCredential
StakingHash :: ByteString -> StakingCredential
StakingPtr :: Integer -> Integer -> Integer -> StakingCredential

-- | Credential required to unlock a transaction output
data Credential

-- | The transaction that spends this output must be signed by the private
--   key
PubKeyCredential :: PubKeyHash -> Credential

-- | The transaction that spends this output must include the validator
--   script and be accepted by the validator.
ScriptCredential :: ValidatorHash -> Credential

-- | Address with two kinds of credentials, normal and staking
data Address
Address :: Credential -> Maybe StakingCredential -> Address
[addressCredential] :: Address -> Credential
[addressStakingCredential] :: Address -> Maybe StakingCredential

-- | The hash of a public key. This is frequently used to identify the
--   public key, rather than the key itself.
newtype PubKeyHash
PubKeyHash :: ByteString -> PubKeyHash
[getPubKeyHash] :: PubKeyHash -> ByteString

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> forged by this transaction.
[txInfoForge] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId

-- | A transaction output, consisting of a target address, a value, and
--   optionally a datum hash.
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
newtype Slot
Slot :: Integer -> Slot
[getSlot] :: Slot -> Integer

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | A set extended with a positive and negative infinity.
data Extended a
NegInf :: Extended a
Finite :: a -> Extended a
PosInf :: Extended a

-- | Whether a bound is inclusive or not.
type Closure = Bool

-- | The upper bound of an interval.
data UpperBound a
UpperBound :: Extended a -> Closure -> UpperBound a

-- | The lower bound of an interval.
data LowerBound a
LowerBound :: Extended a -> Closure -> LowerBound a

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
newtype Validator
Validator :: Script -> Validator
[getValidator] :: Validator -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype ValidatorHash
ValidatorHash :: ByteString -> ValidatorHash

-- | <a>MonetaryPolicy</a> is a wrapper around <a>Script</a>s which are
--   used as validators for forging constraints.
newtype MonetaryPolicy
MonetaryPolicy :: Script -> MonetaryPolicy
[getMonetaryPolicy] :: MonetaryPolicy -> Script

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype MonetaryPolicyHash
MonetaryPolicyHash :: ByteString -> MonetaryPolicyHash

-- | <a>Redeemer</a> is a wrapper around <a>Data</a> values that are used
--   as redeemers in transaction inputs.
newtype Redeemer
Redeemer :: Data -> Redeemer
[getRedeemer] :: Redeemer -> Data

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype RedeemerHash
RedeemerHash :: ByteString -> RedeemerHash

-- | <a>Datum</a> is a wrapper around <a>Data</a> values which are used as
--   data in transaction outputs.
newtype Datum
Datum :: Data -> Datum
[getDatum] :: Datum -> Data

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
newtype DatumHash
DatumHash :: ByteString -> DatumHash

-- | Errors that can be thrown when evaluating a Plutus script.
data EvaluationError

-- | An error from the evaluator itself
CekError :: CekEvaluationException DefaultUni DefaultFun -> EvaluationError

-- | An error in the pre-evaluation step of converting from de-Bruijn
--   indices
DeBruijnError :: FreeVariableError -> EvaluationError

-- | A serialisation error
CodecError :: DeserialiseFailure -> EvaluationError

-- | An error indicating a version tag that we don't support TODO: make
--   this error more informative when we have more information about what
--   went wrong
IncompatibleVersionError :: Version () -> EvaluationError

-- | An error indicating that the cost model parameters didn't match what
--   we expected
CostModelParameterMismatch :: EvaluationError
instance GHC.Classes.Eq Plutus.V1.Ledger.Api.VerboseMode
instance GHC.Classes.Eq Plutus.V1.Ledger.Api.EvaluationError
instance GHC.Show.Show Plutus.V1.Ledger.Api.EvaluationError
instance Prettyprinter.Internal.Pretty Plutus.V1.Ledger.Api.EvaluationError


-- | This module contains example values to be used for testing. These
--   should NOT be used in non-test code!
module Plutus.V1.Ledger.Examples

-- | Creates a script which has N arguments, and always succeeds.
alwaysSucceedingNAryFunction :: Natural -> SerializedScript

-- | Creates a script which has N arguments, and always fails.
alwaysFailingNAryFunction :: Natural -> SerializedScript
