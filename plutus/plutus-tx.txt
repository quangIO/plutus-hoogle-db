-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Libraries for Plutus Tx and its prelude
--   
--   Libraries for Plutus Tx and its prelude
@package plutus-tx
@version 0.1.0.0

module PlutusTx.Bool
data Bool
False :: Bool
True :: Bool

-- | Logical AND
--   
--   <pre>
--   &gt;&gt;&gt; True &amp;&amp; False
--   False
--   </pre>
(&&) :: Bool -> Bool -> Bool
infixr 3 &&

-- | Logical OR
--   
--   <pre>
--   &gt;&gt;&gt; True || False
--   True
--   </pre>
(||) :: Bool -> Bool -> Bool
infixr 2 ||

-- | Logical negation
--   
--   <pre>
--   &gt;&gt;&gt; not True
--   False
--   </pre>
not :: Bool -> Bool

module PlutusTx.Data

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data
instance Control.DeepSeq.NFData PlutusTx.Data.Data
instance GHC.Generics.Generic PlutusTx.Data.Data
instance GHC.Classes.Ord PlutusTx.Data.Data
instance GHC.Classes.Eq PlutusTx.Data.Data
instance GHC.Show.Show PlutusTx.Data.Data
instance Prettyprinter.Internal.Pretty PlutusTx.Data.Data
instance Codec.Serialise.Class.Serialise PlutusTx.Data.Data

module PlutusTx.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
Left :: a -> Either a b
Right :: b -> Either a b

-- | Return <a>True</a> if the given value is a <a>Left</a>-value,
--   <a>False</a> otherwise.
isLeft :: Either a b -> Bool

-- | Return <a>True</a> if the given value is a <a>Right</a>-value,
--   <a>False</a> otherwise.
isRight :: Either a b -> Bool

-- | Plutus Tx version of <a>either</a>
either :: (a -> c) -> (b -> c) -> Either a b -> c

module PlutusTx.Evaluation

-- | Evaluate a program in the CEK machine with the usual string dynamic
--   builtins.
evaluateCek :: (uni ~ DefaultUni, fun ~ DefaultFun) => Program Name uni fun () -> Either (CekEvaluationException uni fun) (Term Name uni fun ())

-- | Evaluate a program in the CEK machine with the usual string dynamic
--   builtins. May throw.
unsafeEvaluateCek :: (uni ~ DefaultUni, fun ~ DefaultFun) => Program Name uni fun () -> EvaluationResult (Term Name uni fun ())

-- | Evaluate a program in the CEK machine with the usual string dynamic
--   builtins and tracing, additionally returning the trace output.
evaluateCekTrace :: (uni ~ DefaultUni, fun ~ DefaultFun) => Program Name uni fun () -> ([String], CekExTally fun, Either (CekEvaluationException uni fun) (Term Name uni fun ()))

-- | An error and (optionally) what caused it.
data ErrorWithCause err term
ErrorWithCause :: err -> Maybe term -> ErrorWithCause err term
[_ewcError] :: ErrorWithCause err term -> err
[_ewcCause] :: ErrorWithCause err term -> Maybe term

-- | The type of errors (all of them) which can occur during evaluation
--   (some are used-caused, some are internal).
data EvaluationError user internal

-- | Indicates bugs.
InternalEvaluationError :: internal -> EvaluationError user internal

-- | Indicates user errors.
UserEvaluationError :: user -> EvaluationError user internal

-- | For a detailed report on what costs how much + the same overall budget
--   that <tt>Counting</tt> gives. The (derived) <a>Monoid</a> instance of
--   <a>CekExTally</a> is the main piece of the machinery.
data CekExTally fun
type CekEvaluationException (uni :: Type -> Type) fun = CekEvaluationExceptionCarrying Term Name uni fun () fun

module PlutusTx.Functor

-- | Plutus Tx version of <a>Functor</a>.
class Functor f

-- | Plutus Tx version of <a>fmap</a>.
fmap :: Functor f => (a -> b) -> f a -> f b

-- | Plutus Tx version of <a>(&lt;$&gt;)</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b
infixl 4 <$>

-- | Plutus Tx version of <a>(&lt;$)</a>.
(<$) :: Functor f => a -> f b -> f a
infixl 4 <$

-- | Plutus Tx version of <a>const</a>.
const :: a -> b -> a

-- | Plutus Tx version of <a>id</a>.
id :: a -> a
instance PlutusTx.Functor.Functor []
instance PlutusTx.Functor.Functor GHC.Maybe.Maybe
instance PlutusTx.Functor.Functor (Data.Either.Either c)
instance PlutusTx.Functor.Functor ((,) c)
instance PlutusTx.Functor.Functor Data.Functor.Identity.Identity
instance PlutusTx.Functor.Functor (Data.Functor.Const.Const m)

module PlutusTx.Lattice

-- | A join semi-lattice, i.e. a partially ordered set equipped with a
--   binary operation <a>(\/)</a>.
--   
--   Note that the mathematical definition would require an ordering
--   constraint - we omit that so we can define instances for e.g.
--   <tt>(-&gt;)</tt>.
class JoinSemiLattice a
(\/) :: JoinSemiLattice a => a -> a -> a

-- | A meet semi-lattice, i.e. a partially ordered set equipped with a
--   binary operation <a>(/\)</a>.
--   
--   Note that the mathematical definition would require an ordering
--   constraint - we omit that so we can define instances for e.g.
--   <tt>(-&gt;)</tt>.
class MeetSemiLattice a
(/\) :: MeetSemiLattice a => a -> a -> a

-- | A lattice.
type Lattice a = (JoinSemiLattice a, MeetSemiLattice a)

-- | A bounded join semi-lattice, i.e. a join semi-lattice augmented with a
--   distinguished element <a>bottom</a> which is the unit of <a>(\/)</a>.
class JoinSemiLattice a => BoundedJoinSemiLattice a
bottom :: BoundedJoinSemiLattice a => a

-- | A bounded meet semi-lattice, i.e. a meet semi-lattice augmented with a
--   distinguished element <a>top</a> which is the unit of <a>(/\)</a>.
class MeetSemiLattice a => BoundedMeetSemiLattice a
top :: BoundedMeetSemiLattice a => a

-- | A bounded lattice.
type BoundedLattice a = (BoundedJoinSemiLattice a, BoundedMeetSemiLattice a)

-- | A wrapper witnessing that a join semi-lattice is a monoid with
--   <a>(\/)</a> and <a>bottom</a>.
newtype Join a
Join :: a -> Join a

-- | A wrapper witnessing that a meet semi-lattice is a monoid with
--   <a>(/\)</a> and <a>top</a>.
newtype Meet a
Meet :: a -> Meet a
instance PlutusTx.Lattice.MeetSemiLattice a => GHC.Base.Semigroup (PlutusTx.Lattice.Meet a)
instance PlutusTx.Lattice.BoundedMeetSemiLattice a => GHC.Base.Monoid (PlutusTx.Lattice.Meet a)
instance PlutusTx.Lattice.JoinSemiLattice a => GHC.Base.Semigroup (PlutusTx.Lattice.Join a)
instance PlutusTx.Lattice.BoundedJoinSemiLattice a => GHC.Base.Monoid (PlutusTx.Lattice.Join a)
instance PlutusTx.Lattice.BoundedMeetSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.BoundedMeetSemiLattice a, PlutusTx.Lattice.BoundedMeetSemiLattice b) => PlutusTx.Lattice.BoundedMeetSemiLattice (a, b)
instance PlutusTx.Lattice.BoundedMeetSemiLattice b => PlutusTx.Lattice.BoundedMeetSemiLattice (a -> b)
instance PlutusTx.Lattice.BoundedJoinSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.BoundedJoinSemiLattice a, PlutusTx.Lattice.BoundedJoinSemiLattice b) => PlutusTx.Lattice.BoundedJoinSemiLattice (a, b)
instance PlutusTx.Lattice.BoundedJoinSemiLattice b => PlutusTx.Lattice.BoundedJoinSemiLattice (a -> b)
instance PlutusTx.Lattice.MeetSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.MeetSemiLattice a, PlutusTx.Lattice.MeetSemiLattice b) => PlutusTx.Lattice.MeetSemiLattice (a, b)
instance PlutusTx.Lattice.MeetSemiLattice b => PlutusTx.Lattice.MeetSemiLattice (a -> b)
instance PlutusTx.Lattice.JoinSemiLattice GHC.Types.Bool
instance (PlutusTx.Lattice.JoinSemiLattice a, PlutusTx.Lattice.JoinSemiLattice b) => PlutusTx.Lattice.JoinSemiLattice (a, b)
instance PlutusTx.Lattice.JoinSemiLattice b => PlutusTx.Lattice.JoinSemiLattice (a -> b)

module PlutusTx.Lift.Class

-- | Class for types which have a corresponding Plutus IR type. Instances
--   should always be derived, do not write your own instance!
class Typeable uni (a :: k)

-- | Get the Plutus IR type corresponding to this type.
typeRep :: Typeable uni a => Proxy a -> RTCompile uni fun (Type TyName uni ())

-- | Class for types which can be lifted into Plutus IR. Instances should
--   be derived, do not write your own instance!
class Lift uni a

-- | Get a Plutus IR term corresponding to the given value.
lift :: Lift uni a => a -> RTCompile uni fun (Term TyName Name uni fun ())
type RTCompile uni fun = DefT Name uni fun () Quote
makeTypeable :: Type -> Name -> Q [Dec]
makeLift :: Name -> Q [Dec]
withTyVars :: MonadReader (LocalVars uni) m => [(Name, TyVarDecl TyName ())] -> m a -> m a
data LiftError
UnsupportedLiftKind :: Kind -> LiftError
UnsupportedLiftType :: Type -> LiftError
UserLiftError :: Text -> LiftError
LiftMissingDataCons :: Name -> LiftError
LiftMissingVar :: Name -> LiftError
instance GHC.Exception.Type.Exception PlutusTx.Lift.Class.LiftError
instance GHC.Classes.Ord PlutusTx.Lift.Class.Dep
instance GHC.Classes.Eq PlutusTx.Lift.Class.Dep
instance GHC.Show.Show PlutusTx.Lift.Class.Dep
instance Prettyprinter.Internal.Pretty PlutusTx.Lift.Class.LiftError
instance GHC.Show.Show PlutusTx.Lift.Class.LiftError
instance ErrorCode.HasErrorCode PlutusTx.Lift.Class.LiftError

module PlutusTx.These

-- | A <a>These</a> <tt>a</tt> <tt>b</tt> is either an <tt>a</tt>, or a
--   <tt>b</tt> or an <tt>a</tt> and a <tt>b</tt>. Plutus version of
--   <a>These</a>.
data These a b
This :: a -> These a b
That :: b -> These a b
These :: a -> b -> These a b
these :: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c

-- | Consume a 'These a b' value.
theseWithDefault :: a -> b -> (a -> b -> c) -> These a b -> c

module PlutusTx.Utils
mustBeReplaced :: String -> a


-- | Primitive names and functions for working with Plutus Core builtins.
module PlutusTx.Builtins

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | Concatenates two <a>ByteString</a>s.
concatenate :: ByteString -> ByteString -> ByteString

-- | Returns the n length prefix of a <a>ByteString</a>.
takeByteString :: Integer -> ByteString -> ByteString

-- | Returns the suffix of a <a>ByteString</a> after n elements.
dropByteString :: Integer -> ByteString -> ByteString

-- | An empty <a>ByteString</a>.
emptyByteString :: ByteString

-- | Check if two <a>ByteString</a>s are equal.
equalsByteString :: ByteString -> ByteString -> Bool

-- | Check if one <a>ByteString</a> is less than another.
lessThanByteString :: ByteString -> ByteString -> Bool

-- | Check if one <a>ByteString</a> is greater than another.
greaterThanByteString :: ByteString -> ByteString -> Bool

-- | The SHA2-256 hash of a <a>ByteString</a>
sha2_256 :: ByteString -> ByteString

-- | The SHA3-256 hash of a <a>ByteString</a>
sha3_256 :: ByteString -> ByteString

-- | Verify that the signature is a signature of the message by the public
--   key.
verifySignature :: ByteString -> ByteString -> ByteString -> Bool

-- | Converts a ByteString to a String.
decodeUtf8 :: ByteString -> String

-- | Add two <a>Integer</a>s.
addInteger :: Integer -> Integer -> Integer

-- | Subtract two <a>Integer</a>s.
subtractInteger :: Integer -> Integer -> Integer

-- | Multiply two <a>Integer</a>s.
multiplyInteger :: Integer -> Integer -> Integer

-- | Divide two integers.
divideInteger :: Integer -> Integer -> Integer

-- | Integer modulo operation.
modInteger :: Integer -> Integer -> Integer

-- | Quotient of two integers.
quotientInteger :: Integer -> Integer -> Integer

-- | Take the remainder of dividing two <a>Integer</a>s.
remainderInteger :: Integer -> Integer -> Integer

-- | Check whether one <a>Integer</a> is greater than another.
greaterThanInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is greater than or equal to another.
greaterThanEqInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is less than another.
lessThanInteger :: Integer -> Integer -> Bool

-- | Check whether one <a>Integer</a> is less than or equal to another.
lessThanEqInteger :: Integer -> Integer -> Bool

-- | Check if two <a>Integer</a>s are equal.
equalsInteger :: Integer -> Integer -> Bool

-- | Aborts evaluation with an error.
error :: () -> a

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | An opaque type representing Plutus Core strings.
data String

-- | Append two <a>String</a>s.
appendString :: String -> String -> String

-- | An empty <a>String</a>.
emptyString :: String

-- | Turn a <a>Char</a> into a <a>String</a>.
charToString :: Char -> String

-- | Check if two strings are equal
equalsString :: String -> String -> Bool

-- | Convert a String into a ByteString.
encodeUtf8 :: String -> ByteString

-- | Logs the given <a>String</a> to the evaluation log.
trace :: String -> ()

module PlutusTx.String
stringToBuiltinString :: String -> String
instance Data.String.IsString PlutusTx.Builtins.String

module PlutusTx.Code

-- | A compiled Plutus Tx program. The last type parameter indicates the
--   type of the Haskell expression that was compiled, and hence the type
--   of the compiled code.
--   
--   Note: the compiled PLC program does *not* have normalized types, if
--   you want to put it on the chain you must normalize the types first.
data CompiledCodeIn uni fun a

-- | Serialized UPLC code and possibly serialized PIR code.
SerializedCode :: ByteString -> Maybe ByteString -> CompiledCodeIn uni fun a

-- | Deserialized UPLC program, and possibly deserialized PIR program.
DeserializedCode :: Program NamedDeBruijn uni fun () -> Maybe (Program TyName Name uni fun ()) -> CompiledCodeIn uni fun a

-- | <a>CompiledCodeIn</a> instantiated with default built-in types and
--   functions.
type CompiledCode = CompiledCodeIn DefaultUni DefaultFun

-- | Apply a compiled function to a compiled argument.
applyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> CompiledCodeIn uni fun b

-- | The size of a <a>CompiledCodeIn</a>, in AST nodes.
sizePlc :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Integer
newtype ImpossibleDeserialisationFailure
ImpossibleDeserialisationFailure :: DecodeException -> ImpossibleDeserialisationFailure

-- | Get the actual Plutus Core program out of a <a>CompiledCodeIn</a>.
getPlc :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun ()

-- | Get the Plutus IR program, if there is one, out of a
--   <a>CompiledCodeIn</a>.
getPir :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun ())
instance GHC.Exception.Type.Exception PlutusTx.Code.ImpossibleDeserialisationFailure
instance GHC.Show.Show PlutusTx.Code.ImpossibleDeserialisationFailure
instance ErrorCode.HasErrorCode PlutusTx.Code.ImpossibleDeserialisationFailure

module PlutusTx.Plugin.Utils

-- | Marks the given expression for compilation to PLC.
plc :: forall (loc :: Symbol) a. Proxy loc -> a -> CompiledCode a

module PlutusTx.TH

-- | Compile a quoted Haskell expression into a corresponding Plutus Core
--   program.
compile :: Q (TExp a) -> Q (TExp (CompiledCode a))

-- | Compile a quoted Haskell expression into a corresponding Plutus Core
--   program.
compileUntyped :: Q Exp -> Q Exp

module PlutusTx.Lift
makeLift :: Name -> Q [Dec]

-- | Get a Plutus Core term corresponding to the given value.
safeLift :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun) => a -> m (Term NamedDeBruijn uni fun ())

-- | Get a Plutus Core program corresponding to the given value.
safeLiftProgram :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun) => a -> m (Program NamedDeBruijn uni fun ())
safeLiftCode :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun) => a -> m (CompiledCodeIn uni fun a)

-- | Get a Plutus Core term corresponding to the given value, throwing any
--   errors that occur as exceptions and ignoring fresh names.
lift :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> Term NamedDeBruijn uni fun ()

-- | Get a Plutus Core program corresponding to the given value, throwing
--   any errors that occur as exceptions and ignoring fresh names.
liftProgram :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> Program NamedDeBruijn uni fun ()

-- | Get a Plutus Core program in the default universe corresponding to the
--   given value, throwing any errors that occur as exceptions and ignoring
--   fresh names.
liftProgramDef :: Lift DefaultUni a => a -> Program NamedDeBruijn DefaultUni DefaultFun ()

-- | Get a Plutus Core program corresponding to the given value as a
--   <a>CompiledCodeIn</a>, throwing any errors that occur as exceptions
--   and ignoring fresh names.
liftCode :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> CompiledCodeIn uni fun a

-- | Check that PLC term has the given type.
typeCheckAgainst :: forall e a uni fun m. (Typeable uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), AsTypeErrorExt e uni (Provenance ()), AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, GEq uni, Typecheckable uni fun) => Proxy a -> Term TyName Name uni fun () -> m ()

-- | Try to interpret a PLC program as a <a>CompiledCodeIn</a> of the given
--   type. Returns successfully iff the program has the right type.
typeCode :: forall e a uni fun m. (Typeable uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, GEq uni, Typecheckable uni fun) => Proxy a -> Program TyName Name uni fun () -> m (CompiledCodeIn uni fun a)

module PlutusTx.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>).
class Eq a
(==) :: Eq a => a -> a -> Bool
infix 4 ==
(/=) :: Eq a => a -> a -> Bool
infix 4 /=
instance PlutusTx.Eq.Eq GHC.Integer.Type.Integer
instance PlutusTx.Eq.Eq Data.ByteString.Internal.ByteString
instance PlutusTx.Eq.Eq PlutusTx.Builtins.String
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq [a]
instance PlutusTx.Eq.Eq GHC.Types.Bool
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (GHC.Maybe.Maybe a)
instance (PlutusTx.Eq.Eq a, PlutusTx.Eq.Eq b) => PlutusTx.Eq.Eq (Data.Either.Either a b)
instance PlutusTx.Eq.Eq ()
instance (PlutusTx.Eq.Eq a, PlutusTx.Eq.Eq b) => PlutusTx.Eq.Eq (a, b)
instance PlutusTx.Eq.Eq PlutusTx.Data.Data

module PlutusTx.List

-- | Plutus Tx version of <a>map</a>.
--   
--   <pre>
--   &gt;&gt;&gt; map (\i -&gt; i + 1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Plutus Tx version of <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; filter (&gt; 1) [1, 2, 3, 4]
--   [2,3,4]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>listToMaybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Return the element in the list, if there is precisely one.
uniqueElement :: [a] -> Maybe a

-- | Plutus Tx version of <a>findIndices</a>.
findIndices :: (a -> Bool) -> [a] -> [Integer]

-- | Plutus Tx version of <a>findIndex</a>.
findIndex :: (a -> Bool) -> [a] -> Maybe Integer

-- | Plutus Tx version of <a>foldr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; foldr (\i s -&gt; s + i) 0 [1, 2, 3, 4]
--   10
--   </pre>
foldr :: (a -> b -> b) -> b -> [a] -> b

-- | Plutus Tx version of <a>reverse</a>.
reverse :: [a] -> [a]

-- | Plutus Tx version of <a>zip</a>.
zip :: [a] -> [b] -> [(a, b)]

-- | Plutus Tx version of <a>(++)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 1, 2] ++ [1, 2, 3, 4]
--   [0,1,2,1,2,3,4]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Plutus Tx version of <a>(!!)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 11, 12] !! 2
--   12
--   </pre>
(!!) :: [a] -> Integer -> a
infixl 9 !!

-- | Plutus Tx version of <a>head</a>.
head :: [a] -> a

-- | Plutus Tx version of <a>take</a>.
take :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>tail</a>.
tail :: [a] -> [a]

-- | Plutus Tx version of <a>nub</a>.
nub :: Eq a => [a] -> [a]

-- | Plutus Tx version of <a>nubBy</a>.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

module PlutusTx.Semigroup

-- | Plutus Tx version of <a>Semigroup</a>.
class Semigroup a

-- | Plutus Tx version of <a>(&lt;&gt;)</a>.
(<>) :: Semigroup a => a -> a -> a
infixr 6 <>
instance PlutusTx.Semigroup.Semigroup Data.ByteString.Internal.ByteString
instance PlutusTx.Semigroup.Semigroup PlutusTx.Builtins.String
instance PlutusTx.Semigroup.Semigroup [a]
instance (PlutusTx.Semigroup.Semigroup a, PlutusTx.Semigroup.Semigroup b) => PlutusTx.Semigroup.Semigroup (a, b)
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Semigroup.Semigroup (GHC.Maybe.Maybe a)
instance PlutusTx.Semigroup.Semigroup GHC.Types.Ordering
instance PlutusTx.Semigroup.Semigroup ()
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Dual a)
instance PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Endo a)
instance PlutusTx.Semigroup.Semigroup (Data.Monoid.First a)

module PlutusTx.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <=
infix 4 <
newtype Max a
Max :: a -> Max a
[getMax] :: Max a -> a
newtype Min a
Min :: a -> Min a
[getMin] :: Min a -> a
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
instance GHC.Base.Functor PlutusTx.Ord.Min
instance PlutusTx.Ord.Ord a => PlutusTx.Semigroup.Semigroup (PlutusTx.Ord.Min a)
instance GHC.Base.Functor PlutusTx.Ord.Max
instance PlutusTx.Ord.Ord a => PlutusTx.Semigroup.Semigroup (PlutusTx.Ord.Max a)
instance PlutusTx.Ord.Ord GHC.Integer.Type.Integer
instance PlutusTx.Ord.Ord Data.ByteString.Internal.ByteString
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord [a]
instance PlutusTx.Ord.Ord GHC.Types.Bool
instance PlutusTx.Ord.Ord a => PlutusTx.Ord.Ord (GHC.Maybe.Maybe a)
instance (PlutusTx.Ord.Ord a, PlutusTx.Ord.Ord b) => PlutusTx.Ord.Ord (Data.Either.Either a b)
instance PlutusTx.Ord.Ord ()
instance (PlutusTx.Ord.Ord a, PlutusTx.Ord.Ord b) => PlutusTx.Ord.Ord (a, b)
instance PlutusTx.Ord.Ord PlutusTx.Data.Data

module PlutusTx.Monoid

-- | Plutus Tx version of <a>Monoid</a>.
class Semigroup a => Monoid a

-- | Plutus Tx version of <a>mempty</a>.
mempty :: Monoid a => a

-- | Plutus Tx version of <a>mappend</a>.
mappend :: Monoid a => a -> a -> a

-- | Plutus Tx version of <a>mconcat</a>.
mconcat :: Monoid a => [a] -> a
class Monoid a => Group a
inv :: Group a => a -> a
gsub :: Group a => a -> a -> a
instance PlutusTx.Monoid.Monoid Data.ByteString.Internal.ByteString
instance PlutusTx.Monoid.Monoid PlutusTx.Builtins.String
instance PlutusTx.Monoid.Monoid [a]
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Monoid.Monoid (GHC.Maybe.Maybe a)
instance PlutusTx.Monoid.Monoid ()
instance (PlutusTx.Monoid.Monoid a, PlutusTx.Monoid.Monoid b) => PlutusTx.Monoid.Monoid (a, b)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Dual a)
instance PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Endo a)
instance PlutusTx.Monoid.Monoid (Data.Monoid.First a)

module PlutusTx.Numeric

-- | A <a>Semigroup</a> that it is sensible to describe using addition.
class AdditiveSemigroup a
(+) :: AdditiveSemigroup a => a -> a -> a
infixl 6 +

-- | A <a>Monoid</a> that it is sensible to describe using addition and
--   zero.
class AdditiveSemigroup a => AdditiveMonoid a
zero :: AdditiveMonoid a => a

-- | A <a>Group</a> that it is sensible to describe using addition, zero,
--   and subtraction.
class AdditiveMonoid a => AdditiveGroup a
(-) :: AdditiveGroup a => a -> a -> a
infixl 6 -
negate :: AdditiveGroup a => a -> a

-- | A newtype wrapper to derive <a>Additive</a> classes via.
newtype Additive a
Additive :: a -> Additive a

-- | A <a>Semigroup</a> that it is sensible to describe using
--   multiplication.
class MultiplicativeSemigroup a
(*) :: MultiplicativeSemigroup a => a -> a -> a
infixl 7 *

-- | A <a>Semigroup</a> that it is sensible to describe using
--   multiplication and one.
class MultiplicativeSemigroup a => MultiplicativeMonoid a
one :: MultiplicativeMonoid a => a

-- | A newtype wrapper to derive <a>Multiplicative</a> classes via.
newtype Multiplicative a
Multiplicative :: a -> Multiplicative a

-- | A semiring.
type Semiring a = (AdditiveMonoid a, MultiplicativeMonoid a)

-- | A ring.
type Ring a = (AdditiveGroup a, MultiplicativeMonoid a)

-- | A module, with a type of scalars which can be used to scale the
--   values.
class (Ring s, AdditiveGroup v) => Module s v | v -> s
scale :: Module s v => s -> v -> v
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Numeric.MultiplicativeSemigroup (PlutusTx.Numeric.Multiplicative a)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Numeric.MultiplicativeMonoid (PlutusTx.Numeric.Multiplicative a)
instance PlutusTx.Numeric.MultiplicativeMonoid GHC.Integer.Type.Integer
instance PlutusTx.Numeric.MultiplicativeMonoid GHC.Types.Bool
instance PlutusTx.Numeric.MultiplicativeMonoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Product a)
instance PlutusTx.Numeric.MultiplicativeSemigroup GHC.Integer.Type.Integer
instance PlutusTx.Numeric.MultiplicativeSemigroup GHC.Types.Bool
instance PlutusTx.Numeric.MultiplicativeSemigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Product a)
instance PlutusTx.Semigroup.Semigroup a => PlutusTx.Numeric.AdditiveSemigroup (PlutusTx.Numeric.Additive a)
instance PlutusTx.Monoid.Monoid a => PlutusTx.Numeric.AdditiveMonoid (PlutusTx.Numeric.Additive a)
instance PlutusTx.Monoid.Group a => PlutusTx.Numeric.AdditiveGroup (PlutusTx.Numeric.Additive a)
instance PlutusTx.Numeric.AdditiveGroup GHC.Integer.Type.Integer
instance PlutusTx.Numeric.AdditiveMonoid GHC.Integer.Type.Integer
instance PlutusTx.Numeric.AdditiveMonoid GHC.Types.Bool
instance PlutusTx.Numeric.AdditiveMonoid a => PlutusTx.Monoid.Monoid (Data.Semigroup.Internal.Sum a)
instance PlutusTx.Numeric.AdditiveSemigroup GHC.Integer.Type.Integer
instance PlutusTx.Numeric.AdditiveSemigroup GHC.Types.Bool
instance PlutusTx.Numeric.AdditiveSemigroup a => PlutusTx.Semigroup.Semigroup (Data.Semigroup.Internal.Sum a)

module PlutusTx.Applicative

-- | Plutus Tx version of <a>Applicative</a>.
class Functor f => Applicative f

-- | Plutus Tx version of <a>pure</a>.
pure :: Applicative f => a -> f a

-- | Plutus Tx version of <a>(&lt;*&gt;)</a>.
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
infixl 4 <*>

-- | Plutus Tx version of <a>liftA2</a>.
liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

-- | Plutus Tx version of <a>(*&gt;)</a>.
(*>) :: Applicative f => f a -> f b -> f b
infixl 4 *>

-- | Plutus Tx version of <a>(&lt;*)</a>.
(<*) :: Applicative f => f a -> f b -> f a
infixl 4 <*

-- | Plutus Tx version of <a>unless</a>.
unless :: Applicative f => Bool -> f () -> f ()
instance PlutusTx.Applicative.Applicative GHC.Maybe.Maybe
instance PlutusTx.Applicative.Applicative (Data.Either.Either a)
instance PlutusTx.Applicative.Applicative Data.Functor.Identity.Identity
instance PlutusTx.Monoid.Monoid m => PlutusTx.Applicative.Applicative (Data.Functor.Const.Const m)

module PlutusTx.Maybe

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a
Nothing :: Maybe a
Just :: a -> Maybe a

-- | Check if a <a>Maybe</a> <tt>a</tt> is <tt>Just a</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isJust Nothing
--   False
--   
--   &gt;&gt;&gt; isJust (Just "plutus")
--   True
--   </pre>
isJust :: Maybe a -> Bool

-- | Check if a <a>Maybe</a> <tt>a</tt> is <tt>Nothing</tt>
--   
--   <pre>
--   &gt;&gt;&gt; isNothing Nothing
--   True
--   
--   &gt;&gt;&gt; isNothing (Just "plutus")
--   False
--   </pre>
isNothing :: Maybe a -> Bool

-- | Plutus Tx version of <a>maybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maybe "platypus" (\s -&gt; s) (Just "plutus")
--   "plutus"
--   
--   &gt;&gt;&gt; maybe "platypus" (\s -&gt; s) Nothing
--   "platypus"
--   </pre>
maybe :: b -> (a -> b) -> Maybe a -> b

-- | Plutus Tx version of <a>fromMaybe</a>
fromMaybe :: a -> Maybe a -> a

-- | Plutus Tx version of <a>mapMaybe</a>.
--   
--   <pre>
--   &gt;&gt;&gt; mapMaybe (\i -&gt; if i == 2 then Just '2' else Nothing) [1, 2, 3, 4]
--   "2"
--   </pre>
mapMaybe :: (a -> Maybe b) -> [a] -> [b]

module PlutusTx.Foldable

-- | Plutus Tx version of <a>Foldable</a>.
class Foldable t

-- | Plutus Tx version of <a>foldMap</a>.
foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m

-- | Plutus Tx version of <a>foldrM</a>.
foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- | Plutus Tx version of <a>foldlM</a>.
foldlM :: (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b

-- | Plutus Tx version of <a>traverse_</a>.
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()

-- | Plutus Tx version of <a>for_</a>.
for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()

-- | Plutus Tx version of <a>sequenceA_</a>.
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()

-- | Plutus Tx version of <a>sequence_</a>.
sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()

-- | Plutus Tx version of <a>asum</a>.
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Plutus Tx version of <a>mapM_</a>.
mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()

-- | Plutus Tx version of <a>concat</a>.
concat :: Foldable t => t [a] -> [a]

-- | Plutus Tx version of <a>concatMap</a>.
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]

-- | Plutus Tx version of <a>and</a>.
and :: Foldable t => t Bool -> Bool

-- | Plutus Tx version of <a>or</a>.
or :: Foldable t => t Bool -> Bool

-- | Plutus Tx version of <a>any</a>.
any :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Plutus Tx version of <a>all</a>.
all :: Foldable t => (a -> Bool) -> t a -> Bool

-- | Plutus Tx version of <a>notElem</a>.
notElem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | Plutus Tx version of <a>find</a>.
find :: Foldable t => (a -> Bool) -> t a -> Maybe a

-- | Plutus Tx version of <a>fold</a>.
fold :: (Foldable t, Monoid m) => t m -> m

-- | Plutus Tx version of <a>foldr</a>.
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b

-- | Plutus Tx version of <a>foldl</a>.
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b

-- | Plutus Tx version of <a>toList</a>.
toList :: Foldable t => t a -> [a]

-- | Plutus Tx version of <a>null</a>.
null :: Foldable t => t a -> Bool

-- | Plutus Tx version of <a>length</a>.
length :: Foldable t => t a -> Integer

-- | Plutus Tx version of <a>elem</a>.
elem :: (Foldable t, Eq a) => a -> t a -> Bool

-- | Plutus Tx version of <a>sum</a>.
sum :: (Foldable t, AdditiveMonoid a) => t a -> a

-- | Plutus Tx version of <a>product</a>.
product :: (Foldable t, MultiplicativeMonoid a) => t a -> a
instance PlutusTx.Foldable.Foldable []
instance PlutusTx.Foldable.Foldable GHC.Maybe.Maybe
instance PlutusTx.Foldable.Foldable (Data.Either.Either c)
instance PlutusTx.Foldable.Foldable ((,) c)
instance PlutusTx.Foldable.Foldable Data.Functor.Identity.Identity
instance PlutusTx.Foldable.Foldable (Data.Functor.Const.Const c)

module PlutusTx.Traversable

-- | Plutus Tx version of <a>Traversable</a>.
class (Functor t, Foldable t) => Traversable t

-- | Plutus Tx version of <a>traverse</a>.
traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Plutus Tx version of <a>sequenceA</a>.
sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Plutus Tx version of <a>mapM</a>.
mapM :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)

-- | Plutus Tx version of <a>sequence</a>.
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)

-- | Plutus Tx version of <a>for</a>.
for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)

-- | Plutus Tx version of <a>fmapDefault</a>.
fmapDefault :: forall t a b. Traversable t => (a -> b) -> t a -> t b

-- | Plutus Tx version of <a>foldMapDefault</a>.
foldMapDefault :: forall t m a. (Traversable t, Monoid m) => (a -> m) -> t a -> m
instance PlutusTx.Traversable.Traversable []
instance PlutusTx.Traversable.Traversable GHC.Maybe.Maybe
instance PlutusTx.Traversable.Traversable (Data.Either.Either c)
instance PlutusTx.Traversable.Traversable ((,) c)
instance PlutusTx.Traversable.Traversable Data.Functor.Identity.Identity
instance PlutusTx.Traversable.Traversable (Data.Functor.Const.Const c)

module PlutusTx.IsData.Class

-- | A typeclass for types that can be converted to and from <a>Data</a>.
class IsData (a :: Type)
toData :: IsData a => a -> Data
fromData :: IsData a => Data -> Maybe a
instance PlutusTx.IsData.Class.IsData PlutusTx.Data.Data
instance (TypeError ...) => PlutusTx.IsData.Class.IsData GHC.Types.Int
instance PlutusTx.IsData.Class.IsData GHC.Integer.Type.Integer
instance PlutusTx.IsData.Class.IsData Data.ByteString.Internal.ByteString
instance PlutusTx.IsData.Class.IsData a => PlutusTx.IsData.Class.IsData [a]
instance PlutusTx.IsData.Class.IsData Data.Void.Void

module PlutusTx.IsData

-- | Generate an <a>IsData</a> instance for a type. This may not be stable
--   in the face of constructor additions, renamings, etc. Use
--   <a>makeIsDataIndexed</a> if you need stability.
unstableMakeIsData :: Name -> Q [Dec]

-- | Generate an <a>IsData</a> instance for a type, using an explicit
--   mapping of constructor names to indices. Use this for types where you
--   need to keep the representation stable.
makeIsDataIndexed :: Name -> [(Name, Int)] -> Q [Dec]

module PlutusTx.Ratio
data Ratio a
type Rational = Ratio Integer

-- | Forms the ratio of two integral numbers.
(%) :: Integer -> Integer -> Ratio Integer
infixl 7 %

-- | Convert an <tt>Interger</tt> to a <a>Rational</a>
fromInteger :: Integer -> Ratio Integer

-- | Extract the numerator of the ratio in reduced form: the numerator and
--   denominator have no common factor and the denominator is positive.
numerator :: Ratio a -> a

-- | Extract the denominator of the ratio in reduced form: the numerator
--   and denominator have no common factor and the denominator is positive.
denominator :: Ratio a -> a

-- | From GHC.Real | <tt>round x</tt> returns the nearest integer to
--   <tt>x</tt>; the even integer if <tt>x</tt> is equidistant between two
--   integers
round :: Ratio Integer -> Integer

-- | truncate <tt>x</tt> returns the integer nearest <tt>x</tt> between
--   zero and <tt>x</tt>
truncate :: Ratio Integer -> Integer

-- | The function <a>properFraction</a> takes a real fractional number
--   <tt>x</tt> and returns a pair <tt>(n,f)</tt> such that <tt>x =
--   n+f</tt>, and:
--   
--   <ul>
--   <li><tt>n</tt> is an integral number with the same sign as <tt>x</tt>;
--   and</li>
--   <li><tt>f</tt> is a fraction with the same type and sign as
--   <tt>x</tt>, and with absolute value less than <tt>1</tt>.</li>
--   </ul>
--   
--   The default definitions of the <tt>ceiling</tt>, <tt>floor</tt>,
--   <a>truncate</a> and <a>round</a> functions are in terms of
--   <a>properFraction</a>.
properFraction :: Ratio Integer -> (Integer, Ratio Integer)

-- | Reciprocal fraction
recip :: Ratio Integer -> Ratio Integer

-- | <ol>
--   <li>5</li>
--   </ol>
half :: Ratio Integer

-- | Convert a <a>Rational</a> to a Plutus-compatible <a>Rational</a>
fromGHC :: Rational -> Ratio Integer

-- | Convert a <a>Rational</a> to a <a>Rational</a>
toGHC :: Rational -> Rational

-- | Simultaneous div and mod.
divMod :: Integer -> Integer -> (Integer, Integer)

-- | Simultaneous quot and rem.
quotRem :: Integer -> Integer -> (Integer, Integer)

-- | <tt><a>gcd</a> x y</tt> is the non-negative factor of both <tt>x</tt>
--   and <tt>y</tt> of which every common factor of <tt>x</tt> and
--   <tt>y</tt> is also a factor; for example <tt><a>gcd</a> 4 2 = 2</tt>,
--   <tt><a>gcd</a> (-4) 6 = 2</tt>, <tt><a>gcd</a> 0 4</tt> = <tt>4</tt>.
--   <tt><a>gcd</a> 0 0</tt> = <tt>0</tt>.
gcd :: Integer -> Integer -> Integer
abs :: (Ord n, AdditiveGroup n) => n -> n

-- | From GHC.Real | <a>reduce</a> is a subsidiary function used only in
--   this module. It normalises a ratio by dividing both numerator and
--   denominator by their greatest common divisor.
reduce :: Integer -> Integer -> Ratio Integer
instance PlutusTx.IsData.Class.IsData a => PlutusTx.IsData.Class.IsData (PlutusTx.Ratio.Ratio a)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.Ratio.Ratio
instance (PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni a, PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni a) => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusTx.Ratio.Ratio a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (PlutusTx.Ratio.Ratio a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (PlutusTx.Ratio.Ratio a)
instance GHC.Generics.Generic (PlutusTx.Ratio.Ratio a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (PlutusTx.Ratio.Ratio a)
instance GHC.Show.Show a => GHC.Show.Show (PlutusTx.Ratio.Ratio a)
instance GHC.Real.Integral a => GHC.Classes.Ord (PlutusTx.Ratio.Ratio a)
instance PlutusTx.Eq.Eq a => PlutusTx.Eq.Eq (PlutusTx.Ratio.Ratio a)
instance PlutusTx.Numeric.AdditiveSemigroup (PlutusTx.Ratio.Ratio GHC.Integer.Type.Integer)
instance PlutusTx.Numeric.AdditiveMonoid (PlutusTx.Ratio.Ratio GHC.Integer.Type.Integer)
instance PlutusTx.Numeric.AdditiveGroup (PlutusTx.Ratio.Ratio GHC.Integer.Type.Integer)
instance PlutusTx.Numeric.MultiplicativeSemigroup (PlutusTx.Ratio.Ratio GHC.Integer.Type.Integer)
instance PlutusTx.Numeric.MultiplicativeMonoid (PlutusTx.Ratio.Ratio GHC.Integer.Type.Integer)
instance PlutusTx.Ord.Ord (PlutusTx.Ratio.Ratio GHC.Integer.Type.Integer)

module PlutusTx

-- | <a>CompiledCodeIn</a> instantiated with default built-in types and
--   functions.
type CompiledCode = CompiledCodeIn DefaultUni DefaultFun

-- | A compiled Plutus Tx program. The last type parameter indicates the
--   type of the Haskell expression that was compiled, and hence the type
--   of the compiled code.
--   
--   Note: the compiled PLC program does *not* have normalized types, if
--   you want to put it on the chain you must normalize the types first.
data CompiledCodeIn uni fun a

-- | Get the actual Plutus Core program out of a <a>CompiledCodeIn</a>.
getPlc :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Program NamedDeBruijn uni fun ()

-- | Get the Plutus IR program, if there is one, out of a
--   <a>CompiledCodeIn</a>.
getPir :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun a -> Maybe (Program TyName Name uni fun ())

-- | Apply a compiled function to a compiled argument.
applyCode :: (Closed uni, uni `Everywhere` Flat, Flat fun) => CompiledCodeIn uni fun (a -> b) -> CompiledCodeIn uni fun a -> CompiledCodeIn uni fun b

-- | A generic "data" type.
--   
--   The main constructor <a>Constr</a> represents a datatype value in
--   sum-of-products form: <tt>Constr i args</tt> represents a use of the
--   <tt>i</tt>th constructor along with its arguments.
--   
--   The other constructors are various primitives.
data Data
Constr :: Integer -> [Data] -> Data
Map :: [(Data, Data)] -> Data
List :: [Data] -> Data
I :: Integer -> Data
B :: ByteString -> Data

-- | A typeclass for types that can be converted to and from <a>Data</a>.
class IsData (a :: Type)
toData :: IsData a => a -> Data
fromData :: IsData a => Data -> Maybe a

-- | Generate an <a>IsData</a> instance for a type. This may not be stable
--   in the face of constructor additions, renamings, etc. Use
--   <a>makeIsDataIndexed</a> if you need stability.
unstableMakeIsData :: Name -> Q [Dec]

-- | Generate an <a>IsData</a> instance for a type, using an explicit
--   mapping of constructor names to indices. Use this for types where you
--   need to keep the representation stable.
makeIsDataIndexed :: Name -> [(Name, Int)] -> Q [Dec]

-- | Class for types which can be lifted into Plutus IR. Instances should
--   be derived, do not write your own instance!
class Lift uni a

-- | Class for types which have a corresponding Plutus IR type. Instances
--   should always be derived, do not write your own instance!
class Typeable uni (a :: k)
makeLift :: Name -> Q [Dec]
safeLiftCode :: (Lift uni a, AsTypeError e (Term TyName Name uni fun ()) uni fun (Provenance ()), GEq uni, AsTypeErrorExt e uni (Provenance ()), AsFreeVariableError e, AsError e uni fun (Provenance ()), MonadError e m, MonadQuote m, Typecheckable uni fun) => a -> m (CompiledCodeIn uni fun a)

-- | Get a Plutus Core program corresponding to the given value as a
--   <a>CompiledCodeIn</a>, throwing any errors that occur as exceptions
--   and ignoring fresh names.
liftCode :: (Lift uni a, Throwable uni fun, Typecheckable uni fun) => a -> CompiledCodeIn uni fun a

module PlutusTx.Prelude

-- | Sequentially compose two actions, passing any value produced by the
--   first as an argument to the second.
--   
--   '<tt>as <a>&gt;&gt;=</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do a &lt;- as
--      bs a
--   </pre>
(>>=) :: Monad m => m a -> (a -> m b) -> m b
infixl 1 >>=

-- | Same as <a>&gt;&gt;=</a>, but with the arguments interchanged.
(=<<) :: Monad m => (a -> m b) -> m a -> m b
infixr 1 =<<

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b
infixl 1 >>

-- | Inject a value into the monadic type.
return :: Monad m => a -> m a

-- | Plutus Tx version of 'Data.Function.($)'.
($) :: (a -> b) -> a -> b
infixr 0 $

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c
infixr 9 .

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | <tt><a>until</a> p f</tt> yields the result of applying <tt>f</tt>
--   until <tt>p</tt> holds.
until :: (a -> Bool) -> (a -> a) -> a -> a

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; flip (++) "hello" "world"
--   "worldhello"
--   </pre>
flip :: (a -> b -> c) -> b -> a -> c

-- | Emit the given string as a trace message before evaluating the
--   argument.
trace :: String -> a -> a

-- | Emit the given <a>String</a> only if the argument evaluates to
--   <a>True</a>.
traceIfTrue :: String -> Bool -> Bool

-- | Emit the given <a>String</a> only if the argument evaluates to
--   <a>False</a>.
traceIfFalse :: String -> Bool -> Bool

-- | Log a message and then terminate the evaluation with an error.
traceError :: String -> a

-- | Terminate the evaluation of the script with an error message.
error :: () -> a

-- | Checks a <a>Bool</a> and aborts if it is false.
check :: Bool -> ()

-- | Arbitrary precision integers. In contrast with fixed-size integral
--   types such as <a>Int</a>, the <a>Integer</a> type represents the
--   entire infinite range of integers.
--   
--   For more information about this type's representation, see the
--   comments in its implementation.
data Integer

-- | Integer division, rounding downwards
--   
--   <pre>
--   &gt;&gt;&gt; divide (-41) 5
--   -9
--   </pre>
divide :: Integer -> Integer -> Integer

-- | Integer remainder, always positive for a positive divisor
--   
--   <pre>
--   &gt;&gt;&gt; modulo (-41) 5
--   4
--   </pre>
modulo :: Integer -> Integer -> Integer

-- | Integer division, rouding towards zero
--   
--   <pre>
--   &gt;&gt;&gt; quotient (-41) 5
--   -8
--   </pre>
quotient :: Integer -> Integer -> Integer

-- | Integer remainder, same sign as dividend
--   
--   <pre>
--   &gt;&gt;&gt; remainder (-41) 5
--   -1
--   </pre>
remainder :: Integer -> Integer -> Integer
even :: Integral a => a -> Bool

-- | Plutus Tx version of <a>fst</a>
fst :: (a, b) -> a

-- | Plutus Tx version of <a>snd</a>
snd :: (a, b) -> b

-- | Plutus Tx version of <a>map</a>.
--   
--   <pre>
--   &gt;&gt;&gt; map (\i -&gt; i + 1) [1, 2, 3]
--   [2,3,4]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | Plutus Tx version of <a>(++)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [0, 1, 2] ++ [1, 2, 3, 4]
--   [0,1,2,1,2,3,4]
--   </pre>
(++) :: [a] -> [a] -> [a]
infixr 5 ++

-- | Plutus Tx version of <a>filter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; filter (&gt; 1) [1, 2, 3, 4]
--   [2,3,4]
--   </pre>
filter :: (a -> Bool) -> [a] -> [a]

-- | Plutus Tx version of <a>listToMaybe</a>.
listToMaybe :: [a] -> Maybe a

-- | Return the element in the list, if there is precisely one.
uniqueElement :: [a] -> Maybe a

-- | Plutus Tx version of <a>findIndices</a>.
findIndices :: (a -> Bool) -> [a] -> [Integer]

-- | Plutus Tx version of <a>findIndex</a>.
findIndex :: (a -> Bool) -> [a] -> Maybe Integer

-- | Plutus Tx version of <a>(!!)</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [10, 11, 12] !! 2
--   12
--   </pre>
(!!) :: [a] -> Integer -> a
infixl 9 !!

-- | Plutus Tx version of <a>reverse</a>.
reverse :: [a] -> [a]

-- | Plutus Tx version of <a>zip</a>.
zip :: [a] -> [b] -> [(a, b)]

-- | Plutus Tx version of <a>head</a>.
head :: [a] -> a

-- | Plutus Tx version of <a>tail</a>.
tail :: [a] -> [a]

-- | Plutus Tx version of <a>take</a>.
take :: Integer -> [a] -> [a]

-- | Plutus Tx version of <a>nub</a>.
nub :: Eq a => [a] -> [a]

-- | Plutus Tx version of <a>nubBy</a>.
nubBy :: (a -> a -> Bool) -> [a] -> [a]

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>:
--   
--   <pre>
--   dropWhile (&lt; 3) [1,2,3,4,5,1,2,3] == [3,4,5,1,2,3]
--   dropWhile (&lt; 9) [1,2,3] == []
--   dropWhile (&lt; 0) [1,2,3] == [1,2,3]
--   </pre>
dropWhile :: (a -> Bool) -> [a] -> [a]

-- | &lt;math&gt;. <a>zipWith</a> generalises <a>zip</a> by zipping with
--   the function given as the first argument, instead of a tupling
--   function. For example, <tt><a>zipWith</a> (+)</tt> is applied to two
--   lists to produce the list of corresponding sums:
--   
--   <pre>
--   &gt;&gt;&gt; zipWith (+) [1, 2, 3] [4, 5, 6]
--   [5,7,9]
--   </pre>
--   
--   <a>zipWith</a> is right-lazy:
--   
--   <pre>
--   zipWith f [] _|_ = []
--   </pre>
--   
--   <a>zipWith</a> is capable of list fusion, but it is restricted to its
--   first list argument and its resulting list.
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString

-- | Returns the n length prefix of a <a>ByteString</a>.
takeByteString :: Integer -> ByteString -> ByteString

-- | Returns the suffix of a <a>ByteString</a> after n elements.
dropByteString :: Integer -> ByteString -> ByteString

-- | Concatenates two <a>ByteString</a>s.
concatenate :: ByteString -> ByteString -> ByteString

-- | An empty <a>ByteString</a>.
emptyByteString :: ByteString

-- | The SHA2-256 hash of a <a>ByteString</a>
sha2_256 :: ByteString -> ByteString

-- | The SHA3-256 hash of a <a>ByteString</a>
sha3_256 :: ByteString -> ByteString

-- | Verify that the signature is a signature of the message by the public
--   key.
verifySignature :: ByteString -> ByteString -> ByteString -> Bool
type Rational = Ratio Integer

-- | Forms the ratio of two integral numbers.
(%) :: Integer -> Integer -> Ratio Integer
infixl 7 %

-- | Convert an <tt>Interger</tt> to a <a>Rational</a>
fromInteger :: Integer -> Ratio Integer

-- | From GHC.Real | <tt>round x</tt> returns the nearest integer to
--   <tt>x</tt>; the even integer if <tt>x</tt> is equidistant between two
--   integers
round :: Ratio Integer -> Integer

-- | Simultaneous div and mod.
divMod :: Integer -> Integer -> (Integer, Integer)

-- | Simultaneous quot and rem.
quotRem :: Integer -> Integer -> (Integer, Integer)

module PlutusTx.Sqrt

-- | Integer square-root representation, discarding imaginary integers.
data Sqrt

-- | The number was negative, so we don't even attempt to compute it; just
--   note that the result would be imaginary.
Imaginary :: Sqrt

-- | An exact integer result. The <a>rsqrt</a> of 4 is 'Exactly 2'.
Exactly :: Integer -> Sqrt

-- | The Integer component (i.e. the floor) of a non-integral result. The
--   'rsqrt 2' is 'Approximately 1'.
Approximately :: Integer -> Sqrt

-- | Calculates the sqrt of a ratio of integers. As x / 0 is undefined,
--   calling this function with `d=0` results in an error.
rsqrt :: Rational -> Sqrt

-- | Calculates the integer-component of the sqrt of <tt>n</tt>.
isqrt :: Integer -> Sqrt
instance PlutusTx.IsData.Class.IsData PlutusTx.Sqrt.Sqrt
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.Sqrt.Sqrt
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni PlutusTx.Sqrt.Sqrt
instance GHC.Classes.Eq PlutusTx.Sqrt.Sqrt
instance GHC.Show.Show PlutusTx.Sqrt.Sqrt


-- | A map represented as an "association list" of key-value pairs.
module PlutusTx.AssocMap

-- | A <a>Map</a> of key-value pairs.
data Map k v

-- | A singleton map.
singleton :: k -> v -> Map k v

-- | An empty <a>Map</a>.
empty :: Map k v

-- | Is the map empty?
null :: Map k v -> Bool
fromList :: [(k, v)] -> Map k v
toList :: Map k v -> [(k, v)]

-- | The keys of a <a>Map</a>.
keys :: Map k v -> [k]

-- | Find an entry in a <a>Map</a>.
lookup :: forall k v. Eq k => k -> Map k v -> Maybe v

-- | Is the key a member of the map?
member :: forall k v. Eq k => k -> Map k v -> Bool
insert :: forall k v. Eq k => k -> v -> Map k v -> Map k v
delete :: forall k v. Eq k => k -> Map k v -> Map k v

-- | Combine two <a>Map</a>s.
union :: forall k v r. Eq k => Map k v -> Map k r -> Map k (These v r)

-- | See <a>all</a>
all :: (v -> Bool) -> Map k v -> Bool

-- | A version of <a>mapEither</a> that works with <a>These</a>.
mapThese :: (v -> These a b) -> Map k v -> (Map k a, Map k b)
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni PlutusTx.AssocMap.Map
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni [(k, v)] => PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni (PlutusTx.AssocMap.Map k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.IsData.Class.IsData k, PlutusTx.IsData.Class.IsData v) => PlutusTx.IsData.Class.IsData (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Ord.Ord k, PlutusTx.Ord.Ord v) => PlutusTx.Ord.Ord (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Eq.Eq k, PlutusTx.Eq.Eq v) => PlutusTx.Eq.Eq (PlutusTx.AssocMap.Map k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (PlutusTx.AssocMap.Map k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (PlutusTx.AssocMap.Map k v)
instance GHC.Generics.Generic (PlutusTx.AssocMap.Map k v)
instance PlutusTx.Functor.Functor (PlutusTx.AssocMap.Map k)
instance PlutusTx.Foldable.Foldable (PlutusTx.AssocMap.Map k)
instance PlutusTx.Traversable.Traversable (PlutusTx.AssocMap.Map k)
instance (PlutusTx.Eq.Eq k, PlutusTx.Semigroup.Semigroup v) => PlutusTx.Semigroup.Semigroup (PlutusTx.AssocMap.Map k v)
instance (PlutusTx.Eq.Eq k, PlutusTx.Semigroup.Semigroup v) => PlutusTx.Monoid.Monoid (PlutusTx.AssocMap.Map k v)
