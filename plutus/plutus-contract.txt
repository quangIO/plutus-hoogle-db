-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus#readme</a>
@package plutus-contract
@version 0.1.0.0


-- | Instances for <a>Rec</a> and <a>Var</a> types
module Data.Row.Extras
newtype JsonRec s
JsonRec :: Rec s -> JsonRec s
[unJsonRec] :: JsonRec s -> Rec s
newtype JsonVar s
JsonVar :: Var s -> JsonVar s
[unJsonVar] :: JsonVar s -> Var s

-- | Parse a 'Var s' from JSON if the label of the branch is known.
namedBranchFromJSON :: forall s. (AllUniqueLabels s, Forall s FromJSON) => String -> Value -> Parser (Var s)

-- | Fast diff. The implementation in row-types is exponential in time and
--   memory in the number of overlapping rows, due to limitations in ghc's
--   handling of type families. This version is much faster.
--   
--   Type level Row difference. That is, <tt>l <a>.\\</a> r</tt> is the row
--   remaining after removing any matching elements of <tt>r</tt> from
--   <tt>l</tt>.
type family (l :: Row k) .\\ (r :: Row k) :: Row k
infixl 6 .\\
instance Data.Row.Internal.Forall s Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Data.Row.Extras.JsonRec s)
instance (Data.Row.Internal.AllUniqueLabels s, Data.Row.Internal.Forall s Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Data.Row.Extras.JsonRec s)
instance (Data.Row.Internal.AllUniqueLabels s, Data.Row.Internal.Forall s Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Data.Row.Extras.JsonVar s)
instance Data.Row.Internal.Forall s Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Data.Row.Extras.JsonVar s)

module Data.Text.Extras
abbreviate :: Int -> Text -> Text
tshow :: Show a => a -> Text

module Data.UUID.Extras
isValidVersion :: Int -> UUID -> Bool

-- | A pure list of UUIDs that can be used in testing. This is _almost_ a
--   sequence counting up from zero, but we ensure that the version and
--   variant numbers are correctly set so the resulting UUIDs validate.
mockUUIDs :: [UUID]

-- | Given a UUID from <a>mockUUIDs</a>, returns a simple sequence number.
--   Returns <a>Nothing</a> if your UUID doesn't seem to come from that
--   sequence. As the name suggests, you should really only be using this
--   for mocking/testing.
mockUUIDToSequenceId :: UUID -> Maybe Word32

-- | Create a UUID that can be used in testing, from a simple
--   <a>Word32</a>. Reminder: Use 'fromIntegral i' to call it with an
--   <a>Int</a>.
sequenceIdToMockUUID :: Word32 -> UUID

module Plutus.Contract.Checkpoint
data Checkpoint r
[DoCheckpoint] :: Checkpoint ()
[AllocateKey] :: Checkpoint CheckpointKey
[Store] :: ToJSON a => CheckpointKey -> CheckpointKey -> a -> Checkpoint ()
[Retrieve] :: FromJSON a => CheckpointKey -> Checkpoint (Either CheckpointError (Maybe a))
data CheckpointError
JSONDecodeError :: Text -> CheckpointError
class AsCheckpointError r_aooT
_CheckpointError :: AsCheckpointError r_aooT => Prism' r_aooT CheckpointError
_JSONDecodeError :: AsCheckpointError r_aooT => Prism' r_aooT Text
newtype CheckpointStore
CheckpointStore :: Map CheckpointKey (CheckpointStoreItem Value) -> CheckpointStore
[unCheckpointStore] :: CheckpointStore -> Map CheckpointKey (CheckpointStoreItem Value)
data CheckpointStoreItem a
CheckpointStoreItem :: a -> CheckpointKey -> CheckpointStoreItem a
[csValue] :: CheckpointStoreItem a -> a
[csNewKey] :: CheckpointStoreItem a -> CheckpointKey
data CheckpointKey
data CheckpointLogMsg
LogFoundValueRestoringKey :: CheckpointKey -> CheckpointLogMsg
LogDecodingErrorAtKey :: CheckpointKey -> CheckpointLogMsg
LogNoValueForKey :: CheckpointKey -> CheckpointLogMsg
LogDoCheckpoint :: CheckpointLogMsg
LogAllocateKey :: CheckpointLogMsg
LogRetrieve :: CheckpointKey -> CheckpointLogMsg
LogStore :: CheckpointKey -> CheckpointKey -> CheckpointLogMsg
LogKeyUpdate :: CheckpointKey -> CheckpointKey -> CheckpointLogMsg

-- | Create a checkpoint for an action. <tt>handleCheckpoint
--   (jsonCheckpoint action)</tt> will
--   
--   <ul>
--   <li>Obtain a <a>CheckpointKey</a> that identifies the position of the
--   current checkpoint in the program</li>
--   <li>Run <tt>action</tt>, convert its result to JSON and store it in
--   the checkpoint store if there is no value at the key</li>
--   <li>Retrieve the result as a JSON value from the store, parse it, and
--   return it *instead* of running <tt>action</tt> if there is a value at
--   the key.</li>
--   </ul>
jsonCheckpoint :: forall err a effs. (Member Checkpoint effs, Member (Error err) effs, ToJSON a, FromJSON a, AsCheckpointError err) => Eff effs a -> Eff effs a
jsonCheckpointLoop :: forall err a b effs. (Member Checkpoint effs, Member (Error err) effs, ToJSON a, FromJSON a, ToJSON b, FromJSON b, AsCheckpointError err) => (a -> Eff effs (Either b a)) -> a -> Eff effs b

-- | Handle the <a>Checkpoint</a> effect in terms of <a>CheckpointStore</a>
--   and <a>CheckpointKey</a> states.
handleCheckpoint :: forall effs. (Member (State CheckpointStore) effs, Member (State CheckpointKey) effs, Member (LogMsg CheckpointLogMsg) effs) => Eff (Checkpoint : effs) ~> Eff effs

-- | Intervals of checkpoint keys that are completely covered by the
--   checkpoint store.
completedIntervals :: CheckpointStore -> IntervalSet (Interval CheckpointKey)

-- | The maximum key that is present in the store
maxKey :: CheckpointStore -> Maybe CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance Data.Traversable.Traversable Plutus.Contract.Checkpoint.CheckpointStoreItem
instance Data.Foldable.Foldable Plutus.Contract.Checkpoint.CheckpointStoreItem
instance GHC.Base.Functor Plutus.Contract.Checkpoint.CheckpointStoreItem
instance GHC.Generics.Generic (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Plutus.Contract.Checkpoint.CheckpointStoreItem a)
instance GHC.Base.Monoid Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Base.Semigroup Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointStore
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointStore
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointLogMsg
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointLogMsg
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointStore
instance Plutus.Contract.Checkpoint.AsCheckpointError Plutus.Contract.Checkpoint.CheckpointError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Enum.Enum Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Num.Num Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointKey
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointKey
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Checkpoint.CheckpointError
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Generics.Generic Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Show.Show Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Classes.Ord Plutus.Contract.Checkpoint.CheckpointError
instance GHC.Classes.Eq Plutus.Contract.Checkpoint.CheckpointError
instance Prettyprinter.Internal.Pretty Plutus.Contract.Checkpoint.CheckpointError

module Plutus.Contract.Constraints

module Plutus.Contract.Resumable

-- | A data type for representing non-deterministic prompts.
data Resumable i o r
[RRequest] :: o -> Resumable i o i
[RSelect] :: Resumable i o Bool
prompt :: Member (Resumable i o) effs => o -> Eff effs i
select :: forall i o effs a. Member (Resumable i o) effs => Eff effs a -> Eff effs a -> Eff effs a
data Request o
Request :: RequestID -> IterationID -> o -> Request o
[rqID] :: Request o -> RequestID
[itID] :: Request o -> IterationID
[rqRequest] :: Request o -> o
data Response i
Response :: RequestID -> IterationID -> i -> Response i
[rspRqID] :: Response i -> RequestID
[rspItID] :: Response i -> IterationID
[rspResponse] :: Response i -> i

-- | A value that uniquely identifies requests made during the execution of
--   <a>Resumable</a> programs.
newtype RequestID
RequestID :: Natural -> RequestID

-- | A value that uniquely identifies groups of requests.
newtype IterationID
IterationID :: Natural -> IterationID
newtype Requests o
Requests :: [Request o] -> Requests o
[unRequests] :: Requests o -> [Request o]
type ResumableEffs i o effs a = NonDet : State IterationID : State RequestID : State (ReqMap i o effs a) : State (Requests o) : effs
newtype Responses i
Responses :: Map (IterationID, RequestID) i -> Responses i
[unResponses] :: Responses i -> Map (IterationID, RequestID) i
insertResponse :: Response i -> Responses i -> Responses i

-- | A list of all responses ordered by iteration and request ID
responses :: Responses i -> [Response i]
_Responses :: forall i. Iso' (Responses i) (Map (IterationID, RequestID) i)

-- | Interpret the <a>Resumable</a> effect in terms of the <a>Yield</a> and
--   <a>NonDet</a> effects.
handleResumable :: forall i o effs. (Member (Yield o i) effs, Member NonDet effs) => Eff (Resumable i o : effs) ~> Eff effs

-- | Interpret <a>Yield</a> as a prompt-type effect using <a>NonDet</a> to
--   branch out and choose a branch, and the <a>State</a> effects to keep
--   track of request IDs.
suspendNonDet :: forall i o a effs. Eff (Yield o i : ResumableEffs i o effs a) a -> Eff effs (Maybe (MultiRequestContStatus i o effs a))

-- | Status of a suspended <a>MultiRequestContinuation</a>.
data MultiRequestContStatus i o effs a

-- | Done
AResult :: a -> MultiRequestContStatus i o effs a

-- | Waiting for inputs
AContinuation :: MultiRequestContinuation i o effs a -> MultiRequestContStatus i o effs a

-- | A continuation that accepts a response to one of several requests.
data MultiRequestContinuation i o effs a
MultiRequestContinuation :: (Response i -> Eff effs (Maybe (MultiRequestContStatus i o effs a))) -> Requests o -> MultiRequestContinuation i o effs a

-- | Continuation for the response
[ndcCont] :: MultiRequestContinuation i o effs a -> Response i -> Eff effs (Maybe (MultiRequestContStatus i o effs a))

-- | The list of all open requests.
[ndcRequests] :: MultiRequestContinuation i o effs a -> Requests o

-- | A map of requests to continuations. For each request, identified by a
--   pair of <a>RequestID</a> and <a>IterationID</a>, <a>ReqMap</a>
--   contains the continuation that takes the response to the request.
newtype ReqMap i o effs a
ReqMap :: Map (RequestID, IterationID) (i -> Eff (ResumableEffs i o effs a) a) -> ReqMap i o effs a
[unReqMap] :: ReqMap i o effs a -> Map (RequestID, IterationID) (i -> Eff (ResumableEffs i o effs a) a)
instance GHC.Num.Num Plutus.Contract.Resumable.RequestID
instance GHC.Enum.Enum Plutus.Contract.Resumable.RequestID
instance Prettyprinter.Internal.Pretty Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Resumable.RequestID
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Resumable.RequestID
instance GHC.Generics.Generic Plutus.Contract.Resumable.RequestID
instance GHC.Show.Show Plutus.Contract.Resumable.RequestID
instance GHC.Classes.Ord Plutus.Contract.Resumable.RequestID
instance GHC.Classes.Eq Plutus.Contract.Resumable.RequestID
instance GHC.Base.Semigroup Plutus.Contract.Resumable.IterationID
instance GHC.Num.Num Plutus.Contract.Resumable.IterationID
instance GHC.Enum.Enum Plutus.Contract.Resumable.IterationID
instance Prettyprinter.Internal.Pretty Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSONKey Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.ToJSON.ToJSONKey Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Resumable.IterationID
instance GHC.Generics.Generic Plutus.Contract.Resumable.IterationID
instance GHC.Show.Show Plutus.Contract.Resumable.IterationID
instance GHC.Classes.Ord Plutus.Contract.Resumable.IterationID
instance GHC.Classes.Eq Plutus.Contract.Resumable.IterationID
instance Data.Aeson.Types.FromJSON.FromJSON o => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Request o)
instance Data.Aeson.Types.ToJSON.ToJSON o => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Request o)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Request
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Request
instance GHC.Base.Functor Plutus.Contract.Resumable.Request
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Request o)
instance GHC.Show.Show o => GHC.Show.Show (Plutus.Contract.Resumable.Request o)
instance GHC.Classes.Ord o => GHC.Classes.Ord (Plutus.Contract.Resumable.Request o)
instance GHC.Classes.Eq o => GHC.Classes.Eq (Plutus.Contract.Resumable.Request o)
instance Data.Aeson.Types.FromJSON.FromJSON i => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Response i)
instance Data.Aeson.Types.ToJSON.ToJSON i => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Response i)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Response
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Response
instance GHC.Base.Functor Plutus.Contract.Resumable.Response
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Response i)
instance GHC.Show.Show i => GHC.Show.Show (Plutus.Contract.Resumable.Response i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Plutus.Contract.Resumable.Response i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Plutus.Contract.Resumable.Response i)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Requests
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Requests
instance GHC.Base.Functor Plutus.Contract.Resumable.Requests
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Requests o)
instance Data.Aeson.Types.FromJSON.FromJSON o => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Requests o)
instance Data.Aeson.Types.ToJSON.ToJSON o => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Requests o)
instance GHC.Base.Monoid (Plutus.Contract.Resumable.Requests o)
instance GHC.Base.Semigroup (Plutus.Contract.Resumable.Requests o)
instance GHC.Show.Show o => GHC.Show.Show (Plutus.Contract.Resumable.Requests o)
instance GHC.Classes.Ord o => GHC.Classes.Ord (Plutus.Contract.Resumable.Requests o)
instance GHC.Classes.Eq o => GHC.Classes.Eq (Plutus.Contract.Resumable.Requests o)
instance Data.Traversable.Traversable Plutus.Contract.Resumable.Responses
instance Data.Foldable.Foldable Plutus.Contract.Resumable.Responses
instance GHC.Base.Functor Plutus.Contract.Resumable.Responses
instance GHC.Generics.Generic (Plutus.Contract.Resumable.Responses i)
instance Data.Aeson.Types.FromJSON.FromJSON i => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Resumable.Responses i)
instance Data.Aeson.Types.ToJSON.ToJSON i => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Resumable.Responses i)
instance GHC.Base.Monoid (Plutus.Contract.Resumable.Responses i)
instance GHC.Base.Semigroup (Plutus.Contract.Resumable.Responses i)
instance GHC.Show.Show i => GHC.Show.Show (Plutus.Contract.Resumable.Responses i)
instance GHC.Classes.Ord i => GHC.Classes.Ord (Plutus.Contract.Resumable.Responses i)
instance GHC.Classes.Eq i => GHC.Classes.Eq (Plutus.Contract.Resumable.Responses i)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Responses i)
instance Prettyprinter.Internal.Pretty o => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Requests o)
instance Prettyprinter.Internal.Pretty i => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Response i)
instance Prettyprinter.Internal.Pretty o => Prettyprinter.Internal.Pretty (Plutus.Contract.Resumable.Request o)
instance GHC.Base.Monoid Plutus.Contract.Resumable.IterationID

module Plutus.Contract.Schema
newtype Handlers s
Handlers :: Var (Output s) -> Handlers s
[unHandlers] :: Handlers s -> Var (Output s)
handlerName :: Forall (Output s) Unconstrained1 => Handlers s -> String
handlerArgument :: Forall (Output s) ToJSON => Handlers s -> Value
newtype Event s
Event :: Var (Input s) -> Event s
[unEvent] :: Event s -> Var (Input s)
eventName :: Forall (Input s) Unconstrained1 => Event s -> String
initialise :: forall (s :: Row *) l a. (KnownSymbol l, AllUniqueLabels (Output s), HasType l a (Output s)) => a -> Handlers s
type family Input (r :: Row *)
type family Output (r :: Row *)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) GHC.Show.Show => GHC.Show.Show (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) GHC.Classes.Eq => GHC.Classes.Eq (Plutus.Contract.Schema.Event s)
instance (Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Input s), Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Schema.Event s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Schema.Handlers s)
instance (Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Output s), Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.FromJSON.FromJSON) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) GHC.Show.Show => GHC.Show.Show (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) GHC.Classes.Eq => GHC.Classes.Eq (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Prettyprinter.Internal.Pretty => Prettyprinter.Internal.Pretty (Plutus.Contract.Schema.Handlers s)
instance Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Prettyprinter.Internal.Pretty => Prettyprinter.Internal.Pretty (Plutus.Contract.Schema.Event s)


-- | On-chain code fragments for creating a state machine. First define a
--   <tt>StateMachine s i</tt> with input type <tt>i</tt> and state type
--   <tt>s</tt>. Then use <a>mkValidator</a> in on-chain code to check the
--   required hashes and validate the transition, and <tt>mkRedeemer</tt>
--   to make redeemer scripts.
module Plutus.Contract.StateMachine.OnChain

-- | Specification of a state machine, consisting of a transition function
--   that determines the next state from the current state and an input,
--   and a checking function that checks the validity of the transition in
--   the context of the current transaction.
data StateMachine s i
StateMachine :: (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> (s -> i -> ScriptContext -> Bool) -> Maybe AssetClass -> StateMachine s i

-- | The transition function of the state machine. <a>Nothing</a> indicates
--   an invalid transition from the current state.
[smTransition] :: StateMachine s i -> State s -> i -> Maybe (TxConstraints Void Void, State s)

-- | Check whether a state is the final state
[smFinal] :: StateMachine s i -> s -> Bool

-- | The condition checking function. Can be used to perform checks on the
--   pending transaction that aren't covered by the constraints.
--   <a>smCheck</a> is always run in addition to checking the constraints,
--   so the default implementation always returns true.
[smCheck] :: StateMachine s i -> s -> i -> ScriptContext -> Bool

-- | The <a>AssetClass</a> of the thread token that identifies the contract
--   instance.
[smThreadToken] :: StateMachine s i -> Maybe AssetClass
data StateMachineInstance s i
StateMachineInstance :: StateMachine s i -> TypedValidator (StateMachine s i) -> StateMachineInstance s i

-- | The state machine specification.
[stateMachine] :: StateMachineInstance s i -> StateMachine s i

-- | The validator code for this state machine.
[typedValidator] :: StateMachineInstance s i -> TypedValidator (StateMachine s i)
data State s
State :: s -> Value -> State s
[stateData] :: State s -> s
[stateValue] :: State s -> Value

-- | A state machine that does not perform any additional checks on the
--   <a>ScriptContext</a> (beyond enforcing the constraints)
mkStateMachine :: Maybe AssetClass -> (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> StateMachine s i
machineAddress :: StateMachineInstance s i -> Address

-- | Turn a state machine into a validator script.
mkValidator :: forall s i. IsData s => StateMachine s i -> ValidatorType (StateMachine s i)

-- | The <a>Value</a> containing exactly the thread token, if one has been
--   specified.
threadTokenValue :: StateMachine s i -> Value
instance Data.Aeson.Types.FromJSON.FromJSON s => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.OnChain.State s)
instance Data.Aeson.Types.ToJSON.ToJSON s => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Show.Show s => GHC.Show.Show (Plutus.Contract.StateMachine.OnChain.State s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Plutus.Contract.StateMachine.OnChain.State s)
instance Ledger.Typed.Scripts.Validators.ValidatorTypes (Plutus.Contract.StateMachine.OnChain.StateMachine s i)


-- | Functions for working with the contract interface using typed
--   transactions.
module Plutus.Contract.Typed.Tx

-- | Given the pay to script address of the <tt>Validator</tt>, collect
--   from it all the outputs that match a predicate, using the
--   <tt>RedeemerValue</tt>.
collectFromScriptFilter :: forall i o. (TxOutRef -> TxOutTx -> Bool) -> Map TxOutRef TxOutTx -> i -> TxConstraints i o

-- | A version of <a>collectFromScript</a> that selects all outputs at the
--   address
collectFromScript :: forall i o. Map TxOutRef TxOutTx -> i -> TxConstraints i o

module Plutus.Contract.Tx

-- | A set of constraints for a transaction that collects script outputs
--   from the address of the given validator script, using the same
--   redeemer script for all outputs.
collectFromScript :: AddressMap -> Validator -> Redeemer -> UntypedConstraints

-- | See
collectFromScriptFilter :: (TxOutRef -> TxOutTx -> Bool) -> AddressMap -> Validator -> Redeemer -> UntypedConstraints

module Plutus.Contract.Util

-- | A monadic version of <tt>loop</tt>, where the predicate returns
--   <a>Left</a> as a seed for the next loop or <a>Right</a> to abort the
--   loop.
--   
--   
--   <a>https://hackage.haskell.org/package/extra-1.6.15/docs/src/Control.Monad.Extra.html#loopM</a>
loopM :: Monad m => (a -> m (Either a b)) -> a -> m b

-- | Repeatedly evaluate the action until it yields <a>Nothing</a>, then
--   return the aggregated result.
foldMaybe :: Monad m => (a -> b -> b) -> b -> m (Maybe a) -> m b

-- | Monadic version of <a>&lt;*</a>
finally :: Monad m => m a -> m b -> m a
uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d

module Plutus.Trace.Tag

-- | A human-readable piece of data, used to identify threads and contract
--   instances. See note [Thread Tag]
newtype Tag
Tag :: Text -> Tag
[unTag] :: Tag -> Text
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Tag.Tag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Tag.Tag
instance Data.String.IsString Plutus.Trace.Tag.Tag
instance GHC.Generics.Generic Plutus.Trace.Tag.Tag
instance GHC.Show.Show Plutus.Trace.Tag.Tag
instance GHC.Classes.Ord Plutus.Trace.Tag.Tag
instance GHC.Classes.Eq Plutus.Trace.Tag.Tag
instance Prettyprinter.Internal.Pretty Plutus.Trace.Tag.Tag

module Plutus.Trace.Scheduler

-- | Unique identifier of a thread.
data ThreadId
type SysCall effs systemEvent = Either (MessageCall systemEvent) (ThreadCall effs systemEvent)

-- | Sending messages to other threads and waiting for new messages to
--   arrive.
data MessageCall systemEvent

-- | Suspend ourselves (the caller) until we receive a message
WaitForMessage :: MessageCall systemEvent

-- | Send a message to all threads
Broadcast :: systemEvent -> MessageCall systemEvent

-- | Send a message to a specific thread
Message :: ThreadId -> systemEvent -> MessageCall systemEvent

-- | The system calls we can make to the scheduler, affecting the the
--   threads that are currently running.
data ThreadCall effs systemEvent

-- | Start a new thread with a new thread ID.
Fork :: (ThreadId -> SuspendedThread effs systemEvent) -> ThreadCall effs systemEvent

-- | Unfreeze a thread.
Thaw :: ThreadId -> ThreadCall effs systemEvent

-- | Terminate the scheduler.
Exit :: ThreadCall effs systemEvent

-- | A thread with a <a>Priority</a>.
data WithPriority t
WithPriority :: Priority -> t -> WithPriority t
[_priority] :: WithPriority t -> Priority
[_thread] :: WithPriority t -> t

-- | Priority of a thread.
data Priority

-- | Thread is ready to run
Normal :: Priority

-- | Thread is sleeping, to be resumed only after an external event happens
Sleeping :: Priority

-- | Thread is frozen, it will only be resumed after it is manually
--   unfrozen via the <a>Thaw</a> sys call.
Frozen :: Priority

-- | A human-readable piece of data, used to identify threads and contract
--   instances. See note [Thread Tag]
data Tag
type EmSystemCall effs systemEvent = WithPriority (SysCall effs systemEvent)
type AgentSystemCall systemEvent = WithPriority (MessageCall systemEvent)
type SuspendedThread effs systemEvent = WithPriority (EmThread effs systemEvent)

-- | Thread that can be run by the scheduler
data EmThread effs systemEvent
EmThread :: (Maybe systemEvent -> Eff effs (Status effs (EmSystemCall effs systemEvent) (Maybe systemEvent) ())) -> ThreadId -> Tag -> EmThread effs systemEvent

-- | The continuation to be run when the thread is resumed.
[_continuation] :: EmThread effs systemEvent -> Maybe systemEvent -> Eff effs (Status effs (EmSystemCall effs systemEvent) (Maybe systemEvent) ())

-- | Thread ID
[_threadId] :: EmThread effs systemEvent -> ThreadId

-- | Tag of the thread. See note [Thread Tag]
[_tag] :: EmThread effs systemEvent -> Tag

-- | Scheduler state
data SchedulerState effs systemEvent
SchedulerState :: Seq (EmThread effs systemEvent) -> Seq (EmThread effs systemEvent) -> Seq (EmThread effs systemEvent) -> ThreadId -> HashMap ThreadId (Seq systemEvent) -> Map Tag (HashSet ThreadId) -> SchedulerState effs systemEvent

-- | Threads running at normal priority
[_normalPrio] :: SchedulerState effs systemEvent -> Seq (EmThread effs systemEvent)

-- | Sleeping threads (waiting for an external event)
[_sleeping] :: SchedulerState effs systemEvent -> Seq (EmThread effs systemEvent)

-- | Frozen threads (will not be resumed until they are explicitly
--   unfrozen)
[_frozen] :: SchedulerState effs systemEvent -> Seq (EmThread effs systemEvent)

-- | Last thread id assigned to a thread
[_lastThreadId] :: SchedulerState effs systemEvent -> ThreadId

-- | The mailboxes of all active threads.
[_mailboxes] :: SchedulerState effs systemEvent -> HashMap ThreadId (Seq systemEvent)

-- | Map of tags to thread IDs. See note [Thread Tag]
[_activeThreads] :: SchedulerState effs systemEvent -> Map Tag (HashSet ThreadId)

-- | Handle the 'Yield (EmSystemCall effs systemEvent) (Maybe systemEvent)'
--   effect using the scheduler, see note [Scheduler]. <a>runThreads</a>
--   only returns when all threads are finished.
runThreads :: forall effs systemEvent. (Eq systemEvent, Member (LogMsg SchedulerLog) effs) => Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent) (Maybe systemEvent) : effs)) () -> Eff effs ()

-- | Start a new thread
fork :: forall effs systemEvent effs2. Member (Yield (EmSystemCall effs systemEvent) (Maybe systemEvent)) effs2 => Tag -> Priority -> Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent) (Maybe systemEvent) : effs)) () -> Eff effs2 (Maybe systemEvent)

-- | Suspend the current thread
sleep :: forall effs systemEvent effs2. Member (Yield (EmSystemCall effs systemEvent) (Maybe systemEvent)) effs2 => Priority -> Eff effs2 (Maybe systemEvent)

-- | Stop the scheduler.
exit :: forall effs systemEvent effs2. Member (Yield (EmSystemCall effs systemEvent) (Maybe systemEvent)) effs2 => Eff effs2 (Maybe systemEvent)

-- | Make a thread with the given priority from an action. This is a
--   convenience for defining <tt>SimulatorInterpreter</tt> values.
mkThread :: Tag -> Priority -> Eff (Reader ThreadId : (Yield (EmSystemCall effs systemEvent) (Maybe systemEvent) : effs)) () -> ThreadId -> SuspendedThread effs systemEvent

-- | Make a system call
mkSysCall :: forall effs systemEvent effs2. Member (Yield (EmSystemCall effs systemEvent) (Maybe systemEvent)) effs2 => Priority -> SysCall effs systemEvent -> Eff effs2 (Maybe systemEvent)

-- | Make a <a>MessageCall</a> system call for some agent
mkAgentSysCall :: forall effs systemEvent. Member (Yield (AgentSystemCall systemEvent) (Maybe systemEvent)) effs => Priority -> MessageCall systemEvent -> Eff effs (Maybe systemEvent)
data SchedulerLog
SchedulerLog :: ThreadEvent -> ThreadId -> Tag -> Priority -> SchedulerLog
[slEvent] :: SchedulerLog -> ThreadEvent
[slThread] :: SchedulerLog -> ThreadId
[slTag] :: SchedulerLog -> Tag
[slPrio] :: SchedulerLog -> Priority
data ThreadEvent
Stopped :: StopReason -> ThreadEvent
Resumed :: ThreadEvent
Suspended :: ThreadEvent
Started :: ThreadEvent
Thawed :: ThreadEvent
data StopReason

-- | The thread was done.
ThreadDone :: StopReason

-- | The thread made the <a>Exit</a> system call.
ThreadExit :: StopReason
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.StopReason
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.StopReason
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.StopReason
instance GHC.Generics.Generic Plutus.Trace.Scheduler.StopReason
instance GHC.Show.Show Plutus.Trace.Scheduler.StopReason
instance GHC.Classes.Eq Plutus.Trace.Scheduler.StopReason
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Generics.Generic Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Show.Show Plutus.Trace.Scheduler.ThreadEvent
instance GHC.Classes.Eq Plutus.Trace.Scheduler.ThreadEvent
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.SchedulerLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Generics.Generic Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Show.Show Plutus.Trace.Scheduler.SchedulerLog
instance GHC.Classes.Eq Plutus.Trace.Scheduler.SchedulerLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.SchedulerLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.ThreadId
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.ThreadId
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.ThreadId
instance Data.Hashable.Class.Hashable Plutus.Trace.Scheduler.ThreadId
instance GHC.Generics.Generic Plutus.Trace.Scheduler.ThreadId
instance GHC.Show.Show Plutus.Trace.Scheduler.ThreadId
instance GHC.Classes.Ord Plutus.Trace.Scheduler.ThreadId
instance GHC.Classes.Eq Plutus.Trace.Scheduler.ThreadId
instance Prettyprinter.Internal.Pretty Plutus.Trace.Scheduler.Priority
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Scheduler.Priority
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Scheduler.Priority
instance GHC.Generics.Generic Plutus.Trace.Scheduler.Priority
instance GHC.Show.Show Plutus.Trace.Scheduler.Priority
instance GHC.Classes.Eq Plutus.Trace.Scheduler.Priority
instance GHC.Base.Functor Plutus.Trace.Scheduler.WithPriority

module Wallet.Emulator.Chain

-- | Events produced by the blockchain emulator.
data ChainEvent

-- | A transaction has been validated and added to the blockchain.
TxnValidate :: TxId -> Tx -> [ScriptValidationEvent] -> ChainEvent

-- | A transaction failed to validate.
TxnValidationFail :: ValidationPhase -> TxId -> Tx -> ValidationError -> [ScriptValidationEvent] -> ChainEvent
SlotAdd :: Slot -> ChainEvent

-- | A pool of transactions which have yet to be validated.
type TxPool = [Tx]
data ChainState
ChainState :: Blockchain -> TxPool -> UtxoIndex -> Slot -> ChainState

-- | The current chain, with the newest transactions first in the list.
[_chainNewestFirst] :: ChainState -> Blockchain

-- | The pool of pending transactions.
[_txPool] :: ChainState -> TxPool

-- | The UTxO index, used for validation.
[_index] :: ChainState -> UtxoIndex

-- | The current slot number
[_currentSlot] :: ChainState -> Slot
emptyChainState :: ChainState
txPool :: Lens' ChainState TxPool
index :: Lens' ChainState UtxoIndex
currentSlot :: Lens' ChainState Slot
chainNewestFirst :: Lens' ChainState Blockchain
data ChainControlEffect r
[ProcessBlock] :: ChainControlEffect Block
[ModifySlot] :: (Slot -> Slot) -> ChainControlEffect Slot
data ChainEffect r
[QueueTx] :: Tx -> ChainEffect ()
[GetCurrentSlot] :: ChainEffect Slot

-- | Make a new block
processBlock :: Member ChainControlEffect effs => Eff effs Block

-- | Adjust the current slot number, returning the new slot.
modifySlot :: Member ChainControlEffect effs => (Slot -> Slot) -> Eff effs Slot
queueTx :: Member ChainEffect effs => Tx -> Eff effs ()
getCurrentSlot :: Member ChainEffect effs => Eff effs Slot
type ChainEffs = '[State ChainState, LogMsg ChainEvent]
handleControlChain :: Members ChainEffs effs => ChainControlEffect ~> Eff effs
logEvent :: Member (LogMsg ChainEvent) effs => ChainEvent -> Eff effs ()
handleChain :: Members ChainEffs effs => ChainEffect ~> Eff effs

-- | The result of validating a block.
data ValidatedBlock
ValidatedBlock :: Block -> [ChainEvent] -> [Tx] -> ValidatedBlock

-- | The transactions that have been validated in this block.
[vlbValid] :: ValidatedBlock -> Block

-- | Transaction validation events for the transactions in this block.
[vlbEvents] :: ValidatedBlock -> [ChainEvent]

-- | The transactions that haven't been validated because the current slot
--   is not in their validation interval.
[vlbRest] :: ValidatedBlock -> [Tx]

-- | Validate a block given the current slot and UTxO index, returning the
--   valid transactions, success/failure events, remaining transactions and
--   the updated UTxO set.
validateBlock :: Slot -> UtxoIndex -> [Tx] -> ValidatedBlock

-- | Check whether the given transaction can be validated in the given
--   slot.
canValidateNow :: Slot -> Tx -> Bool
mkValidationEvent :: Tx -> Maybe ValidationErrorInPhase -> [ScriptValidationEvent] -> ChainEvent

-- | Validate a transaction in the current emulator state.
validateEm :: MonadState UtxoIndex m => Slot -> Tx -> m (Maybe ValidationErrorInPhase, [ScriptValidationEvent])

-- | Adds a block to ChainState, without validation.
addBlock :: Block -> ChainState -> ChainState
addTxToPool :: Tx -> TxPool -> TxPool
_SlotAdd :: Prism' ChainEvent Slot
_TxnValidationFail :: Prism' ChainEvent (ValidationPhase, TxId, Tx, ValidationError, [ScriptValidationEvent])
_TxnValidate :: Prism' ChainEvent (TxId, Tx, [ScriptValidationEvent])
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Chain.ChainEvent
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Chain.ChainEvent
instance GHC.Generics.Generic Wallet.Emulator.Chain.ChainEvent
instance GHC.Show.Show Wallet.Emulator.Chain.ChainEvent
instance GHC.Classes.Eq Wallet.Emulator.Chain.ChainEvent
instance Control.DeepSeq.NFData Wallet.Emulator.Chain.ChainState
instance Codec.Serialise.Class.Serialise Wallet.Emulator.Chain.ChainState
instance GHC.Generics.Generic Wallet.Emulator.Chain.ChainState
instance GHC.Show.Show Wallet.Emulator.Chain.ChainState
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Chain.ChainEvent


-- | This module implements an index of transactions by slot and addresses
module Wallet.Emulator.ChainIndex.Index

-- | The slot in which a transaction was added to the chain.
newtype TxSlot
TxSlot :: Maybe (Max Slot) -> TxSlot
[unTxSlot] :: TxSlot -> Maybe (Max Slot)

-- | A transaction with extra information, for the chain index.
data ChainIndexItem
ChainIndexItem :: !Slot -> !OnChainTx -> !TxId -> ChainIndexItem

-- | The slot in which the transaction was added to the chain
[ciSlot] :: ChainIndexItem -> !Slot

-- | The transaction
[ciTx] :: ChainIndexItem -> !OnChainTx

-- | Hash of the transaction
[ciTxId] :: ChainIndexItem -> !TxId

-- | A list of transactions that touch an address, sorted by slot number
newtype AddressIndex
AddressIndex :: FingerTree TxSlot ChainIndexItem -> AddressIndex
[unAddressIndex] :: AddressIndex -> FingerTree TxSlot ChainIndexItem

-- | Insert a new item into the chain index.
insertAI :: ChainIndexItem -> AddressIndex -> AddressIndex

-- | Split the address index into two. The first of the results has all
--   entries up to and including the slot. The second result has all
--   entries after the given slot.
split :: Slot -> AddressIndex -> (AddressIndex, AddressIndex)
newtype ChainIndex
ChainIndex :: Map Address AddressIndex -> ChainIndex
[unChainIndex] :: ChainIndex -> Map Address AddressIndex

-- | An empty chain index.
emptyCI :: ChainIndex

-- | Insert a transaction into the <a>ChainIndex</a>
insert :: AddressMap -> ChainIndexItem -> ChainIndex -> ChainIndex

-- | All transactions that modify the address in the given slot range
transactionsAt :: ChainIndex -> SlotRange -> Address -> [ChainIndexItem]
instance GHC.Base.Monoid Wallet.Emulator.ChainIndex.Index.TxSlot
instance GHC.Base.Semigroup Wallet.Emulator.ChainIndex.Index.TxSlot
instance GHC.Generics.Generic Wallet.Emulator.ChainIndex.Index.TxSlot
instance GHC.Show.Show Wallet.Emulator.ChainIndex.Index.TxSlot
instance GHC.Classes.Eq Wallet.Emulator.ChainIndex.Index.TxSlot
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.ChainIndex.Index.ChainIndexItem
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.ChainIndex.Index.ChainIndexItem
instance GHC.Generics.Generic Wallet.Emulator.ChainIndex.Index.ChainIndexItem
instance GHC.Show.Show Wallet.Emulator.ChainIndex.Index.ChainIndexItem
instance GHC.Classes.Eq Wallet.Emulator.ChainIndex.Index.ChainIndexItem
instance GHC.Show.Show Wallet.Emulator.ChainIndex.Index.AddressIndex
instance GHC.Classes.Eq Wallet.Emulator.ChainIndex.Index.AddressIndex
instance GHC.Generics.Generic Wallet.Emulator.ChainIndex.Index.ChainIndex
instance GHC.Show.Show Wallet.Emulator.ChainIndex.Index.ChainIndex
instance GHC.Classes.Eq Wallet.Emulator.ChainIndex.Index.ChainIndex
instance GHC.Base.Semigroup Wallet.Emulator.ChainIndex.Index.ChainIndex
instance GHC.Base.Monoid Wallet.Emulator.ChainIndex.Index.ChainIndex
instance GHC.Base.Semigroup Wallet.Emulator.ChainIndex.Index.AddressIndex
instance GHC.Base.Monoid Wallet.Emulator.ChainIndex.Index.AddressIndex
instance Data.FingerTree.Measured Wallet.Emulator.ChainIndex.Index.TxSlot Wallet.Emulator.ChainIndex.Index.ChainIndexItem

module Wallet.Emulator.Error

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | There were insufficient funds to perform the desired operation.
InsufficientFunds :: Text -> WalletAPIError

-- | The private key of this public key hahs is not known to the wallet.
PrivateKeyNotFound :: PubKeyHash -> WalletAPIError

-- | There was an error during off-chain validation.
ValidationError :: ValidationError -> WalletAPIError

-- | Some other error occurred.
OtherError :: Text -> WalletAPIError
throwInsufficientFundsError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
throwOtherError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
instance GHC.Generics.Generic Wallet.Emulator.Error.WalletAPIError
instance GHC.Classes.Eq Wallet.Emulator.Error.WalletAPIError
instance GHC.Show.Show Wallet.Emulator.Error.WalletAPIError
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Error.WalletAPIError
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Error.WalletAPIError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Error.WalletAPIError


-- | The log messages produced by the emulator.
module Wallet.Emulator.LogMessages
data RequestHandlerLogMsg
SlotNoficationTargetVsCurrent :: Slot -> Slot -> RequestHandlerLogMsg
StartWatchingContractAddresses :: RequestHandlerLogMsg
HandleAddressChangedAt :: Slot -> SlotRange -> RequestHandlerLogMsg
HandleTxFailed :: WalletAPIError -> RequestHandlerLogMsg
UtxoAtFailed :: Address -> RequestHandlerLogMsg
data TxBalanceMsg
BalancingUnbalancedTx :: UnbalancedTx -> TxBalanceMsg
NoOutputsAdded :: TxBalanceMsg
AddingPublicKeyOutputFor :: Value -> TxBalanceMsg
NoInputsAdded :: TxBalanceMsg
AddingInputsFor :: Value -> TxBalanceMsg
NoCollateralInputsAdded :: TxBalanceMsg
AddingCollateralInputsFor :: Value -> TxBalanceMsg
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Generics.Generic Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Show.Show Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance GHC.Classes.Eq Wallet.Emulator.LogMessages.RequestHandlerLogMsg
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.LogMessages.TxBalanceMsg
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.LogMessages.TxBalanceMsg
instance GHC.Generics.Generic Wallet.Emulator.LogMessages.TxBalanceMsg
instance GHC.Show.Show Wallet.Emulator.LogMessages.TxBalanceMsg
instance GHC.Classes.Eq Wallet.Emulator.LogMessages.TxBalanceMsg
instance Prettyprinter.Internal.Pretty Wallet.Emulator.LogMessages.TxBalanceMsg
instance Prettyprinter.Internal.Pretty Wallet.Emulator.LogMessages.RequestHandlerLogMsg


-- | Support for visualisation of a blockchain as a graph.
module Wallet.Graph

-- | Compute the <a>FlowLink</a>s for a <a>Blockchain</a> given a set of
--   known <a>PubKey</a>s.
txnFlows :: [PubKey] -> Blockchain -> [FlowLink]

-- | Construct a graph from a list of <a>FlowLink</a>s.
graph :: [FlowLink] -> FlowGraph

-- | The flow graph, consisting of a set of nodes (<a>TxRef</a>s) and edges
--   (<a>FlowLink</a>s).
data FlowGraph

-- | A link in the flow graph.
data FlowLink

-- | A wrapper around the first 8 digits of a <a>TxId</a>.
data TxRef

-- | The owner of an unspent transaction output.
data UtxOwner

-- | The location of a transaction in a blockchain specified by two
--   indices: the index of the containing block in the chain, and the index
--   of the transaction within the block.
data UtxoLocation
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxOwner
instance GHC.Generics.Generic Wallet.Graph.UtxOwner
instance GHC.Show.Show Wallet.Graph.UtxOwner
instance GHC.Classes.Ord Wallet.Graph.UtxOwner
instance GHC.Classes.Eq Wallet.Graph.UtxOwner
instance GHC.Generics.Generic Wallet.Graph.TxRef
instance GHC.Show.Show Wallet.Graph.TxRef
instance GHC.Classes.Ord Wallet.Graph.TxRef
instance GHC.Classes.Eq Wallet.Graph.TxRef
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.UtxoLocation
instance GHC.Generics.Generic Wallet.Graph.UtxoLocation
instance GHC.Show.Show Wallet.Graph.UtxoLocation
instance GHC.Classes.Ord Wallet.Graph.UtxoLocation
instance GHC.Classes.Eq Wallet.Graph.UtxoLocation
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowLink
instance GHC.Generics.Generic Wallet.Graph.FlowLink
instance GHC.Show.Show Wallet.Graph.FlowLink
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.FlowGraph
instance GHC.Generics.Generic Wallet.Graph.FlowGraph
instance GHC.Show.Show Wallet.Graph.FlowGraph
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Graph.TxRef

module Wallet.Rollup.Types
data TxKey
TxKey :: TxId -> Integer -> TxKey
[_txKeyTxId] :: TxKey -> TxId
[_txKeyTxOutRefIdx] :: TxKey -> Integer
data SequenceId
SequenceId :: Int -> Int -> SequenceId
[slotIndex] :: SequenceId -> Int
[txIndex] :: SequenceId -> Int
txIndexL :: Lens' SequenceId Int
slotIndexL :: Lens' SequenceId Int
data DereferencedInput
DereferencedInput :: TxIn -> TxOut -> DereferencedInput
[originalInput] :: DereferencedInput -> TxIn
[refersTo] :: DereferencedInput -> TxOut
InputNotFound :: TxKey -> DereferencedInput
isFound :: DereferencedInput -> Bool
data BeneficialOwner
OwnedByPubKey :: PubKeyHash -> BeneficialOwner
OwnedByScript :: ValidatorHash -> BeneficialOwner
toBeneficialOwner :: TxOut -> BeneficialOwner
data AnnotatedTx
AnnotatedTx :: SequenceId -> TxId -> Tx -> [DereferencedInput] -> Map BeneficialOwner Value -> Bool -> AnnotatedTx
[sequenceId] :: AnnotatedTx -> SequenceId
[txId] :: AnnotatedTx -> TxId
[tx] :: AnnotatedTx -> Tx
[dereferencedInputs] :: AnnotatedTx -> [DereferencedInput]
[balances] :: AnnotatedTx -> Map BeneficialOwner Value
[valid] :: AnnotatedTx -> Bool
data Rollup
Rollup :: Map TxKey TxOut -> Map BeneficialOwner Value -> Rollup
[_previousOutputs] :: Rollup -> Map TxKey TxOut
[_rollingBalances] :: Rollup -> Map BeneficialOwner Value
rollingBalances :: Lens' Rollup (Map BeneficialOwner Value)
previousOutputs :: Lens' Rollup (Map TxKey TxOut)
data RollupState
RollupState :: SequenceId -> Rollup -> [AnnotatedTx] -> RollupState
[_currentSequenceId] :: RollupState -> SequenceId
[_rollup] :: RollupState -> Rollup
[_annotatedTransactions] :: RollupState -> [AnnotatedTx]
rollup :: Lens' RollupState Rollup
currentSequenceId :: Lens' RollupState SequenceId
annotatedTransactions :: Lens' RollupState [AnnotatedTx]
instance GHC.Generics.Generic Wallet.Rollup.Types.Rollup
instance GHC.Classes.Eq Wallet.Rollup.Types.Rollup
instance GHC.Show.Show Wallet.Rollup.Types.Rollup
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.DereferencedInput
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.DereferencedInput
instance GHC.Generics.Generic Wallet.Rollup.Types.DereferencedInput
instance GHC.Show.Show Wallet.Rollup.Types.DereferencedInput
instance GHC.Classes.Eq Wallet.Rollup.Types.DereferencedInput
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.FromJSON.FromJSONKey Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.BeneficialOwner
instance GHC.Generics.Generic Wallet.Rollup.Types.BeneficialOwner
instance GHC.Classes.Ord Wallet.Rollup.Types.BeneficialOwner
instance GHC.Show.Show Wallet.Rollup.Types.BeneficialOwner
instance GHC.Classes.Eq Wallet.Rollup.Types.BeneficialOwner
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.AnnotatedTx
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.AnnotatedTx
instance GHC.Generics.Generic Wallet.Rollup.Types.AnnotatedTx
instance GHC.Show.Show Wallet.Rollup.Types.AnnotatedTx
instance GHC.Classes.Eq Wallet.Rollup.Types.AnnotatedTx
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.TxKey
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.TxKey
instance GHC.Generics.Generic Wallet.Rollup.Types.TxKey
instance GHC.Classes.Ord Wallet.Rollup.Types.TxKey
instance GHC.Classes.Eq Wallet.Rollup.Types.TxKey
instance GHC.Show.Show Wallet.Rollup.Types.TxKey
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Rollup.Types.SequenceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Rollup.Types.SequenceId
instance GHC.Generics.Generic Wallet.Rollup.Types.SequenceId
instance GHC.Show.Show Wallet.Rollup.Types.SequenceId
instance GHC.Classes.Ord Wallet.Rollup.Types.SequenceId
instance GHC.Classes.Eq Wallet.Rollup.Types.SequenceId
instance Prettyprinter.Internal.Pretty Wallet.Rollup.Types.TxKey

module Wallet.Rollup
doAnnotateBlockchain :: Monad m => Blockchain -> m [[AnnotatedTx]]
initialRollup :: Rollup
annotateBlockchain :: Monad m => Blockchain -> StateT Rollup m [[AnnotatedTx]]
data Rollup
initialState :: RollupState
handleChainEvent :: RollupState -> ChainEvent -> RollupState
getAnnotatedTransactions :: RollupState -> [[AnnotatedTx]]


-- | Defines a number of types that are used in Wallet.XXX modules
module Wallet.Types

-- | Unique ID for contract instance
newtype ContractInstanceId
ContractInstanceId :: UUID -> ContractInstanceId
[unContractInstanceId] :: ContractInstanceId -> UUID

-- | A pure list of all <a>ContractInstanceId</a> values. To be used in
--   testing.
contractInstanceIDs :: [ContractInstanceId]
randomID :: IO ContractInstanceId
data Notification
Notification :: ContractInstanceId -> EndpointDescription -> Value -> Notification
[notificationContractID] :: Notification -> ContractInstanceId
[notificationContractEndpoint] :: Notification -> EndpointDescription
[notificationContractArg] :: Notification -> Value
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
[getEndpointDescription] :: EndpointDescription -> String
newtype EndpointValue a
EndpointValue :: a -> EndpointValue a
[unEndpointValue] :: EndpointValue a -> a

-- | A payment consisting of a set of inputs to be spent, and an optional
--   change output. The size of the payment is the difference between the
--   total value of the inputs and the value of the output.
data Payment
Payment :: Set TxIn -> Maybe TxOut -> Payment
[paymentInputs] :: Payment -> Set TxIn
[paymentChangeOutput] :: Payment -> Maybe TxOut

-- | A payment with zero inputs and no change output
emptyPayment :: Payment

-- | Request for information about transactions that spend or produce
--   outputs at a specific address in a slot range.
data AddressChangeRequest
AddressChangeRequest :: Slot -> Slot -> Address -> AddressChangeRequest
[acreqSlotRangeFrom] :: AddressChangeRequest -> Slot
[acreqSlotRangeTo] :: AddressChangeRequest -> Slot

-- | The address
[acreqAddress] :: AddressChangeRequest -> Address

-- | The earliest slot in which we can respond to an
--   <a>AddressChangeRequest</a>.
targetSlot :: AddressChangeRequest -> Slot

-- | The slot range for this request
slotRange :: AddressChangeRequest -> SlotRange

-- | Information about transactions that spend or produce an output at an
--   address in a slot range.
data AddressChangeResponse
AddressChangeResponse :: Address -> SlotRange -> [OnChainTx] -> AddressChangeResponse

-- | The address
[acrAddress] :: AddressChangeResponse -> Address

-- | The slot range
[acrSlotRange] :: AddressChangeResponse -> SlotRange

-- | Transactions that were validated in the slot range and spent or
--   produced at least one output at the address.
[acrTxns] :: AddressChangeResponse -> [OnChainTx]

-- | An error
newtype MatchingError
WrongVariantError :: Text -> MatchingError
[unWrongVariantError] :: MatchingError -> Text
class AsMatchingError r_a1Cuc
_MatchingError :: AsMatchingError r_a1Cuc => Prism' r_a1Cuc MatchingError
_WrongVariantError :: AsMatchingError r_a1Cuc => Prism' r_a1Cuc Text

-- | An error emitted when an <tt>Assertion</tt> fails.
newtype AssertionError
GenericAssertion :: Text -> AssertionError
[unAssertionError] :: AssertionError -> Text
class AsAssertionError r_a1CPT
_AssertionError :: AsAssertionError r_a1CPT => Prism' r_a1CPT AssertionError
_GenericAssertion :: AsAssertionError r_a1CPT => Prism' r_a1CPT Text
data ContractError
WalletError :: WalletAPIError -> ContractError
EmulatorAssertionError :: AssertionError -> ContractError
OtherError :: Text -> ContractError
ConstraintResolutionError :: MkTxError -> ContractError
ResumableError :: MatchingError -> ContractError
CCheckpointError :: CheckpointError -> ContractError
class AsContractError r_a1D8V
_ContractError :: AsContractError r_a1D8V => Prism' r_a1D8V ContractError
_WalletError :: AsContractError r_a1D8V => Prism' r_a1D8V WalletAPIError
_EmulatorAssertionError :: AsContractError r_a1D8V => Prism' r_a1D8V AssertionError
_OtherError :: AsContractError r_a1D8V => Prism' r_a1D8V Text
_ConstraintResolutionError :: AsContractError r_a1D8V => Prism' r_a1D8V MkTxError
_ResumableError :: AsContractError r_a1D8V => Prism' r_a1D8V MatchingError
_CCheckpointError :: AsContractError r_a1D8V => Prism' r_a1D8V CheckpointError
data NotificationError
EndpointNotAvailable :: ContractInstanceId -> EndpointDescription -> NotificationError
MoreThanOneEndpointAvailable :: ContractInstanceId -> EndpointDescription -> NotificationError
InstanceDoesNotExist :: ContractInstanceId -> NotificationError
OtherNotificationError :: ContractError -> NotificationError

-- | Indicates that the target contract does not have the expected schema
NotificationJSONDecodeError :: EndpointDescription -> Value -> String -> NotificationError
class AsNotificationError r_a1EyG
_NotificationError :: AsNotificationError r_a1EyG => Prism' r_a1EyG NotificationError
_EndpointNotAvailable :: AsNotificationError r_a1EyG => Prism' r_a1EyG (ContractInstanceId, EndpointDescription)
_MoreThanOneEndpointAvailable :: AsNotificationError r_a1EyG => Prism' r_a1EyG (ContractInstanceId, EndpointDescription)
_InstanceDoesNotExist :: AsNotificationError r_a1EyG => Prism' r_a1EyG ContractInstanceId
_OtherNotificationError :: AsNotificationError r_a1EyG => Prism' r_a1EyG ContractError
_NotificationJSONDecodeError :: AsNotificationError r_a1EyG => Prism' r_a1EyG (EndpointDescription, Value, String)
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.AddressChangeResponse
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.AddressChangeResponse
instance GHC.Show.Show Wallet.Types.AddressChangeResponse
instance GHC.Generics.Generic Wallet.Types.AddressChangeResponse
instance GHC.Classes.Eq Wallet.Types.AddressChangeResponse
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.AddressChangeRequest
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.AddressChangeRequest
instance GHC.Classes.Ord Wallet.Types.AddressChangeRequest
instance GHC.Show.Show Wallet.Types.AddressChangeRequest
instance GHC.Generics.Generic Wallet.Types.AddressChangeRequest
instance GHC.Classes.Eq Wallet.Types.AddressChangeRequest
instance Prettyprinter.Internal.Pretty Wallet.Types.AddressChangeRequest
instance Prettyprinter.Internal.Pretty Wallet.Types.AddressChangeResponse
instance Wallet.Types.AsNotificationError Wallet.Types.NotificationError
instance Prettyprinter.Internal.Pretty Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSONKey Wallet.Types.ContractInstanceId
instance GHC.Generics.Generic Wallet.Types.ContractInstanceId
instance GHC.Show.Show Wallet.Types.ContractInstanceId
instance GHC.Classes.Ord Wallet.Types.ContractInstanceId
instance GHC.Classes.Eq Wallet.Types.ContractInstanceId
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.EndpointDescription
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.EndpointDescription
instance Prettyprinter.Internal.Pretty Wallet.Types.EndpointDescription
instance Data.String.IsString Wallet.Types.EndpointDescription
instance Language.Haskell.TH.Syntax.Lift Wallet.Types.EndpointDescription
instance GHC.Show.Show Wallet.Types.EndpointDescription
instance GHC.Generics.Generic Wallet.Types.EndpointDescription
instance GHC.Classes.Ord Wallet.Types.EndpointDescription
instance GHC.Classes.Eq Wallet.Types.EndpointDescription
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Wallet.Types.EndpointValue a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Wallet.Types.EndpointValue a)
instance GHC.Show.Show a => GHC.Show.Show (Wallet.Types.EndpointValue a)
instance GHC.Generics.Generic (Wallet.Types.EndpointValue a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Wallet.Types.EndpointValue a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Wallet.Types.EndpointValue a)
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.Notification
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.Notification
instance GHC.Generics.Generic Wallet.Types.Notification
instance GHC.Show.Show Wallet.Types.Notification
instance GHC.Classes.Eq Wallet.Types.Notification
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.NotificationError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.NotificationError
instance GHC.Generics.Generic Wallet.Types.NotificationError
instance GHC.Show.Show Wallet.Types.NotificationError
instance GHC.Classes.Eq Wallet.Types.NotificationError
instance GHC.Show.Show a => Prettyprinter.Internal.Pretty (Wallet.Types.EndpointValue a)
instance Prettyprinter.Internal.Pretty Wallet.Types.NotificationError
instance Prettyprinter.Internal.Pretty Wallet.Types.Notification
instance Wallet.Types.AsContractError Wallet.Types.ContractError
instance Wallet.Types.AsContractError Data.Text.Internal.Text
instance Wallet.Types.AsAssertionError Wallet.Types.ContractError
instance Plutus.Contract.Checkpoint.AsCheckpointError Wallet.Types.ContractError
instance Prettyprinter.Internal.Pretty Wallet.Types.ContractError
instance Data.String.IsString Wallet.Types.ContractError
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.ContractError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.ContractError
instance GHC.Generics.Generic Wallet.Types.ContractError
instance GHC.Classes.Eq Wallet.Types.ContractError
instance GHC.Show.Show Wallet.Types.ContractError
instance Wallet.Types.AsAssertionError Wallet.Types.AssertionError
instance Wallet.Types.AsAssertionError Data.Text.Internal.Text
instance Prettyprinter.Internal.Pretty Wallet.Types.AssertionError
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.AssertionError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.AssertionError
instance GHC.Generics.Generic Wallet.Types.AssertionError
instance GHC.Classes.Eq Wallet.Types.AssertionError
instance GHC.Show.Show Wallet.Types.AssertionError
instance Wallet.Types.AsMatchingError Wallet.Types.MatchingError
instance Prettyprinter.Internal.Pretty Wallet.Types.MatchingError
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.Payment
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.Payment
instance GHC.Generics.Generic Wallet.Types.Payment
instance GHC.Show.Show Wallet.Types.Payment
instance GHC.Classes.Eq Wallet.Types.Payment
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Types.MatchingError
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Types.MatchingError
instance GHC.Generics.Generic Wallet.Types.MatchingError
instance GHC.Show.Show Wallet.Types.MatchingError
instance GHC.Classes.Ord Wallet.Types.MatchingError
instance GHC.Classes.Eq Wallet.Types.MatchingError

module Wallet.Effects

-- | Effects that allow contracts to interact with the blockchain
type WalletEffects = '[WalletEffect, NodeClientEffect, ChainIndexEffect, ContractRuntimeEffect]
data WalletEffect r
[SubmitTxn] :: Tx -> WalletEffect ()
[OwnPubKey] :: WalletEffect PubKey
[UpdatePaymentWithChange] :: Value -> Payment -> WalletEffect Payment
[WalletSlot] :: WalletEffect Slot
[OwnOutputs] :: WalletEffect UtxoMap
[WalletAddSignature] :: Tx -> WalletEffect Tx

-- | A payment consisting of a set of inputs to be spent, and an optional
--   change output. The size of the payment is the difference between the
--   total value of the inputs and the value of the output.
data Payment
Payment :: Set TxIn -> Maybe TxOut -> Payment
[paymentInputs] :: Payment -> Set TxIn
[paymentChangeOutput] :: Payment -> Maybe TxOut
submitTxn :: forall effs_a1WGe. Member WalletEffect effs_a1WGe => Tx -> Eff effs_a1WGe ()
ownPubKey :: forall effs_a1WGf. Member WalletEffect effs_a1WGf => Eff effs_a1WGf PubKey
updatePaymentWithChange :: forall effs_a1WGg. Member WalletEffect effs_a1WGg => Value -> Payment -> Eff effs_a1WGg Payment
walletSlot :: forall effs_a1WGh. Member WalletEffect effs_a1WGh => Eff effs_a1WGh Slot
ownOutputs :: forall effs_a1WGi. Member WalletEffect effs_a1WGi => Eff effs_a1WGi UtxoMap
walletAddSignature :: forall effs_a1WGj. Member WalletEffect effs_a1WGj => Tx -> Eff effs_a1WGj Tx
data NodeClientEffect r
[PublishTx] :: Tx -> NodeClientEffect ()
[GetClientSlot] :: NodeClientEffect Slot
publishTx :: forall effs_a1WJy. Member NodeClientEffect effs_a1WJy => Tx -> Eff effs_a1WJy ()
getClientSlot :: forall effs_a1WJz. Member NodeClientEffect effs_a1WJz => Eff effs_a1WJz Slot

-- | Access the chain index. The chain index keeps track of the datums that
--   are associated with unspent transaction outputs. Addresses that are of
--   interest need to be added with <a>startWatching</a> before their
--   outputs show up in the <a>AddressMap</a> returned by
--   <a>watchedAddresses</a>.
data ChainIndexEffect r
[StartWatching] :: Address -> ChainIndexEffect ()
[WatchedAddresses] :: ChainIndexEffect AddressMap
[ConfirmedBlocks] :: ChainIndexEffect [Block]
[TransactionConfirmed] :: TxId -> ChainIndexEffect Bool
[AddressChanged] :: AddressChangeRequest -> ChainIndexEffect AddressChangeResponse

-- | Request for information about transactions that spend or produce
--   outputs at a specific address in a slot range.
data AddressChangeRequest
AddressChangeRequest :: Slot -> Slot -> Address -> AddressChangeRequest
[acreqSlotRangeFrom] :: AddressChangeRequest -> Slot
[acreqSlotRangeTo] :: AddressChangeRequest -> Slot

-- | The address
[acreqAddress] :: AddressChangeRequest -> Address

-- | Information about transactions that spend or produce an output at an
--   address in a slot range.
data AddressChangeResponse
AddressChangeResponse :: Address -> SlotRange -> [OnChainTx] -> AddressChangeResponse

-- | The address
[acrAddress] :: AddressChangeResponse -> Address

-- | The slot range
[acrSlotRange] :: AddressChangeResponse -> SlotRange

-- | Transactions that were validated in the slot range and spent or
--   produced at least one output at the address.
[acrTxns] :: AddressChangeResponse -> [OnChainTx]
startWatching :: forall effs_a1WLD. Member ChainIndexEffect effs_a1WLD => Address -> Eff effs_a1WLD ()
watchedAddresses :: forall effs_a1WLE. Member ChainIndexEffect effs_a1WLE => Eff effs_a1WLE AddressMap
confirmedBlocks :: forall effs_a1WLF. Member ChainIndexEffect effs_a1WLF => Eff effs_a1WLF [Block]
transactionConfirmed :: forall effs_a1WLG. Member ChainIndexEffect effs_a1WLG => TxId -> Eff effs_a1WLG Bool
addressChanged :: forall effs_a1WLH. Member ChainIndexEffect effs_a1WLH => AddressChangeRequest -> Eff effs_a1WLH AddressChangeResponse

-- | Interact with other contracts.
data ContractRuntimeEffect r
[SendNotification] :: Notification -> ContractRuntimeEffect (Maybe NotificationError)
sendNotification :: forall effs_a1WOk. Member ContractRuntimeEffect effs_a1WOk => Notification -> Eff effs_a1WOk (Maybe NotificationError)

module Wallet.Emulator.NodeClient
data NodeClientEvent

-- | A transaction has been added to the pool of pending transactions. The
--   value is the fee of the transaction.
TxSubmit :: TxId -> Value -> NodeClientEvent
_TxSubmit :: Iso' NodeClientEvent (TxId, Value)
data NodeClientState
NodeClientState :: Slot -> AddressMap -> NodeClientState
[_clientSlot] :: NodeClientState -> Slot

-- | Full index
[_clientIndex] :: NodeClientState -> AddressMap
emptyNodeClientState :: NodeClientState
clientSlot :: Lens' NodeClientState Slot
clientIndex :: Lens' NodeClientState AddressMap
data ChainClientNotification
BlockValidated :: Block -> ChainClientNotification
SlotChanged :: Slot -> ChainClientNotification
data NodeClientControlEffect r
[ClientNotify] :: ChainClientNotification -> NodeClientControlEffect ()
clientNotify :: forall effs_a1XtA. Member NodeClientControlEffect effs_a1XtA => ChainClientNotification -> Eff effs_a1XtA ()
type NodeClientEffs = '[ChainEffect, State NodeClientState, LogMsg NodeClientEvent]
handleNodeControl :: Members NodeClientEffs effs => Eff (NodeClientControlEffect : effs) ~> Eff effs
handleNodeClient :: Members NodeClientEffs effs => Eff (NodeClientEffect : effs) ~> Eff effs
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.ChainClientNotification
instance GHC.Show.Show Wallet.Emulator.NodeClient.ChainClientNotification
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.NodeClientState
instance GHC.Show.Show Wallet.Emulator.NodeClient.NodeClientState
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.NodeClient.NodeClientEvent
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Generics.Generic Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Show.Show Wallet.Emulator.NodeClient.NodeClientEvent
instance GHC.Classes.Eq Wallet.Emulator.NodeClient.NodeClientEvent
instance Prettyprinter.Internal.Pretty Wallet.Emulator.NodeClient.NodeClientEvent

module Wallet.Emulator.ChainIndex
data ChainIndexControlEffect r
[ChainIndexNotify] :: ChainClientNotification -> ChainIndexControlEffect ()
chainIndexNotify :: forall effs_a1Zba. Member ChainIndexControlEffect effs_a1Zba => ChainClientNotification -> Eff effs_a1Zba ()
data ChainIndexEvent
AddressStartWatching :: Address -> ChainIndexEvent
ReceiveBlockNotification :: Int -> ChainIndexEvent
HandlingAddressChangeRequest :: AddressChangeRequest -> [ChainIndexItem] -> ChainIndexEvent
_HandlingAddressChangeRequest :: Prism' ChainIndexEvent (AddressChangeRequest, [ChainIndexItem])
_ReceiveBlockNotification :: Prism' ChainIndexEvent Int
_AddressStartWatching :: Prism' ChainIndexEvent Address
data ChainIndexState
ChainIndexState :: AddressMap -> Map TxId Slot -> Blockchain -> Maybe (Max Slot) -> ChainIndex -> ChainIndexState

-- | Utxo set annotated with datums
[_idxWatchedAddresses] :: ChainIndexState -> AddressMap

-- | Transactions with confirmation date
[_idxConfirmedTransactions] :: ChainIndexState -> Map TxId Slot

-- | The blockchain
[_idxConfirmedBlocks] :: ChainIndexState -> Blockchain

-- | The current slot
[_idxCurrentSlot] :: ChainIndexState -> Maybe (Max Slot)

-- | Transactions indexed by time and address
[_idxIdx] :: ChainIndexState -> ChainIndex
idxWatchedAddresses :: Lens' ChainIndexState AddressMap
idxIdx :: Lens' ChainIndexState ChainIndex
idxCurrentSlot :: Lens' ChainIndexState (Maybe (Max Slot))
idxConfirmedTransactions :: Lens' ChainIndexState (Map TxId Slot)
idxConfirmedBlocks :: Lens' ChainIndexState Blockchain
type ChainIndexEffs = '[State ChainIndexState, LogMsg ChainIndexEvent]
handleChainIndexControl :: Members ChainIndexEffs effs => Eff (ChainIndexControlEffect : effs) ~> Eff effs
handleChainIndex :: Members ChainIndexEffs effs => Eff (ChainIndexEffect : effs) ~> Eff effs
instance GHC.Base.Monoid Wallet.Emulator.ChainIndex.ChainIndexState
instance GHC.Base.Semigroup Wallet.Emulator.ChainIndex.ChainIndexState
instance GHC.Generics.Generic Wallet.Emulator.ChainIndex.ChainIndexState
instance GHC.Show.Show Wallet.Emulator.ChainIndex.ChainIndexState
instance GHC.Classes.Eq Wallet.Emulator.ChainIndex.ChainIndexState
instance Prettyprinter.Internal.Pretty Wallet.Emulator.ChainIndex.ChainIndexEvent
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.ChainIndex.ChainIndexEvent
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.ChainIndex.ChainIndexEvent
instance GHC.Generics.Generic Wallet.Emulator.ChainIndex.ChainIndexEvent
instance GHC.Show.Show Wallet.Emulator.ChainIndex.ChainIndexEvent
instance GHC.Classes.Eq Wallet.Emulator.ChainIndex.ChainIndexEvent


-- | The interface between the wallet and Plutus client code.
module Wallet.API
data WalletEffect r
submitTxn :: forall effs_a1WGe. Member WalletEffect effs_a1WGe => Tx -> Eff effs_a1WGe ()
ownPubKey :: forall effs_a1WGf. Member WalletEffect effs_a1WGf => Eff effs_a1WGf PubKey
updatePaymentWithChange :: forall effs_a1WGg. Member WalletEffect effs_a1WGg => Value -> Payment -> Eff effs_a1WGg Payment
walletSlot :: forall effs_a1WGh. Member WalletEffect effs_a1WGh => Eff effs_a1WGh Slot
ownOutputs :: forall effs_a1WGi. Member WalletEffect effs_a1WGi => Eff effs_a1WGi UtxoMap
data NodeClientEffect r
publishTx :: forall effs_a1WJy. Member NodeClientEffect effs_a1WJy => Tx -> Eff effs_a1WJy ()
getClientSlot :: forall effs_a1WJz. Member NodeClientEffect effs_a1WJz => Eff effs_a1WJz Slot

-- | Access the chain index. The chain index keeps track of the datums that
--   are associated with unspent transaction outputs. Addresses that are of
--   interest need to be added with <a>startWatching</a> before their
--   outputs show up in the <a>AddressMap</a> returned by
--   <a>watchedAddresses</a>.
data ChainIndexEffect r
startWatching :: forall effs_a1WLD. Member ChainIndexEffect effs_a1WLD => Address -> Eff effs_a1WLD ()
watchedAddresses :: forall effs_a1WLE. Member ChainIndexEffect effs_a1WLE => Eff effs_a1WLE AddressMap

-- | A cryptographic public key.
newtype PubKey
PubKey :: LedgerBytes -> PubKey
[getPubKey] :: PubKey -> LedgerBytes

-- | A payment consisting of a set of inputs to be spent, and an optional
--   change output. The size of the payment is the difference between the
--   total value of the inputs and the value of the output.
data Payment
Payment :: Set TxIn -> Maybe TxOut -> Payment
[paymentInputs] :: Payment -> Set TxIn
[paymentChangeOutput] :: Payment -> Maybe TxOut

-- | A payment with zero inputs and no change output
emptyPayment :: Payment

-- | Add the wallet's signature to the transaction and submit it. Returns
--   the transaction with the wallet's signature.
signTxAndSubmit :: Member WalletEffect effs => Tx -> Eff effs Tx

-- | A version of <a>signTxAndSubmit</a> that discards the result.
signTxAndSubmit_ :: Member WalletEffect effs => Tx -> Eff effs ()

-- | Transfer some funds to an address locked by a public key, returning
--   the transaction that was submitted.
payToPublicKey :: Member WalletEffect effs => SlotRange -> Value -> PubKey -> Eff effs Tx

-- | Transfer some funds to an address locked by a public key.
payToPublicKey_ :: Member WalletEffect effs => SlotRange -> Value -> PubKey -> Eff effs ()

-- | An interval of <tt>a</tt>s.
--   
--   The interval may be either closed or open at either end, meaning that
--   the endpoints may or may not be included in the interval.
--   
--   The interval can also be unbounded on either side.
data Interval a
Interval :: LowerBound a -> UpperBound a -> Interval a
[ivFrom] :: Interval a -> LowerBound a
[ivTo] :: Interval a -> UpperBound a

-- | The slot number. This is a good proxy for time, since on the Cardano
--   blockchain slots pass at a constant rate.
data Slot

-- | An <a>Interval</a> of <a>Slot</a>s.
type SlotRange = Interval Slot

-- | Number of <a>Slot</a>s covered by the interval, if finite. <tt>width
--   (from x) == Nothing</tt>.
width :: SlotRange -> Maybe Integer

-- | The default slot validity range for transactions.
defaultSlotRange :: SlotRange

-- | <tt>interval a b</tt> includes all values that are greater than or
--   equal to <tt>a</tt> and smaller than <tt>b</tt>. Therefore it includes
--   <tt>a</tt> but not it does not include <tt>b</tt>.
interval :: a -> a -> Interval a
singleton :: a -> Interval a

-- | Check if an <a>Interval</a> is empty.
isEmpty :: Ord a => Interval a -> Bool

-- | An <a>Interval</a> that covers every slot.
always :: Interval a

-- | Check whether a value is in an interval.
member :: Ord a => a -> Interval a -> Bool

-- | Check if a value is earlier than the beginning of an <a>Interval</a>.
before :: Ord a => a -> Interval a -> Bool

-- | Check if a value is later than the end of a <a>Interval</a>.
after :: Ord a => a -> Interval a -> Bool

-- | <tt>a <a>contains</a> b</tt> is true if the <a>Interval</a> <tt>b</tt>
--   is entirely contained in <tt>a</tt>. That is, <tt>a <a>contains</a>
--   b</tt> if for every entry <tt>s</tt>, if <tt>member s b</tt> then
--   <tt>member s a</tt>.
contains :: Ord a => Interval a -> Interval a -> Bool

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | There were insufficient funds to perform the desired operation.
InsufficientFunds :: Text -> WalletAPIError

-- | The private key of this public key hahs is not known to the wallet.
PrivateKeyNotFound :: PubKeyHash -> WalletAPIError

-- | There was an error during off-chain validation.
ValidationError :: ValidationError -> WalletAPIError

-- | Some other error occurred.
OtherError :: Text -> WalletAPIError
throwInsufficientFundsError :: Member (Error WalletAPIError) effs => Text -> Eff effs a
throwOtherError :: Member (Error WalletAPIError) effs => Text -> Eff effs a

module Wallet.Emulator.Wallet
newtype SigningProcess
SigningProcess :: (forall effs. Member (Error WalletAPIError) effs => [PubKeyHash] -> Tx -> Eff effs Tx) -> SigningProcess
[unSigningProcess] :: SigningProcess -> forall effs. Member (Error WalletAPIError) effs => [PubKeyHash] -> Tx -> Eff effs Tx

-- | A wallet in the emulator model.
newtype Wallet
Wallet :: Integer -> Wallet
[getWallet] :: Wallet -> Integer

-- | Get a wallet's public key.
walletPubKey :: Wallet -> PubKey

-- | Get a wallet's private key by looking it up in the list of private
--   keys in <a>knownPrivateKeys</a>
walletPrivKey :: Wallet -> PrivateKey

-- | Get a wallet's address.
walletAddress :: Wallet -> Address

-- | Sign a <a>Tx</a> using the wallet's privat key.
signWithWallet :: Wallet -> Tx -> Tx

-- | Whether the wallet is one of the known emulated wallets
isEmulatorWallet :: Wallet -> Bool
data WalletEvent
GenericLog :: Text -> WalletEvent
CheckpointLog :: CheckpointLogMsg -> WalletEvent
RequestHandlerLog :: RequestHandlerLogMsg -> WalletEvent
TxBalanceLog :: TxBalanceMsg -> WalletEvent
_TxBalanceLog :: Prism' WalletEvent TxBalanceMsg
_RequestHandlerLog :: Prism' WalletEvent RequestHandlerLogMsg
_CheckpointLog :: Prism' WalletEvent CheckpointLogMsg
_GenericLog :: Prism' WalletEvent Text

-- | The state used by the mock wallet environment.
data WalletState
WalletState :: PrivateKey -> NodeClientState -> ChainIndexState -> SigningProcess -> WalletState

-- | User's <a>PrivateKey</a>.
[_ownPrivateKey] :: WalletState -> PrivateKey
[_nodeClient] :: WalletState -> NodeClientState
[_chainIndex] :: WalletState -> ChainIndexState
[_signingProcess] :: WalletState -> SigningProcess
signingProcess :: Lens' WalletState SigningProcess
ownPrivateKey :: Lens' WalletState PrivateKey
nodeClient :: Lens' WalletState NodeClientState
chainIndex :: Lens' WalletState ChainIndexState

-- | Get the user's own public-key address.
ownAddress :: WalletState -> Address

-- | An empty wallet state with the public/private key pair for a wallet,
--   and the public-key address for that wallet as the sole watched
--   address.
emptyWalletState :: Wallet -> WalletState

-- | An empty wallet using the given private key. for that wallet as the
--   sole watched address.
emptyWalletStateFromPrivateKey :: PrivateKey -> WalletState
data PaymentArgs
PaymentArgs :: Map TxOutRef TxOutTx -> PubKey -> Value -> PaymentArgs

-- | Funds that may be spent in order to balance the payment
[availableFunds] :: PaymentArgs -> Map TxOutRef TxOutTx

-- | Where to send the change (if any)
[ownPubKey] :: PaymentArgs -> PubKey

-- | The value that must be covered by the payment's inputs
[requestedValue] :: PaymentArgs -> Value
handleUpdatePaymentWithChange :: Member (Error WalletAPIError) effs => PaymentArgs -> Payment -> Eff effs Payment
handleWallet :: (Member NodeClientEffect effs, Member ChainIndexEffect effs, Member (State WalletState) effs, Member (Error WalletAPIError) effs) => WalletEffect ~> Eff effs
mkChangeOutput :: PubKey -> Value -> Maybe TxOut

-- | Given a set of <tt>a</tt>s with coin values, and a target value,
--   select a number of <tt>a</tt> such that their total value is greater
--   than or equal to the target.
selectCoin :: Member (Error WalletAPIError) effs => [(a, Value)] -> Value -> Eff effs ([(a, Value)], Value)

-- | Take elements from a list until the predicate is satisfied.
--   <a>takeUntil</a> <tt>p</tt> includes the first element for wich
--   <tt>p</tt> is true (unlike <tt>takeWhile (not . p)</tt>).
takeUntil :: (a -> Bool) -> [a] -> [a]

-- | The default signing process is <a>signWallet</a>
defaultSigningProcess :: Wallet -> SigningProcess
signWithPrivateKey :: PrivateKey -> SigningProcess

-- | Sign the transaction by calling <a>signTxnWithKey</a> (throwing a
--   <tt>PrivateKeyNotFound</tt> error if called with a key other than the
--   wallet's private key)
signWallet :: Wallet -> SigningProcess

-- | Sign the transaction with the private key of the given public key.
--   Fails if the wallet doesn't have the private key.
signTxnWithKey :: Member (Error WalletAPIError) r => Wallet -> Tx -> PubKeyHash -> Eff r Tx

-- | Sign the transaction with the private key, if the hash is that of the
--   private key.
signTxWithPrivateKey :: Member (Error WalletAPIError) r => PrivateKey -> Tx -> PubKeyHash -> Eff r Tx

-- | Sign the transaction with the private keys of the given wallets,
--   ignoring the list of public keys that the <a>SigningProcess</a> is
--   passed.
signWallets :: [Wallet] -> SigningProcess
data SigningProcessControlEffect r
[SetSigningProcess] :: SigningProcess -> SigningProcessControlEffect ()
setSigningProcess :: forall effs_a26B3. Member SigningProcessControlEffect effs_a26B3 => SigningProcess -> Eff effs_a26B3 ()
type SigningProcessEffs = '[State SigningProcess, Error WalletAPIError]
handleSigningProcessControl :: Members SigningProcessEffs effs => Eff (SigningProcessControlEffect : effs) ~> Eff effs

-- | An Entity is a thing that can hold <a>Value</a>. Used in the
--   <a>balances</a> function to compute who holds for a given chain state
--   and set of wallets.
data Entity
WalletEntity :: Wallet -> Entity
PubKeyHashEntity :: PubKeyHash -> Entity
ScriptEntity :: ValidatorHash -> Entity
type WalletSet = Map Wallet WalletState

-- | Pick out all the public keys from the set of wallets and map them back
--   to their corresponding wallets.
walletPubKeyHashes :: WalletSet -> Map PubKeyHash Wallet

-- | For a set of wallets, convert them into a map of value: entity, where
--   entity is one of <a>Entity</a>.
balances :: ChainState -> WalletSet -> Map Entity Value
instance GHC.Classes.Ord Wallet.Emulator.Wallet.Entity
instance GHC.Classes.Eq Wallet.Emulator.Wallet.Entity
instance GHC.Show.Show Wallet.Emulator.Wallet.Entity
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletState
instance Data.Aeson.Types.ToJSON.ToJSONKey Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.Wallet
instance Control.Newtype.Generics.Newtype Wallet.Emulator.Wallet.Wallet
instance Data.Hashable.Class.Hashable Wallet.Emulator.Wallet.Wallet
instance Web.Internal.HttpApiData.FromHttpApiData Wallet.Emulator.Wallet.Wallet
instance Web.Internal.HttpApiData.ToHttpApiData Wallet.Emulator.Wallet.Wallet
instance GHC.Generics.Generic Wallet.Emulator.Wallet.Wallet
instance GHC.Classes.Ord Wallet.Emulator.Wallet.Wallet
instance GHC.Classes.Eq Wallet.Emulator.Wallet.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Wallet.WalletEvent
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Wallet.WalletEvent
instance GHC.Generics.Generic Wallet.Emulator.Wallet.WalletEvent
instance GHC.Classes.Eq Wallet.Emulator.Wallet.WalletEvent
instance GHC.Show.Show Wallet.Emulator.Wallet.WalletEvent
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Wallet.WalletEvent
instance GHC.Show.Show Wallet.Emulator.Wallet.Wallet
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Wallet.Wallet
instance GHC.Show.Show Wallet.Emulator.Wallet.SigningProcess


-- | Implements contract instance notifications in the emulator.
module Wallet.Emulator.Notify
data EmulatorContractNotifyEffect r
[SendAgentNotification] :: Wallet -> Wallet -> Notification -> EmulatorContractNotifyEffect (Maybe NotificationError)
sendAgentNotification :: forall effs_a2c6P. Member EmulatorContractNotifyEffect effs_a2c6P => Wallet -> Wallet -> Notification -> Eff effs_a2c6P (Maybe NotificationError)

-- | Handle the <a>ContractRuntimeEffect</a> by forwarding notifications to
--   <a>EmulatorContractNotifyEffect</a>
handleContractRuntime :: (Member (LogMsg EmulatorNotifyLogMsg) effs, Member EmulatorContractNotifyEffect effs) => Wallet -> ContractRuntimeEffect ~> Eff effs

-- | The <a>ContractInstanceId</a> of a wallet. See note [Emulator contract
--   instances].
walletInstanceId :: Wallet -> ContractInstanceId

-- | The wallet of a <a>ContractInstanceId</a>. See note [Emulator contract
--   instances].
instanceIdWallet :: ContractInstanceId -> Maybe Wallet
data EmulatorNotifyLogMsg
NotifyFailed :: Wallet -> NotificationError -> EmulatorNotifyLogMsg
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.Notify.EmulatorNotifyLogMsg
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.Notify.EmulatorNotifyLogMsg
instance GHC.Generics.Generic Wallet.Emulator.Notify.EmulatorNotifyLogMsg
instance GHC.Show.Show Wallet.Emulator.Notify.EmulatorNotifyLogMsg
instance GHC.Classes.Eq Wallet.Emulator.Notify.EmulatorNotifyLogMsg
instance Prettyprinter.Internal.Pretty Wallet.Emulator.Notify.EmulatorNotifyLogMsg

module Wallet

module Plutus.Trace.Effects.ContractInstanceId
data ContractInstanceIdEff r
nextId :: forall effs_a2ddx. Member ContractInstanceIdEff effs_a2ddx => Eff effs_a2ddx ContractInstanceId

-- | Handle <a>ContractInstanceIdEff</a> using the list of IDs
--   <a>contractInstanceIDs</a>.
handleDeterministicIds :: Eff (ContractInstanceIdEff : effs) ~> Eff effs

-- | Handle <a>ContractInstanceIdEff</a> using a random number generator
handleRandomIds :: (LastMember m effs, MonadIO m) => Eff (ContractInstanceIdEff : effs) ~> Eff effs

module Plutus.Contract.Types

-- | Effects that are available to contracts.
type ContractEffs w s e = '[Error e, LogMsg Value, Writer w, Checkpoint, Resumable (Event s) (Handlers s)]
handleContractEffs :: forall w s e effs a. (Member (Error e) effs, Member (State CheckpointStore) effs, Member (State CheckpointKey) effs, Member (State (AccumState w)) effs, Member (LogMsg CheckpointLogMsg) effs, Member (LogMsg Value) effs, Monoid w) => Eff (ContractEffs w s e) a -> Eff effs (Maybe (MultiRequestContStatus (Event s) (Handlers s) effs a))

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
newtype Contract w s e a
Contract :: Eff (ContractEffs w s e) a -> Contract w s e a
[unContract] :: Contract w s e a -> Eff (ContractEffs w s e) a

-- | <tt>select</tt> returns the contract that makes progress first,
--   discarding the other one.
select :: forall w s e a. Contract w s e a -> Contract w s e a -> Contract w s e a

-- | A variant of <tt>select</tt> for contracts with different return
--   types.
selectEither :: forall w s e a b. Contract w s e a -> Contract w s e b -> Contract w s e (Either a b)
data ContractError
WalletError :: WalletAPIError -> ContractError
EmulatorAssertionError :: AssertionError -> ContractError
OtherError :: Text -> ContractError
ConstraintResolutionError :: MkTxError -> ContractError
ResumableError :: MatchingError -> ContractError
CCheckpointError :: CheckpointError -> ContractError
class AsContractError r_a1D8V
_ContractError :: AsContractError r_a1D8V => Prism' r_a1D8V ContractError
_WalletError :: AsContractError r_a1D8V => Prism' r_a1D8V WalletAPIError
_EmulatorAssertionError :: AsContractError r_a1D8V => Prism' r_a1D8V AssertionError
_OtherError :: AsContractError r_a1D8V => Prism' r_a1D8V Text
_ConstraintResolutionError :: AsContractError r_a1D8V => Prism' r_a1D8V MkTxError
_ResumableError :: AsContractError r_a1D8V => Prism' r_a1D8V MatchingError
_CCheckpointError :: AsContractError r_a1D8V => Prism' r_a1D8V CheckpointError

-- | An error
newtype MatchingError
WrongVariantError :: Text -> MatchingError
[unWrongVariantError] :: MatchingError -> Text

-- | Transform any exceptions thrown by the <a>Contract</a> using the given
--   function.
mapError :: forall w s e e' a. (e -> e') -> Contract w s e a -> Contract w s e' a

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | Turn a contract with error type <tt>e</tt> and return type <tt>a</tt>
--   into one with error type <a>Void</a> (ie. throwing no errors) that
--   returns 'Either e a'
runError :: forall w s e a. Contract w s e a -> Contract w s Void (Either e a)

-- | Handle errors, potentially throwing new errors.
handleError :: forall w s e e' a. (e -> Contract w s e' a) -> Contract w s e a -> Contract w s e' a
class AsCheckpointError r_aooT
_CheckpointError :: AsCheckpointError r_aooT => Prism' r_aooT CheckpointError
_JSONDecodeError :: AsCheckpointError r_aooT => Prism' r_aooT Text
data CheckpointError
JSONDecodeError :: Text -> CheckpointError

-- | Write the current state of the contract to a checkpoint.
checkpoint :: forall w s e a. (AsCheckpointError e, FromJSON a, ToJSON a) => Contract w s e a -> Contract w s e a
checkpointLoop :: forall w s e a b. (AsCheckpointError e, FromJSON a, ToJSON a, ToJSON b, FromJSON b) => (a -> Contract w s e (Either b a)) -> a -> Contract w s e b
runResumable :: Monoid w => [Response (Event s)] -> CheckpointStore -> Eff (ContractEffs w s e) a -> ResumableResult w e (Event s) (Handlers s) a
insertAndUpdate :: forall w s e a. Monoid w => Eff (ContractEffs w s e) a -> CheckpointStore -> Responses (CheckpointKey, Event s) -> Response (Event s) -> ResumableResult w e (Event s) (Handlers s) a
runWithRecord :: forall w s e a. Monoid w => Eff (ContractEffs w s e) a -> CheckpointStore -> Responses (Event s) -> ResumableResult w e (Event s) (Handlers s) a

-- | The result of running a <a>Resumable</a>
data ResumableResult w e i o a
ResumableResult :: Responses (CheckpointKey, i) -> Requests o -> Either e (Maybe a) -> Seq (LogMessage Value) -> Seq (LogMessage Value) -> CheckpointStore -> w -> w -> ResumableResult w e i o a
[_responses] :: ResumableResult w e i o a -> Responses (CheckpointKey, i)
[_requests] :: ResumableResult w e i o a -> Requests o
[_finalState] :: ResumableResult w e i o a -> Either e (Maybe a)
[_logs] :: ResumableResult w e i o a -> Seq (LogMessage Value)
[_lastLogs] :: ResumableResult w e i o a -> Seq (LogMessage Value)
[_checkpointStore] :: ResumableResult w e i o a -> CheckpointStore

-- | Accumulated, observable state of the contract
[_observableState] :: ResumableResult w e i o a -> w

-- | Last accumulated state
[_lastState] :: ResumableResult w e i o a -> w
responses :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY i_a2eFY. Lens (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) (ResumableResult w_a2dxU e_a2dxV i_a2eFY o_a2dxX a_a2dxY) (Responses (CheckpointKey, i_a2dxW)) (Responses (CheckpointKey, i_a2eFY))
requests :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY o_a2eFX. Lens (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2eFX a_a2dxY) (Requests o_a2dxX) (Requests o_a2eFX)
finalState :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY e_a2eFV a_a2eFW. Lens (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) (ResumableResult w_a2dxU e_a2eFV i_a2dxW o_a2dxX a_a2eFW) (Either e_a2dxV (Maybe a_a2dxY)) (Either e_a2eFV (Maybe a_a2eFW))
logs :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY. Lens' (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) (Seq (LogMessage Value))
lastState :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY. Lens' (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) w_a2dxU
checkpointStore :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY. Lens' (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) CheckpointStore
observableState :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY. Lens' (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) w_a2dxU

-- | Shrink the <a>ResumableResult</a> by deleting everything that's not
--   needed to restore the state of the contract instance.
shrinkResumableResult :: ResumableResult w e i o a -> ResumableResult w e i o a
data SuspendedContract w e i o a
SuspendedContract :: ResumableResult w e i o a -> Maybe (MultiRequestContStatus i o (SuspendedContractEffects w e i) a) -> CheckpointKey -> SuspendedContract w e i o a
[_resumableResult] :: SuspendedContract w e i o a -> ResumableResult w e i o a
[_continuations] :: SuspendedContract w e i o a -> Maybe (MultiRequestContStatus i o (SuspendedContractEffects w e i) a)
[_checkpointKey] :: SuspendedContract w e i o a -> CheckpointKey
resumableResult :: forall w_a2eHv e_a2eHw i_a2eHx o_a2eHy a_a2eHz. Lens' (SuspendedContract w_a2eHv e_a2eHw i_a2eHx o_a2eHy a_a2eHz) (ResumableResult w_a2eHv e_a2eHw i_a2eHx o_a2eHy a_a2eHz)
continuations :: forall w_a2eHv e_a2eHw i_a2eHx o_a2eHy a_a2eHz. Lens' (SuspendedContract w_a2eHv e_a2eHw i_a2eHx o_a2eHy a_a2eHz) (Maybe (MultiRequestContStatus i_a2eHx o_a2eHy (SuspendedContractEffects w_a2eHv e_a2eHw i_a2eHx) a_a2eHz))
checkpointKey :: forall w_a2eHv e_a2eHw i_a2eHx o_a2eHy a_a2eHz. Lens' (SuspendedContract w_a2eHv e_a2eHw i_a2eHx o_a2eHy a_a2eHz) CheckpointKey

-- | Run an action of <tt>ContractEffs</tt> until it requests input for the
--   first time, returning the <a>SuspendedContract</a>
suspend :: forall w s e a. Monoid w => CheckpointStore -> Eff (ContractEffs w s e) a -> SuspendedContract w e (Event s) (Handlers s) a

-- | Feed a <a>Response</a> to a <a>SuspendedContract</a>.
runStep :: forall w s e a. Monoid w => SuspendedContract w e (Event s) (Handlers s) a -> Response (Event s) -> Maybe (SuspendedContract w e (Event s) (Handlers s) a)
lastLogs :: forall w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY. Lens' (ResumableResult w_a2dxU e_a2dxV i_a2dxW o_a2dxX a_a2dxY) (Seq (LogMessage Value))
instance Data.Aeson.Types.FromJSON.FromJSON w => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Types.AccumState w)
instance Data.Aeson.Types.ToJSON.ToJSON w => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Monoid w => GHC.Base.Monoid (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Semigroup w => GHC.Base.Semigroup (Plutus.Contract.Types.AccumState w)
instance GHC.Show.Show w => GHC.Show.Show (Plutus.Contract.Types.AccumState w)
instance GHC.Classes.Ord w => GHC.Classes.Ord (Plutus.Contract.Types.AccumState w)
instance GHC.Classes.Eq w => GHC.Classes.Eq (Plutus.Contract.Types.AccumState w)
instance GHC.Base.Monad (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Applicative (Plutus.Contract.Types.Contract w s e)
instance GHC.Base.Functor (Plutus.Contract.Types.Contract w s e)
instance (Data.Aeson.Types.FromJSON.FromJSON i, Data.Aeson.Types.FromJSON.FromJSON o, Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.Types.ResumableResult w e i o a)
instance (Data.Aeson.Types.ToJSON.ToJSON w, Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON o, Data.Aeson.Types.ToJSON.ToJSON i) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.Types.ResumableResult w e i o a)
instance (GHC.Show.Show i, GHC.Show.Show o, GHC.Show.Show e, GHC.Show.Show a, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.Types.ResumableResult w e i o a)
instance GHC.Generics.Generic (Plutus.Contract.Types.ResumableResult w e i o a)
instance Control.Monad.Error.Class.MonadError e (Plutus.Contract.Types.Contract w s e)
instance PlutusTx.Functor.Functor (Plutus.Contract.Types.Contract w s e)
instance PlutusTx.Applicative.Applicative (Plutus.Contract.Types.Contract w s e)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.Types.Contract w s)

module Plutus.Contract.State

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
data Contract w s e a

-- | The state of a <a>Contract</a>, containing all responses that have
--   been fed to it, and checkpoints that it produced.
data State w e
State :: Responses e -> CheckpointStore -> w -> State w e
[record] :: State w e -> Responses e
[checkpoints] :: State w e -> CheckpointStore
[observableState] :: State w e -> w

-- | A request sent to a contract instance. It contains the previous
--   <a>State</a> of the instance, and a <a>Response</a> to one of the
--   requests of the instance.
data ContractRequest w s
ContractRequest :: State w (CheckpointKey, s) -> Response s -> ContractRequest w s
[oldState] :: ContractRequest w s -> State w (CheckpointKey, s)
[event] :: ContractRequest w s -> Response s

-- | A response produced by a contract instance. It contains the new
--   <a>State</a>, the list of endpoints that can be called, logs produced
--   by the contract, possibly an error message, and the accumulated
--   observable state.
data ContractResponse w e s h
ContractResponse :: State w (CheckpointKey, s) -> [Request h] -> [LogMessage Value] -> [LogMessage Value] -> Maybe e -> w -> ContractResponse w e s h

-- | Serialised state of the contract (internal)
[newState] :: ContractResponse w e s h -> State w (CheckpointKey, s)

-- | Open requests that can be handled
[hooks] :: ContractResponse w e s h -> [Request h]

-- | Logs produced by the contract
[logs] :: ContractResponse w e s h -> [LogMessage Value]

-- | Logs produced in the last step
[lastLogs] :: ContractResponse w e s h -> [LogMessage Value]

-- | Error that happened during contract execution
[err] :: ContractResponse w e s h -> Maybe e

-- | Observable state produced in the last step
[lastState] :: ContractResponse w e s h -> w
mapE :: forall e f w s h. (e -> f) -> ContractResponse w e s h -> ContractResponse w f s h
mapW :: forall w q e s h. (w -> q) -> ContractResponse w e s h -> ContractResponse q e s h

-- | Run one step of the contract by restoring it to its previous state and
--   feeding it a single new <a>Response</a> event.
insertAndUpdateContract :: forall w s e a. Monoid w => Contract w s e a -> ContractRequest w (Event s) -> ContractResponse w e (Event s) (Handlers s)

-- | The <a>ContractResponse</a> with the initial state of the contract.
initialiseContract :: forall w s e a. Monoid w => Contract w s e a -> ContractResponse w e (Event s) (Handlers s)
mkResponse :: forall w e s h a. Monoid w => w -> ResumableResult w e s h a -> ContractResponse w e s h
instance (Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.State w e)
instance (Data.Aeson.Types.ToJSON.ToJSON w, Data.Aeson.Types.ToJSON.ToJSON e) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.State w e)
instance Data.Traversable.Traversable (Plutus.Contract.State.State w)
instance Data.Foldable.Foldable (Plutus.Contract.State.State w)
instance GHC.Base.Functor (Plutus.Contract.State.State w)
instance (GHC.Show.Show e, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.State.State w e)
instance (GHC.Classes.Eq e, GHC.Classes.Eq w) => GHC.Classes.Eq (Plutus.Contract.State.State w e)
instance GHC.Generics.Generic (Plutus.Contract.State.State w e)
instance (GHC.Show.Show s, GHC.Show.Show w) => Prettyprinter.Internal.Pretty (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.ContractRequest w s)
instance Data.Traversable.Traversable (Plutus.Contract.State.ContractRequest w)
instance Data.Foldable.Foldable (Plutus.Contract.State.ContractRequest w)
instance GHC.Base.Functor (Plutus.Contract.State.ContractRequest w)
instance (GHC.Show.Show s, GHC.Show.Show w) => GHC.Show.Show (Plutus.Contract.State.ContractRequest w s)
instance (GHC.Classes.Eq s, GHC.Classes.Eq w) => GHC.Classes.Eq (Plutus.Contract.State.ContractRequest w s)
instance GHC.Generics.Generic (Plutus.Contract.State.ContractRequest w s)
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON w, Data.Aeson.Types.FromJSON.FromJSON h, Data.Aeson.Types.FromJSON.FromJSON e) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.State.ContractResponse w e s h)
instance (Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON h, Data.Aeson.Types.ToJSON.ToJSON s, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.State.ContractResponse w e s h)
instance GHC.Base.Functor (Plutus.Contract.State.ContractResponse w e s)
instance (GHC.Show.Show s, GHC.Show.Show w, GHC.Show.Show h, GHC.Show.Show e) => GHC.Show.Show (Plutus.Contract.State.ContractResponse w e s h)
instance (GHC.Classes.Eq s, GHC.Classes.Eq w, GHC.Classes.Eq h, GHC.Classes.Eq e) => GHC.Classes.Eq (Plutus.Contract.State.ContractResponse w e s h)
instance GHC.Generics.Generic (Plutus.Contract.State.ContractResponse w e s h)
instance Data.Bifunctor.Bifunctor (Plutus.Contract.State.ContractResponse w e)
instance Data.Bifunctor.Bifunctor Plutus.Contract.State.State

module Plutus.Contract.Servant

-- | Serve a <tt>PlutusContract</tt> via the contract API.
contractServer :: forall w s e. (Show e, Monoid w) => Contract w s e () -> Server (ContractAPI w e s)

-- | A servant <a>Application</a> that serves a Plutus contract
contractApp :: forall w s e. (AllUniqueLabels (Input s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) ToJSON, ToJSON e, ToJSON w, FromJSON w, Monoid w, Show e) => Contract w s e () -> Application

-- | A request sent to a contract instance. It contains the previous
--   <a>State</a> of the instance, and a <a>Response</a> to one of the
--   requests of the instance.
data ContractRequest w s

-- | A response produced by a contract instance. It contains the new
--   <a>State</a>, the list of endpoints that can be called, logs produced
--   by the contract, possibly an error message, and the accumulated
--   observable state.
data ContractResponse w e s h

module Plutus.Contract.Request

-- | Constraints on the contract schema, ensuring that the requests
--   produced by the contracts are <a>Monoid</a>s (so that we can produce a
--   record with requests from different branches) and that the labels of
--   the schema are unique.
type ContractRow s = (AllUniqueLabels (Input s), AllUniqueLabels (Output s))

-- | Given a schema <tt>s</tt> with an entry <tt>l .== (resp, req)</tt>,
--   <tt>request r</tt> is a contract that writes the request <tt>r</tt>
--   and waits for a response of type <tt>resp</tt>.
request :: forall w l req resp s e. (KnownSymbol l, AllUniqueLabels (Output s), HasType l resp (Input s), HasType l req (Output s), AsContractError e) => req -> Contract w s e resp

-- | Write a request repeatedly until the desired response is returned.
requestMaybe :: forall w l req resp s a e. (KnownSymbol l, HasType l resp (Input s), HasType l req (Output s), ContractRow s, AsContractError e) => req -> (resp -> Maybe a) -> Contract w s e a

module Plutus.Contract.Effects.OwnPubKey
type OwnPubKeySym = "own-pubkey"
type HasOwnPubKey s = (HasType OwnPubKeySym PubKey (Input s), HasType OwnPubKeySym OwnPubKeyRequest (Output s), ContractRow s)
type OwnPubKey = OwnPubKeySym .== (PubKey, OwnPubKeyRequest)
data OwnPubKeyRequest
WaitingForPubKey :: OwnPubKeyRequest

-- | Get a public key belonging to the wallet that runs this contract. *
--   Any funds paid to this public key will be treated as the wallet's own
--   funds * The wallet is able to sign transactions with the private key
--   of this public key, for example, if the public key is added to the
--   <tt>requiredSignatures</tt> field of <tt>Tx</tt>. * There is a 1-n
--   relationship between wallets and public keys (although in the
--   mockchain n=1)
ownPubKey :: forall w s e. (AsContractError e, HasOwnPubKey s) => Contract w s e PubKey
event :: forall s. HasOwnPubKey s => PubKey -> Event s
request :: forall s. HasOwnPubKey s => Handlers s -> Maybe OwnPubKeyRequest
instance GHC.Generics.Generic Plutus.Contract.Effects.OwnPubKey.OwnPubKeyRequest
instance GHC.Show.Show Plutus.Contract.Effects.OwnPubKey.OwnPubKeyRequest
instance GHC.Classes.Eq Plutus.Contract.Effects.OwnPubKey.OwnPubKeyRequest
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.OwnPubKey.OwnPubKeyRequest
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.OwnPubKey.OwnPubKeyRequest
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.OwnPubKey.OwnPubKeyRequest

module Plutus.Contract.Effects.AwaitTxConfirmed
type TxConfirmationSym = "tx-confirmation"
type HasTxConfirmation s = (HasType TxConfirmationSym TxConfirmed (Input s), HasType TxConfirmationSym TxId (Output s), ContractRow s)
newtype TxConfirmed
TxConfirmed :: TxId -> TxConfirmed
[unTxConfirmed] :: TxConfirmed -> TxId
type TxConfirmation = TxConfirmationSym .== (TxConfirmed, TxId)

-- | Wait until a transaction is confirmed (added to the ledger).
awaitTxConfirmed :: forall w s e. (AsContractError e, HasTxConfirmation s) => TxId -> Contract w s e ()
event :: forall s. HasTxConfirmation s => TxId -> Event s
txId :: forall s. HasTxConfirmation s => Handlers s -> Maybe TxId
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed
instance GHC.Show.Show Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed
instance GHC.Generics.Generic Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed
instance GHC.Classes.Ord Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed
instance GHC.Classes.Eq Plutus.Contract.Effects.AwaitTxConfirmed.TxConfirmed

module Plutus.Contract.Effects.WriteTx
type TxSymbol = "tx"
data WriteTxResponse
WriteTxFailed :: WalletAPIError -> WriteTxResponse
WriteTxSuccess :: Tx -> WriteTxResponse
writeTxResponse :: Iso' WriteTxResponse (Either WalletAPIError Tx)
type HasWriteTx s = (HasType TxSymbol WriteTxResponse (Input s), HasType TxSymbol UnbalancedTx (Output s), ContractRow s)
type WriteTx = TxSymbol .== (WriteTxResponse, UnbalancedTx)

-- | Send an unbalanced transaction to be balanced and signed. Returns the
--   ID of the final transaction when the transaction was submitted. Throws
--   an error if balancing or signing failed.
submitUnbalancedTx :: forall w s e. (AsContractError e, HasWriteTx s) => UnbalancedTx -> Contract w s e Tx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. The constraints do not refer to any typed script inputs
--   or outputs.
submitTx :: forall w s e. (HasWriteTx s, AsContractError e) => TxConstraints Void Void -> Contract w s e Tx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the current outputs at the contract address and the
--   contract's own public key to solve the constraints.
submitTxConstraints :: forall a w s e. (HasWriteTx s, IsData (RedeemerType a), IsData (DatumType a), AsContractError e) => TypedValidator a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e Tx

-- | Build a transaction that satisfies the constraints using the UTXO map
--   to resolve any input constraints (see <a>InputConstraint</a>)
submitTxConstraintsSpending :: forall a w s e. (HasWriteTx s, IsData (RedeemerType a), IsData (DatumType a), AsContractError e) => TypedValidator a -> UtxoMap -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e Tx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the given constraints.
submitTxConstraintsWith :: forall a w s e. (HasWriteTx s, IsData (RedeemerType a), IsData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e Tx

-- | A version of <a>submitTx</a> that waits until the transaction has been
--   confirmed on the ledger before returning.
submitTxConfirmed :: forall w s e. (HasWriteTx s, HasTxConfirmation s, AsContractError e) => UnbalancedTx -> Contract w s e ()
event :: forall s. (HasType TxSymbol WriteTxResponse (Input s), AllUniqueLabels (Input s)) => WriteTxResponse -> Event s
pendingTransaction :: forall s. HasType TxSymbol UnbalancedTx (Output s) => Handlers s -> Maybe UnbalancedTx
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.WriteTx.WriteTxResponse
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.WriteTx.WriteTxResponse
instance GHC.Generics.Generic Plutus.Contract.Effects.WriteTx.WriteTxResponse
instance GHC.Show.Show Plutus.Contract.Effects.WriteTx.WriteTxResponse
instance GHC.Classes.Eq Plutus.Contract.Effects.WriteTx.WriteTxResponse
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.WriteTx.WriteTxResponse

module Plutus.Contract.Effects.AwaitSlot
type SlotSymbol = "slot"
type HasAwaitSlot s = (HasType SlotSymbol Slot (Input s), HasType SlotSymbol WaitingForSlot (Output s), ContractRow s)
newtype WaitingForSlot
WaitingForSlot :: Slot -> WaitingForSlot
[unWaitingForSlot] :: WaitingForSlot -> Slot
type AwaitSlot = SlotSymbol .== (Slot, WaitingForSlot)

-- | A contract that waits until the slot is reached, then returns the
--   current slot.
awaitSlot :: forall w s e. (HasAwaitSlot s, AsContractError e) => Slot -> Contract w s e Slot

-- | Wait for a number of slots.
waitNSlots :: forall w s e. (HasAwaitSlot s, AsContractError e) => Integer -> Contract w s e Slot
event :: forall s. (HasType SlotSymbol Slot (Input s), AllUniqueLabels (Input s)) => Slot -> Event s
request :: forall s. HasType SlotSymbol WaitingForSlot (Output s) => Handlers s -> Maybe Slot

-- | Run a contract until the given slot has been reached.
until :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Contract w s e a -> Slot -> Contract w s e (Maybe a)

-- | Run a contract when the given slot has been reached.
when :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Slot -> Contract w s e a -> Contract w s e a

-- | Run a contract until the given slot has been reached. <tt>timeout =
--   flip until</tt>
timeout :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Slot -> Contract w s e a -> Contract w s e (Maybe a)

-- | Wait until the first slot is reached, then run the contract until the
--   second slot is reached.
between :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Slot -> Slot -> Contract w s e a -> Contract w s e (Maybe a)

-- | Repeatedly run a contract until the slot is reached, then return the
--   last result.
collectUntil :: forall w s e a b. (HasAwaitSlot s, AsContractError e) => (a -> b -> b) -> b -> Contract w s e a -> Slot -> Contract w s e b

-- | The current slot number
currentSlot :: forall w s e. (HasAwaitSlot s, AsContractError e) => Contract w s e Slot
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.AwaitSlot.WaitingForSlot
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.AwaitSlot.WaitingForSlot
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.AwaitSlot.WaitingForSlot
instance GHC.Generics.Generic Plutus.Contract.Effects.AwaitSlot.WaitingForSlot
instance GHC.Show.Show Plutus.Contract.Effects.AwaitSlot.WaitingForSlot
instance GHC.Classes.Ord Plutus.Contract.Effects.AwaitSlot.WaitingForSlot
instance GHC.Classes.Eq Plutus.Contract.Effects.AwaitSlot.WaitingForSlot

module Plutus.Contract.Effects.UtxoAt
type UtxoAtSym = "utxo-at"
type HasUtxoAt s = (HasType UtxoAtSym UtxoAtAddress (Input s), HasType UtxoAtSym Address (Output s), ContractRow s)
data UtxoAtAddress
UtxoAtAddress :: Address -> UtxoMap -> UtxoAtAddress
[address] :: UtxoAtAddress -> Address
[utxo] :: UtxoAtAddress -> UtxoMap
type UtxoAt = UtxoAtSym .== (UtxoAtAddress, Address)

-- | Get the unspent transaction outputs at an address.
utxoAt :: forall w s e. (AsContractError e, HasUtxoAt s) => Address -> Contract w s e UtxoMap
event :: forall s. HasUtxoAt s => UtxoAtAddress -> Event s
utxoAtRequest :: forall s. HasUtxoAt s => Handlers s -> Maybe Address

-- | Watch an address until the given slot, then return all known outputs
--   at the address.
watchAddressUntil :: forall w s e. (HasAwaitSlot s, HasUtxoAt s, AsContractError e) => Address -> Slot -> Contract w s e UtxoMap
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.UtxoAt.UtxoAtAddress
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.UtxoAt.UtxoAtAddress
instance GHC.Generics.Generic Plutus.Contract.Effects.UtxoAt.UtxoAtAddress
instance GHC.Show.Show Plutus.Contract.Effects.UtxoAt.UtxoAtAddress
instance GHC.Classes.Eq Plutus.Contract.Effects.UtxoAt.UtxoAtAddress
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.UtxoAt.UtxoAtAddress

module Plutus.Contract.Effects.WatchAddress
type AddressSymbol = "address"
type HasWatchAddress s = (HasType AddressSymbol AddressChangeResponse (Input s), HasType AddressSymbol AddressChangeRequest (Output s), ContractRow s)
type WatchAddress = AddressSymbol .== (AddressChangeResponse, AddressChangeRequest)

-- | Get the transactions that modified an address in a specific slot.
addressChangeRequest :: forall w s e. (HasWatchAddress s, AsContractError e, HasAwaitSlot s) => AddressChangeRequest -> Contract w s e AddressChangeResponse

-- | Call <tt>addresssChangeRequest</tt> for the address in each slot,
--   until at least one transaction is returned that modifies the address.
nextTransactionsAt :: forall w s e. (HasWatchAddress s, AsContractError e, HasAwaitSlot s) => Address -> Contract w s e [OnChainTx]

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has surpassed the given value.
fundsAtAddressGt :: forall w s e. (AsContractError e, HasAwaitSlot s, HasUtxoAt s) => Address -> Value -> Contract w s e UtxoMap

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has reached or surpassed the given
--   value.
fundsAtAddressGeq :: forall w s e. (AsContractError e, HasAwaitSlot s, HasUtxoAt s) => Address -> Value -> Contract w s e UtxoMap

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has fallen below the given value.
fundsAtAddressLt :: forall w s e. (AsContractError e, HasAwaitSlot s, HasUtxoAt s) => Address -> Value -> Contract w s e UtxoMap

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has reached or fallen below the
--   given value.
fundsAtAddressLeq :: forall w s e. (AsContractError e, HasAwaitSlot s, HasUtxoAt s) => Address -> Value -> Contract w s e UtxoMap

-- | Watch an address for changes, and return the outputs at that address
--   when the condition succeeds.
fundsAtAddressCondition :: forall w s e. (AsContractError e, HasAwaitSlot s, HasUtxoAt s) => (Value -> Bool) -> Address -> Contract w s e UtxoMap

-- | The <a>AddressChangeResponse</a> events for all addresses touched by
--   the transaction. The <a>AddressMap</a> is used to lookup the addresses
--   of outputs spent by the transaction.
events :: forall s. (HasType AddressSymbol AddressChangeResponse (Input s), AllUniqueLabels (Input s)) => Slot -> AddressMap -> OnChainTx -> Map Address (Event s)
watchAddressRequest :: forall s. HasType AddressSymbol AddressChangeRequest (Output s) => Handlers s -> Maybe AddressChangeRequest
watchedAddress :: forall s. HasType AddressSymbol AddressChangeRequest (Output s) => Handlers s -> Maybe Address

-- | Request for information about transactions that spend or produce
--   outputs at a specific address in a slot range.
data AddressChangeRequest
AddressChangeRequest :: Slot -> Slot -> Address -> AddressChangeRequest
[acreqSlotRangeFrom] :: AddressChangeRequest -> Slot
[acreqSlotRangeTo] :: AddressChangeRequest -> Slot

-- | The address
[acreqAddress] :: AddressChangeRequest -> Address

-- | Information about transactions that spend or produce an output at an
--   address in a slot range.
data AddressChangeResponse
AddressChangeResponse :: Address -> SlotRange -> [OnChainTx] -> AddressChangeResponse

-- | The address
[acrAddress] :: AddressChangeResponse -> Address

-- | The slot range
[acrSlotRange] :: AddressChangeResponse -> SlotRange

-- | Transactions that were validated in the slot range and spent or
--   produced at least one output at the address.
[acrTxns] :: AddressChangeResponse -> [OnChainTx]
event :: forall s. (HasType AddressSymbol AddressChangeResponse (Input s), AllUniqueLabels (Input s)) => AddressChangeResponse -> Event s


-- | Dealing with instances of running contract.
module Plutus.Contract.Effects.Instance
type HasOwnId s = (HasType OwnIdSym ContractInstanceId (Input s), HasType OwnIdSym OwnIdRequest (Output s), ContractRow s)

-- | Unique ID for contract instance
data ContractInstanceId

-- | Get the <a>ContractInstanceId</a> of this instance.
ownInstanceId :: forall w s e. (AsContractError e, HasOwnId s) => Contract w s e ContractInstanceId
data OwnIdRequest
WaitingForInstanceId :: OwnIdRequest
type OwnId = OwnIdSym .== (ContractInstanceId, OwnIdRequest)
event :: forall s. HasOwnId s => ContractInstanceId -> Event s
request :: forall s. HasOwnId s => Handlers s -> Maybe OwnIdRequest
instance GHC.Generics.Generic Plutus.Contract.Effects.Instance.OwnIdRequest
instance GHC.Show.Show Plutus.Contract.Effects.Instance.OwnIdRequest
instance GHC.Classes.Eq Plutus.Contract.Effects.Instance.OwnIdRequest
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.Instance.OwnIdRequest
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.Instance.OwnIdRequest
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.Instance.OwnIdRequest

module Plutus.Contract.Effects.ExposeEndpoint
type HasEndpoint l a s = (HasType l (EndpointValue a) (Input s), HasType l ActiveEndpoint (Output s), KnownSymbol l, ContractRow s)
type Endpoint l a = l .== (EndpointValue a, ActiveEndpoint)
data ActiveEndpoint
ActiveEndpoint :: EndpointDescription -> Maybe Value -> ActiveEndpoint

-- | The name of the endpoint
[aeDescription] :: ActiveEndpoint -> EndpointDescription

-- | Data that should be shown to the user
[aeMetadata] :: ActiveEndpoint -> Maybe Value
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
[getEndpointDescription] :: EndpointDescription -> String
newtype EndpointValue a
EndpointValue :: a -> EndpointValue a
[unEndpointValue] :: EndpointValue a -> a

-- | Expose an endpoint, return the data that was entered
endpoint :: forall l a w s e. (HasEndpoint l a s, AsContractError e) => Contract w s e a

-- | Expose an endpoint with some metadata. Return the data that was
--   entered.
endpointWithMeta :: forall l a w s e b. (HasEndpoint l a s, AsContractError e, ToJSON b) => b -> Contract w s e a
endpointDescription :: forall l. KnownSymbol l => Proxy l -> EndpointDescription
event :: forall (l :: Symbol) a s. (KnownSymbol l, HasType l (EndpointValue a) (Input s), AllUniqueLabels (Input s)) => a -> Event s
isActive :: forall (l :: Symbol) s. (KnownSymbol l, HasType l ActiveEndpoint (Output s)) => Handlers s -> Bool
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Effects.ExposeEndpoint.ActiveEndpoint
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Effects.ExposeEndpoint.ActiveEndpoint
instance GHC.Generics.Generic Plutus.Contract.Effects.ExposeEndpoint.ActiveEndpoint
instance GHC.Show.Show Plutus.Contract.Effects.ExposeEndpoint.ActiveEndpoint
instance GHC.Classes.Eq Plutus.Contract.Effects.ExposeEndpoint.ActiveEndpoint
instance Prettyprinter.Internal.Pretty Plutus.Contract.Effects.ExposeEndpoint.ActiveEndpoint

module Plutus.Contract

-- | <tt>Contract w s e a</tt> is a contract with schema <tt>s</tt>,
--   producing a value of type <tt>a</tt> or an error <tt>e</tt>. See note
--   [Contract Schema].
newtype Contract w s e a
Contract :: Eff (ContractEffs w s e) a -> Contract w s e a
[unContract] :: Contract w s e a -> Eff (ContractEffs w s e) a
data ContractError
WalletError :: WalletAPIError -> ContractError
EmulatorAssertionError :: AssertionError -> ContractError
OtherError :: Text -> ContractError
ConstraintResolutionError :: MkTxError -> ContractError
ResumableError :: MatchingError -> ContractError
CCheckpointError :: CheckpointError -> ContractError
class AsContractError r_a1D8V
_ContractError :: AsContractError r_a1D8V => Prism' r_a1D8V ContractError
_WalletError :: AsContractError r_a1D8V => Prism' r_a1D8V WalletAPIError
_EmulatorAssertionError :: AsContractError r_a1D8V => Prism' r_a1D8V AssertionError
_OtherError :: AsContractError r_a1D8V => Prism' r_a1D8V Text
_ConstraintResolutionError :: AsContractError r_a1D8V => Prism' r_a1D8V MkTxError
_ResumableError :: AsContractError r_a1D8V => Prism' r_a1D8V MatchingError
_CCheckpointError :: AsContractError r_a1D8V => Prism' r_a1D8V CheckpointError
type HasBlockchainActions s = (HasAwaitSlot s, HasWatchAddress s, HasWriteTx s, HasUtxoAt s, HasOwnPubKey s, HasTxConfirmation s, HasOwnId s)

-- | Schema for contracts that can interact with the blockchain (via a node
--   client &amp; signing process)
type BlockchainActions = AwaitSlot .\/ WatchAddress .\/ WriteTx .\/ UtxoAt .\/ OwnPubKey .\/ TxConfirmation .\/ OwnId

-- | Execute both contracts in any order
both :: Contract w s e a -> Contract w s e b -> Contract w s e (a, b)

-- | A variant of <tt>select</tt> for contracts with different return
--   types.
selectEither :: forall w s e a b. Contract w s e a -> Contract w s e b -> Contract w s e (Either a b)

-- | <tt>select</tt> returns the contract that makes progress first,
--   discarding the other one.
select :: forall w s e a. Contract w s e a -> Contract w s e a -> Contract w s e a

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
--   
--   '<tt>as <a>&gt;&gt;</a> bs</tt>' can be understood as the <tt>do</tt>
--   expression
--   
--   <pre>
--   do as
--      bs
--   </pre>
(>>) :: Monad m => m a -> m b -> m b
infixl 1 >>

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => e -> m a

-- | Handle errors, potentially throwing new errors.
handleError :: forall w s e e' a. (e -> Contract w s e' a) -> Contract w s e a -> Contract w s e' a

-- | Transform any exceptions thrown by the <a>Contract</a> using the given
--   function.
mapError :: forall w s e e' a. (e -> e') -> Contract w s e a -> Contract w s e' a

-- | Turn a contract with error type <tt>e</tt> and return type <tt>a</tt>
--   into one with error type <a>Void</a> (ie. throwing no errors) that
--   returns 'Either e a'
runError :: forall w s e a. Contract w s e a -> Contract w s Void (Either e a)
type HasAwaitSlot s = (HasType SlotSymbol Slot (Input s), HasType SlotSymbol WaitingForSlot (Output s), ContractRow s)
type AwaitSlot = SlotSymbol .== (Slot, WaitingForSlot)

-- | A contract that waits until the slot is reached, then returns the
--   current slot.
awaitSlot :: forall w s e. (HasAwaitSlot s, AsContractError e) => Slot -> Contract w s e Slot

-- | The current slot number
currentSlot :: forall w s e. (HasAwaitSlot s, AsContractError e) => Contract w s e Slot

-- | Wait for a number of slots.
waitNSlots :: forall w s e. (HasAwaitSlot s, AsContractError e) => Integer -> Contract w s e Slot

-- | Run a contract until the given slot has been reached.
until :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Contract w s e a -> Slot -> Contract w s e (Maybe a)

-- | Run a contract when the given slot has been reached.
when :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Slot -> Contract w s e a -> Contract w s e a

-- | Run a contract until the given slot has been reached. <tt>timeout =
--   flip until</tt>
timeout :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Slot -> Contract w s e a -> Contract w s e (Maybe a)

-- | Wait until the first slot is reached, then run the contract until the
--   second slot is reached.
between :: forall w s e a. (HasAwaitSlot s, AsContractError e) => Slot -> Slot -> Contract w s e a -> Contract w s e (Maybe a)

-- | Repeatedly run a contract until the slot is reached, then return the
--   last result.
collectUntil :: forall w s e a b. (HasAwaitSlot s, AsContractError e) => (a -> b -> b) -> b -> Contract w s e a -> Slot -> Contract w s e b
type HasEndpoint l a s = (HasType l (EndpointValue a) (Input s), HasType l ActiveEndpoint (Output s), KnownSymbol l, ContractRow s)
newtype EndpointDescription
EndpointDescription :: String -> EndpointDescription
[getEndpointDescription] :: EndpointDescription -> String
type Endpoint l a = l .== (EndpointValue a, ActiveEndpoint)

-- | Expose an endpoint, return the data that was entered
endpoint :: forall l a w s e. (HasEndpoint l a s, AsContractError e) => Contract w s e a

-- | Expose an endpoint with some metadata. Return the data that was
--   entered.
endpointWithMeta :: forall l a w s e b. (HasEndpoint l a s, AsContractError e, ToJSON b) => b -> Contract w s e a
type HasWatchAddress s = (HasType AddressSymbol AddressChangeResponse (Input s), HasType AddressSymbol AddressChangeRequest (Output s), ContractRow s)
type WatchAddress = AddressSymbol .== (AddressChangeResponse, AddressChangeRequest)

-- | Request for information about transactions that spend or produce
--   outputs at a specific address in a slot range.
data AddressChangeRequest
AddressChangeRequest :: Slot -> Slot -> Address -> AddressChangeRequest
[acreqSlotRangeFrom] :: AddressChangeRequest -> Slot
[acreqSlotRangeTo] :: AddressChangeRequest -> Slot

-- | The address
[acreqAddress] :: AddressChangeRequest -> Address

-- | Information about transactions that spend or produce an output at an
--   address in a slot range.
data AddressChangeResponse
AddressChangeResponse :: Address -> SlotRange -> [OnChainTx] -> AddressChangeResponse

-- | The address
[acrAddress] :: AddressChangeResponse -> Address

-- | The slot range
[acrSlotRange] :: AddressChangeResponse -> SlotRange

-- | Transactions that were validated in the slot range and spent or
--   produced at least one output at the address.
[acrTxns] :: AddressChangeResponse -> [OnChainTx]

-- | Get the transactions that modified an address in a specific slot.
addressChangeRequest :: forall w s e. (HasWatchAddress s, AsContractError e, HasAwaitSlot s) => AddressChangeRequest -> Contract w s e AddressChangeResponse

-- | Call <tt>addresssChangeRequest</tt> for the address in each slot,
--   until at least one transaction is returned that modifies the address.
nextTransactionsAt :: forall w s e. (HasWatchAddress s, AsContractError e, HasAwaitSlot s) => Address -> Contract w s e [OnChainTx]

-- | Watch an address until the given slot, then return all known outputs
--   at the address.
watchAddressUntil :: forall w s e. (HasAwaitSlot s, HasUtxoAt s, AsContractError e) => Address -> Slot -> Contract w s e UtxoMap

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has surpassed the given value.
fundsAtAddressGt :: forall w s e. (AsContractError e, HasAwaitSlot s, HasUtxoAt s) => Address -> Value -> Contract w s e UtxoMap

-- | Watch an address for changes, and return the outputs at that address
--   when the total value at the address has reached or surpassed the given
--   value.
fundsAtAddressGeq :: forall w s e. (AsContractError e, HasAwaitSlot s, HasUtxoAt s) => Address -> Value -> Contract w s e UtxoMap
type HasUtxoAt s = (HasType UtxoAtSym UtxoAtAddress (Input s), HasType UtxoAtSym Address (Output s), ContractRow s)
type UtxoAt = UtxoAtSym .== (UtxoAtAddress, Address)

-- | Get the unspent transaction outputs at an address.
utxoAt :: forall w s e. (AsContractError e, HasUtxoAt s) => Address -> Contract w s e UtxoMap
type HasOwnPubKey s = (HasType OwnPubKeySym PubKey (Input s), HasType OwnPubKeySym OwnPubKeyRequest (Output s), ContractRow s)
type OwnPubKey = OwnPubKeySym .== (PubKey, OwnPubKeyRequest)

-- | Get a public key belonging to the wallet that runs this contract. *
--   Any funds paid to this public key will be treated as the wallet's own
--   funds * The wallet is able to sign transactions with the private key
--   of this public key, for example, if the public key is added to the
--   <tt>requiredSignatures</tt> field of <tt>Tx</tt>. * There is a 1-n
--   relationship between wallets and public keys (although in the
--   mockchain n=1)
ownPubKey :: forall w s e. (AsContractError e, HasOwnPubKey s) => Contract w s e PubKey
type HasOwnId s = (HasType OwnIdSym ContractInstanceId (Input s), HasType OwnIdSym OwnIdRequest (Output s), ContractRow s)

-- | Unique ID for contract instance
data ContractInstanceId

-- | Get the <a>ContractInstanceId</a> of this instance.
ownInstanceId :: forall w s e. (AsContractError e, HasOwnId s) => Contract w s e ContractInstanceId

-- | Update the contract's accumulating state <tt>w</tt>
tell :: w -> Contract w s e ()
type HasWriteTx s = (HasType TxSymbol WriteTxResponse (Input s), HasType TxSymbol UnbalancedTx (Output s), ContractRow s)
type WriteTx = TxSymbol .== (WriteTxResponse, UnbalancedTx)

-- | An error thrown by wallet interactions.
data WalletAPIError

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. The constraints do not refer to any typed script inputs
--   or outputs.
submitTx :: forall w s e. (HasWriteTx s, AsContractError e) => TxConstraints Void Void -> Contract w s e Tx

-- | A version of <a>submitTx</a> that waits until the transaction has been
--   confirmed on the ledger before returning.
submitTxConfirmed :: forall w s e. (HasWriteTx s, HasTxConfirmation s, AsContractError e) => UnbalancedTx -> Contract w s e ()

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the current outputs at the contract address and the
--   contract's own public key to solve the constraints.
submitTxConstraints :: forall a w s e. (HasWriteTx s, IsData (RedeemerType a), IsData (DatumType a), AsContractError e) => TypedValidator a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e Tx

-- | Build a transaction that satisfies the constraints using the UTXO map
--   to resolve any input constraints (see <a>InputConstraint</a>)
submitTxConstraintsSpending :: forall a w s e. (HasWriteTx s, IsData (RedeemerType a), IsData (DatumType a), AsContractError e) => TypedValidator a -> UtxoMap -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e Tx

-- | Build a transaction that satisfies the constraints, then submit it to
--   the network. Using the given constraints.
submitTxConstraintsWith :: forall a w s e. (HasWriteTx s, IsData (RedeemerType a), IsData (DatumType a), AsContractError e) => ScriptLookups a -> TxConstraints (RedeemerType a) (DatumType a) -> Contract w s e Tx

-- | Send an unbalanced transaction to be balanced and signed. Returns the
--   ID of the final transaction when the transaction was submitted. Throws
--   an error if balancing or signing failed.
submitUnbalancedTx :: forall w s e. (AsContractError e, HasWriteTx s) => UnbalancedTx -> Contract w s e Tx
type HasTxConfirmation s = (HasType TxConfirmationSym TxConfirmed (Input s), HasType TxConfirmationSym TxId (Output s), ContractRow s)
type TxConfirmation = TxConfirmationSym .== (TxConfirmed, TxId)

-- | Wait until a transaction is confirmed (added to the ledger).
awaitTxConfirmed :: forall w s e. (AsContractError e, HasTxConfirmation s) => TxId -> Contract w s e ()

-- | Write the current state of the contract to a checkpoint.
checkpoint :: forall w s e a. (AsCheckpointError e, FromJSON a, ToJSON a) => Contract w s e a -> Contract w s e a
checkpointLoop :: forall w s e a b. (AsCheckpointError e, FromJSON a, ToJSON a, ToJSON b, FromJSON b) => (a -> Contract w s e (Either b a)) -> a -> Contract w s e b
class AsCheckpointError r_aooT
_CheckpointError :: AsCheckpointError r_aooT => Prism' r_aooT CheckpointError
_JSONDecodeError :: AsCheckpointError r_aooT => Prism' r_aooT Text
data CheckpointError
JSONDecodeError :: Text -> CheckpointError

-- | Log a message at the <tt>Debug</tt> level
logDebug :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Info</tt> level
logInfo :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Warning</tt> level
logWarn :: ToJSON a => a -> Contract w s e ()

-- | Log a message at the <tt>Error</tt> level
logError :: ToJSON a => a -> Contract w s e ()
class r .! l  a => HasType (l :: Symbol) (a :: k) (r :: Row k)

-- | Constraints on the contract schema, ensuring that the requests
--   produced by the contracts are <a>Monoid</a>s (so that we can produce a
--   record with requests from different branches) and that the labels of
--   the schema are unique.
type ContractRow s = (AllUniqueLabels (Input s), AllUniqueLabels (Output s))
type family (l :: Row k) .\/ (r :: Row k) :: Row k
type Empty = 'R '[] :: [LT a]

module Plutus.Trace.Emulator.Types

-- | Messages sent to, and received by, threads in the emulator.
data EmulatorMessage

-- | A new slot has begun and some blocks were added.
NewSlot :: [Block] -> Slot -> EmulatorMessage

-- | Call to an endpoint
EndpointCall :: ThreadId -> EndpointDescription -> Value -> EmulatorMessage

-- | Tell the contract instance to freeze itself (see note [Freeze and
--   Thaw])
Freeze :: EmulatorMessage

-- | Request for the current state of a contract instance
ContractInstanceStateRequest :: ThreadId -> EmulatorMessage

-- | Response to a contract instance state request
ContractInstanceStateResponse :: Value -> EmulatorMessage

-- | A map of contract instance ID to thread ID
newtype EmulatorThreads
EmulatorThreads :: Map ContractInstanceId ThreadId -> EmulatorThreads
[_instanceIdThreads] :: EmulatorThreads -> Map ContractInstanceId ThreadId
instanceIdThreads :: Iso' EmulatorThreads (Map ContractInstanceId ThreadId)

-- | Effects available to emulator agent threads. Includes emulated wallet
--   effects and effects related to threading / waiting for messages.
type EmulatorAgentThreadEffs effs = LogMsg ContractInstanceLog : EmulatedWalletEffects' (Yield (AgentSystemCall EmulatorMessage) (Maybe EmulatorMessage) : Reader ThreadId : effs)
type EmulatedWalletEffects = EmulatedWalletEffects' '[]

-- | Effects that are used to handle requests by contract instances. In the
--   emulator these effects are handled by <a>MultiAgent</a>. In the PAB
--   they are handled by the actual wallet<i>node</i>chain index, mediated
--   by the PAB runtime.
type EmulatedWalletEffects' effs = WalletEffect : Error WalletAPIError : NodeClientEffect : ChainIndexEffect : LogObserve (LogMessage Text) : LogMsg RequestHandlerLogMsg : LogMsg TxBalanceMsg : LogMsg Text : effs

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
newtype ContractInstanceTag
ContractInstanceTag :: Text -> ContractInstanceTag
[unContractInstanceTag] :: ContractInstanceTag -> Text

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | A reference to a running contract in the emulator.
data ContractHandle w s e
ContractHandle :: Contract w s e () -> ContractInstanceId -> ContractInstanceTag -> ContractHandle w s e
[chContract] :: ContractHandle w s e -> Contract w s e ()
[chInstanceId] :: ContractHandle w s e -> ContractInstanceId
[chInstanceTag] :: ContractHandle w s e -> ContractInstanceTag
data Emulator
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)

-- | The state of a running contract instance with schema <tt>s</tt> and
--   error type <tt>e</tt> Serialisable to JSON.
data ContractInstanceState w s e a
ContractInstanceState :: ResumableResult w e (Event s) (Handlers s) a -> Seq (Response (Event s)) -> Seq [Request (Handlers s)] -> ContractInstanceState w s e a
[instContractState] :: ContractInstanceState w s e a -> ResumableResult w e (Event s) (Handlers s) a

-- | Events received by the contract instance. (Used for debugging
--   purposes)
[instEvents] :: ContractInstanceState w s e a -> Seq (Response (Event s))

-- | Requests issued by the contract instance (Used for debugging purposes)
[instHandlersHistory] :: ContractInstanceState w s e a -> Seq [Request (Handlers s)]

-- | State of the contract instance, internal to the contract instance
--   thread. It contains both the serialisable state of the contract
--   instance and the non-serialisable continuations in
--   <a>SuspendedContract</a>.
data ContractInstanceStateInternal w s e a
ContractInstanceStateInternal :: SuspendedContract w e (Event s) (Handlers s) a -> Seq (Response (Event s)) -> Seq [Request (Handlers s)] -> ContractInstanceStateInternal w s e a
[cisiSuspState] :: ContractInstanceStateInternal w s e a -> SuspendedContract w e (Event s) (Handlers s) a
[cisiEvents] :: ContractInstanceStateInternal w s e a -> Seq (Response (Event s))
[cisiHandlersHistory] :: ContractInstanceStateInternal w s e a -> Seq [Request (Handlers s)]
emptyInstanceState :: Monoid w => Contract w s e a -> ContractInstanceStateInternal w s e a
addEventInstanceState :: forall w s e a. Monoid w => Response (Event s) -> ContractInstanceStateInternal w s e a -> Maybe (ContractInstanceStateInternal w s e a)

-- | Extract the serialisable <a>ContractInstanceState</a> from the
--   <a>ContractInstanceStateInternal</a>. We need to do this when we want
--   to send the instance state to another thread.
toInstanceState :: ContractInstanceStateInternal w s e a -> ContractInstanceState w s e a
data ContractInstanceLog
ContractInstanceLog :: ContractInstanceMsg -> ContractInstanceId -> ContractInstanceTag -> ContractInstanceLog
[_cilMessage] :: ContractInstanceLog -> ContractInstanceMsg
[_cilId] :: ContractInstanceLog -> ContractInstanceId
[_cilTag] :: ContractInstanceLog -> ContractInstanceTag
cilId :: Lens' ContractInstanceLog ContractInstanceId
cilMessage :: Lens' ContractInstanceLog ContractInstanceMsg
cilTag :: Lens' ContractInstanceLog ContractInstanceTag
data EmulatorRuntimeError
ThreadIdNotFound :: ContractInstanceId -> EmulatorRuntimeError
InstanceIdNotFound :: Wallet -> EmulatorRuntimeError
JSONDecodingError :: String -> EmulatorRuntimeError
GenericError :: String -> EmulatorRuntimeError

-- | Log messages produced by contract instances
data ContractInstanceMsg
Started :: ContractInstanceMsg
StoppedNoError :: ContractInstanceMsg
StoppedWithError :: String -> ContractInstanceMsg
ReceiveEndpointCall :: Value -> ContractInstanceMsg
ReceiveEndpointCallSuccess :: ContractInstanceMsg
ReceiveEndpointCallFailure :: NotificationError -> ContractInstanceMsg
NoRequestsHandled :: ContractInstanceMsg
HandledRequest :: Response Value -> ContractInstanceMsg
CurrentRequests :: [Request Value] -> ContractInstanceMsg
InstErr :: EmulatorRuntimeError -> ContractInstanceMsg
ContractLog :: Value -> ContractInstanceMsg
SendingNotification :: Notification -> ContractInstanceMsg
NotificationSuccess :: Notification -> ContractInstanceMsg
NotificationFailure :: NotificationError -> ContractInstanceMsg
SendingContractState :: ThreadId -> ContractInstanceMsg
Freezing :: ContractInstanceMsg
_Started :: Prism' ContractInstanceMsg ()
_StoppedNoError :: Prism' ContractInstanceMsg ()
_StoppedWithError :: Prism' ContractInstanceMsg String
_ReceiveEndpointCall :: Prism' ContractInstanceMsg Value
_NoRequestsHandled :: Prism' ContractInstanceMsg ()
_HandledRequest :: Prism' ContractInstanceMsg (Response Value)
_CurrentRequests :: Prism' ContractInstanceMsg [Request Value]
_InstErr :: Prism' ContractInstanceMsg EmulatorRuntimeError
_ContractLog :: Prism' ContractInstanceMsg Value

-- | Log message produced by the user (main) thread
data UserThreadMsg
UserThreadErr :: EmulatorRuntimeError -> UserThreadMsg
UserLog :: String -> UserThreadMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance GHC.Classes.Ord Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.OnInitialThreadStopped
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Show.Show Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Classes.Ord Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Base.Monoid Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Base.Semigroup Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.String.IsString Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Classes.Ord Plutus.Trace.Emulator.Types.ContractInstanceTag
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceTag
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.UserThreadMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.UserThreadMsg
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.UserThreadMsg
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Trace.Emulator.Types.ContractInstanceLog
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Generics.Generic Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Show.Show Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.ContractInstanceLog
instance GHC.Generics.Generic (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance (Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.ToJSON.ToJSON, Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.ToJSON.ToJSON, Data.Aeson.Types.ToJSON.ToJSON e, Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON w) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance (Data.Row.Internal.Forall (Plutus.Contract.Schema.Input s) Data.Aeson.Types.FromJSON.FromJSON, Data.Row.Internal.Forall (Plutus.Contract.Schema.Output s) Data.Aeson.Types.FromJSON.FromJSON, Data.Aeson.Types.FromJSON.FromJSON e, Data.Aeson.Types.FromJSON.FromJSON a, Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Input s), Data.Row.Internal.AllUniqueLabels (Plutus.Contract.Schema.Output s), Data.Aeson.Types.FromJSON.FromJSON w) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Trace.Emulator.Types.ContractInstanceState w s e a)
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceLog
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.ContractInstanceMsg
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.UserThreadMsg
instance Prettyprinter.Internal.Pretty Plutus.Trace.Emulator.Types.EmulatorRuntimeError
instance GHC.Show.Show Plutus.Trace.Emulator.Types.EmulatorMessage
instance GHC.Classes.Eq Plutus.Trace.Emulator.Types.EmulatorMessage
instance GHC.Base.Monoid Plutus.Trace.Emulator.Types.EmulatorThreads
instance GHC.Base.Semigroup Plutus.Trace.Emulator.Types.EmulatorThreads

module Wallet.Emulator.MultiAgent

-- | Assertions which will be checked during execution of the emulator.
data Assertion

-- | Assert that the given transaction is validated.
IsValidated :: Tx -> Assertion

-- | Assert that the funds belonging to a wallet's public-key address are
--   equal to a value.
OwnFundsEqual :: Wallet -> Value -> Assertion

-- | An event with a timestamp measured in emulator time (currently:
--   <a>Slot</a>)
data EmulatorTimeEvent e
EmulatorTimeEvent :: Slot -> e -> EmulatorTimeEvent e
[_eteEmulatorTime] :: EmulatorTimeEvent e -> Slot
[_eteEvent] :: EmulatorTimeEvent e -> e
eteEvent :: forall e_a2S6W e_a2Smx. Lens (EmulatorTimeEvent e_a2S6W) (EmulatorTimeEvent e_a2Smx) e_a2S6W e_a2Smx
eteEmulatorTime :: forall e_a2S6W. Lens' (EmulatorTimeEvent e_a2S6W) Slot
emulatorTimeEvent :: Slot -> Prism' (EmulatorTimeEvent e) e

-- | Events produced by the blockchain emulator.
data EmulatorEvent'
ChainEvent :: ChainEvent -> EmulatorEvent'
ClientEvent :: Wallet -> NodeClientEvent -> EmulatorEvent'
WalletEvent :: Wallet -> WalletEvent -> EmulatorEvent'
ChainIndexEvent :: Wallet -> ChainIndexEvent -> EmulatorEvent'
NotificationEvent :: EmulatorNotifyLogMsg -> EmulatorEvent'
SchedulerEvent :: SchedulerLog -> EmulatorEvent'
InstanceEvent :: ContractInstanceLog -> EmulatorEvent'
UserThreadEvent :: UserThreadMsg -> EmulatorEvent'
type EmulatorEvent = EmulatorTimeEvent EmulatorEvent'
chainEvent :: Prism' EmulatorEvent' ChainEvent
walletClientEvent :: Wallet -> Prism' EmulatorEvent' NodeClientEvent
walletEvent :: Wallet -> Prism' EmulatorEvent' WalletEvent
chainIndexEvent :: Wallet -> Prism' EmulatorEvent' ChainIndexEvent
notificationEvent :: Prism' EmulatorEvent' EmulatorNotifyLogMsg
schedulerEvent :: Prism' EmulatorEvent' SchedulerLog
instanceEvent :: Prism' EmulatorEvent' ContractInstanceLog
userThreadEvent :: Prism' EmulatorEvent' UserThreadMsg
type EmulatedWalletControlEffects = '[NodeClientControlEffect, ChainIndexControlEffect, SigningProcessControlEffect, LogObserve (LogMessage Text), LogMsg Text]

-- | The type of actions in the emulator.
data MultiAgentEffect r

-- | A direct action performed by a wallet. Usually represents a "user
--   action", as it is triggered externally.
[WalletAction] :: Wallet -> Eff EmulatedWalletEffects r -> MultiAgentEffect r
data MultiAgentControlEffect r

-- | An action affecting the emulated parts of a wallet (only available in
--   emulator - see note [Control effects].)
[WalletControlAction] :: Wallet -> Eff EmulatedWalletControlEffects r -> MultiAgentControlEffect r

-- | An assertion in the event stream, which can inspect the current state.
[Assertion] :: Assertion -> MultiAgentControlEffect ()

-- | Run an action in the context of a wallet (ie. agent)
walletAction :: Member MultiAgentEffect effs => Wallet -> Eff EmulatedWalletEffects r -> Eff effs r
handleMultiAgentEffects :: forall effs. Member MultiAgentEffect effs => Wallet -> Eff (EmulatedWalletEffects' effs) ~> Eff effs
raiseWallet :: forall f effs. (Member f EmulatedWalletEffects, Member MultiAgentEffect effs) => Wallet -> f ~> Eff effs

-- | Run a control action in the context of a wallet
walletControlAction :: Member MultiAgentControlEffect effs => Wallet -> Eff EmulatedWalletControlEffects r -> Eff effs r
assertion :: Member MultiAgentControlEffect effs => Assertion -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
assertOwnFundsEq :: Member MultiAgentControlEffect effs => Wallet -> Value -> Eff effs ()

-- | Issue an assertion that the given transaction has been validated.
assertIsValidated :: Member MultiAgentControlEffect effs => Tx -> Eff effs ()

-- | The state of the emulator itself.
data EmulatorState
EmulatorState :: ChainState -> Map Wallet WalletState -> [LogMessage EmulatorEvent] -> EmulatorState

-- | Mockchain
[_chainState] :: EmulatorState -> ChainState

-- | The state of each agent.
[_walletStates] :: EmulatorState -> Map Wallet WalletState

-- | The emulator log messages, with the newest last.
[_emulatorLog] :: EmulatorState -> [LogMessage EmulatorEvent]
walletStates :: Lens' EmulatorState (Map Wallet WalletState)
emulatorLog :: Lens' EmulatorState [LogMessage EmulatorEvent]
chainState :: Lens' EmulatorState ChainState
walletState :: Wallet -> Lens' EmulatorState WalletState

-- | Get the blockchain as a list of blocks, starting with the oldest
--   (genesis) block.
chainOldestFirst :: Lens' EmulatorState Blockchain
chainUtxo :: Getter EmulatorState AddressMap

-- | Get a map with the total value of each wallet's "own funds".
fundsDistribution :: EmulatorState -> Map Wallet Value

-- | Get the emulator log.
emLog :: EmulatorState -> [LogMessage EmulatorEvent]
emptyEmulatorState :: EmulatorState

-- | Initialise the emulator state with a blockchain.
emulatorState :: Blockchain -> EmulatorState

-- | Initialise the emulator state with a pool of pending transactions.
emulatorStatePool :: TxPool -> EmulatorState

-- | Initialise the emulator state with a single pending transaction that
--   creates the initial distribution of funds to public key addresses.
emulatorStateInitialDist :: Map PubKey Value -> EmulatorState
type MultiAgentEffs = '[State EmulatorState, LogMsg EmulatorEvent', Error WalletAPIError, Error AssertionError, ChainEffect, ChainControlEffect]
handleMultiAgentControl :: forall effs. Members MultiAgentEffs effs => Eff (MultiAgentControlEffect : effs) ~> Eff effs
handleMultiAgent :: forall effs. Members MultiAgentEffs effs => Eff (MultiAgentEffect : effs) ~> Eff effs

-- | Issue an <a>Assertion</a>.
assert :: Members MultiAgentEffs effs => Assertion -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
ownFundsEqual :: Members MultiAgentEffs effs => Wallet -> Value -> Eff effs ()

-- | Issue an assertion that the given transaction has been validated.
isValidated :: Members MultiAgentEffs effs => Tx -> Eff effs ()
_singleton :: AReview [a] a
instance Data.Aeson.Types.FromJSON.FromJSON Wallet.Emulator.MultiAgent.EmulatorEvent'
instance Data.Aeson.Types.ToJSON.ToJSON Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Generics.Generic Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Show.Show Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Classes.Eq Wallet.Emulator.MultiAgent.EmulatorEvent'
instance GHC.Show.Show Wallet.Emulator.MultiAgent.EmulatorState
instance Prettyprinter.Internal.Pretty Wallet.Emulator.MultiAgent.EmulatorEvent'
instance Prettyprinter.Internal.Pretty e => Prettyprinter.Internal.Pretty (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Aeson.Types.FromJSON.FromJSON e => Data.Aeson.Types.FromJSON.FromJSON (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Aeson.Types.ToJSON.ToJSON e => Data.Aeson.Types.ToJSON.ToJSON (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance Data.Traversable.Traversable Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance Data.Foldable.Foldable Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance GHC.Base.Functor Wallet.Emulator.MultiAgent.EmulatorTimeEvent
instance GHC.Generics.Generic (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance GHC.Show.Show e => GHC.Show.Show (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Wallet.Emulator.MultiAgent.EmulatorTimeEvent e)

module Wallet.Emulator.Types

-- | A wallet in the emulator model.
newtype Wallet
Wallet :: Integer -> Wallet
[getWallet] :: Wallet -> Integer

-- | Get a wallet's public key.
walletPubKey :: Wallet -> PubKey

-- | Get a wallet's private key by looking it up in the list of private
--   keys in <a>knownPrivateKeys</a>
walletPrivKey :: Wallet -> PrivateKey

-- | Sign a <a>Tx</a> using the wallet's privat key.
signWithWallet :: Wallet -> Tx -> Tx

-- | Sign the transaction with a <a>PrivateKey</a> and add the signature to
--   the transaction's list of signatures.
addSignature :: PrivateKey -> Tx -> Tx

-- | A pool of transactions which have yet to be validated.
type TxPool = [Tx]
type EmulatorEffs = '[MultiAgentEffect, ChainEffect, ChainControlEffect]

-- | Assertions which will be checked during execution of the emulator.
data Assertion

-- | Assert that the given transaction is validated.
IsValidated :: Tx -> Assertion

-- | Assert that the funds belonging to a wallet's public-key address are
--   equal to a value.
OwnFundsEqual :: Wallet -> Value -> Assertion

-- | Issue an <a>Assertion</a>.
assert :: Members MultiAgentEffs effs => Assertion -> Eff effs ()

-- | Issue an assertion that the given transaction has been validated.
assertIsValidated :: Member MultiAgentControlEffect effs => Tx -> Eff effs ()

-- | An error emitted when an <tt>Assertion</tt> fails.
newtype AssertionError
GenericAssertion :: Text -> AssertionError
[unAssertionError] :: AssertionError -> Text
class AsAssertionError r_a1CPT
_AssertionError :: AsAssertionError r_a1CPT => Prism' r_a1CPT AssertionError
_GenericAssertion :: AsAssertionError r_a1CPT => Prism' r_a1CPT Text
data ChainClientNotification
BlockValidated :: Block -> ChainClientNotification
SlotChanged :: Slot -> ChainClientNotification
type EmulatorEvent = EmulatorTimeEvent EmulatorEvent'

-- | Events produced by the blockchain emulator.
data EmulatorEvent'

-- | An event with a timestamp measured in emulator time (currently:
--   <a>Slot</a>)
data EmulatorTimeEvent e
EmulatorTimeEvent :: Slot -> e -> EmulatorTimeEvent e
[_eteEmulatorTime] :: EmulatorTimeEvent e -> Slot
[_eteEvent] :: EmulatorTimeEvent e -> e

-- | The state used by the mock wallet environment.
data WalletState
WalletState :: PrivateKey -> NodeClientState -> ChainIndexState -> SigningProcess -> WalletState

-- | User's <a>PrivateKey</a>.
[_ownPrivateKey] :: WalletState -> PrivateKey
[_nodeClient] :: WalletState -> NodeClientState
[_chainIndex] :: WalletState -> ChainIndexState
[_signingProcess] :: WalletState -> SigningProcess

-- | An empty wallet state with the public/private key pair for a wallet,
--   and the public-key address for that wallet as the sole watched
--   address.
emptyWalletState :: Wallet -> WalletState
ownPrivateKey :: Lens' WalletState PrivateKey

-- | Get the user's own public-key address.
ownAddress :: WalletState -> Address

-- | Run an action in the context of a wallet (ie. agent)
walletAction :: Member MultiAgentEffect effs => Wallet -> Eff EmulatedWalletEffects r -> Eff effs r
assertion :: Member MultiAgentControlEffect effs => Assertion -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
assertOwnFundsEq :: Member MultiAgentControlEffect effs => Wallet -> Value -> Eff effs ()

-- | Issue an assertion that the funds for a given wallet have the given
--   value.
ownFundsEqual :: Members MultiAgentEffs effs => Wallet -> Value -> Eff effs ()

-- | The state of the emulator itself.
data EmulatorState
EmulatorState :: ChainState -> Map Wallet WalletState -> [LogMessage EmulatorEvent] -> EmulatorState

-- | Mockchain
[_chainState] :: EmulatorState -> ChainState

-- | The state of each agent.
[_walletStates] :: EmulatorState -> Map Wallet WalletState

-- | The emulator log messages, with the newest last.
[_emulatorLog] :: EmulatorState -> [LogMessage EmulatorEvent]
emptyEmulatorState :: EmulatorState

-- | Initialise the emulator state with a blockchain.
emulatorState :: Blockchain -> EmulatorState

-- | Initialise the emulator state with a pool of pending transactions.
emulatorStatePool :: TxPool -> EmulatorState

-- | Initialise the emulator state with a single pending transaction that
--   creates the initial distribution of funds to public key addresses.
emulatorStateInitialDist :: Map PubKey Value -> EmulatorState
txPool :: Lens' ChainState TxPool
walletStates :: Lens' EmulatorState (Map Wallet WalletState)
index :: Lens' ChainState UtxoIndex
chainState :: Lens' EmulatorState ChainState
currentSlot :: Lens' ChainState Slot
processEmulated :: forall effs. (Member (Error WalletAPIError) effs, Member (Error AssertionError) effs, Member (State EmulatorState) effs, Member (LogMsg EmulatorEvent') effs) => Eff (MultiAgentEffect : (MultiAgentControlEffect : (ChainEffect : (ChainControlEffect : effs)))) ~> Eff effs

-- | Get a map with the total value of each wallet's "own funds".
fundsDistribution :: EmulatorState -> Map Wallet Value

-- | Get the emulator log.
emLog :: EmulatorState -> [LogMessage EmulatorEvent]

-- | Given a set of <tt>a</tt>s with coin values, and a target value,
--   select a number of <tt>a</tt> such that their total value is greater
--   than or equal to the target.
selectCoin :: Member (Error WalletAPIError) effs => [(a, Value)] -> Value -> Eff effs ([(a, Value)], Value)

module Wallet.Emulator


-- | Turn <a>UnbalancedTx</a> values into transactions using the wallet
--   API.
module Plutus.Contract.Wallet

-- | Balance an unbalanced transaction in a <a>WalletEffects</a> context.
--   See note [Submitting transactions from Plutus contracts].
balanceWallet :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member ChainIndexEffect effs, Member (LogMsg TxBalanceMsg) effs) => UnbalancedTx -> Eff effs Tx

-- | Balance an unbalanced transaction by adding public key inputs and
--   outputs and by adding enough collateral inputs.
balanceTx :: (Member WalletEffect effs, Member (Error WalletAPIError) effs, Member ChainIndexEffect effs, Member (LogMsg TxBalanceMsg) effs) => UtxoMap -> PubKey -> UnbalancedTx -> Eff effs Tx

-- | Balance an unabalanced transaction, sign it, and submit it to the
--   chain in the context of a wallet.
handleTx :: (Member WalletEffect effs, Member ChainIndexEffect effs, Member (LogMsg TxBalanceMsg) effs, Member (Error WalletAPIError) effs) => UnbalancedTx -> Eff effs Tx
startWatching :: forall effs_a1WLD. Member ChainIndexEffect effs_a1WLD => Address -> Eff effs_a1WLD ()

module Plutus.Contract.Trace.RequestHandler

-- | Request handlers that can choose whether to handle an effect (using
--   <a>Alternative</a>). This is useful if <tt>req</tt> is a sum type.
newtype RequestHandler effs req resp
RequestHandler :: (req -> Eff (NonDet : effs) resp) -> RequestHandler effs req resp
[unRequestHandler] :: RequestHandler effs req resp -> req -> Eff (NonDet : effs) resp
data RequestHandlerLogMsg
SlotNoficationTargetVsCurrent :: Slot -> Slot -> RequestHandlerLogMsg
StartWatchingContractAddresses :: RequestHandlerLogMsg
HandleAddressChangedAt :: Slot -> SlotRange -> RequestHandlerLogMsg
HandleTxFailed :: WalletAPIError -> RequestHandlerLogMsg
UtxoAtFailed :: Address -> RequestHandlerLogMsg
tryHandler :: forall effs req resp. RequestHandler effs req resp -> [req] -> Eff effs (Maybe resp)
tryHandler' :: forall f effs req resp. (Alternative f, Monad f) => RequestHandler effs req (f resp) -> [req] -> Eff effs (f resp)
wrapHandler :: RequestHandler effs req resp -> RequestHandler effs (Request req) (Response resp)
extract :: Alternative f => Prism' a b -> a -> f b
maybeToHandler :: (req -> Maybe resp) -> RequestHandler effs req resp
handleOwnPubKey :: forall a effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs) => RequestHandler effs a PubKey
handleSlotNotifications :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs) => RequestHandler effs Slot Slot
handlePendingTransactions :: forall effs. (Member WalletEffect effs, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member (LogMsg TxBalanceMsg) effs, Member ChainIndexEffect effs) => RequestHandler effs UnbalancedTx (Either WalletAPIError Tx)
handleUtxoQueries :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member ChainIndexEffect effs) => RequestHandler effs Address UtxoAtAddress
handleTxConfirmedQueries :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member ChainIndexEffect effs) => RequestHandler effs TxId TxConfirmed
handleAddressChangedAtQueries :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member WalletEffect effs, Member ChainIndexEffect effs) => RequestHandler effs AddressChangeRequest AddressChangeResponse
handleOwnInstanceIdQueries :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member (Reader ContractInstanceId) effs) => RequestHandler effs OwnIdRequest ContractInstanceId
handleContractNotifications :: forall effs. (Member (LogObserve (LogMessage Text)) effs, Member ContractRuntimeEffect effs) => RequestHandler effs Notification (Maybe NotificationError)
instance GHC.Base.Monoid (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req resp)
instance GHC.Base.Semigroup (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req resp)
instance Control.Arrow.Arrow (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance Control.Category.Category (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance Data.Profunctor.Unsafe.Profunctor (Plutus.Contract.Trace.RequestHandler.RequestHandler effs)
instance GHC.Base.Functor (Plutus.Contract.Trace.RequestHandler.RequestHandler effs req)


-- | Interfacing with the wallet (for making payments)
module Plutus.Trace.Effects.EmulatedWalletAPI
data EmulatedWalletAPI r
[LiftWallet] :: Wallet -> Eff '[WalletEffect] a -> EmulatedWalletAPI a
liftWallet :: forall a_a3dMS. forall effs_a3dNr. Member EmulatedWalletAPI effs_a3dNr => Wallet -> Eff ('(:) WalletEffect ('[] :: [Type -> Type])) a_a3dMS -> Eff effs_a3dNr a_a3dMS

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId

-- | Handle the <a>EmulatedWalletAPI</a> effect using the emulator's
--   <tt>MultiAgent</tt> effect.
handleEmulatedWalletAPI :: Member MultiAgentEffect effs => EmulatedWalletAPI ~> Eff effs

module Plutus.Trace.Emulator.System

-- | Start the system threads.
launchSystemThreads :: forall effs. (Member ChainControlEffect effs, Member MultiAgentEffect effs, Member MultiAgentControlEffect effs) => [Wallet] -> Eff (Yield (EmSystemCall effs EmulatorMessage) (Maybe EmulatorMessage) : effs) ()


-- | Waiting for things to happen
module Plutus.Trace.Effects.Waiting
data Waiting r
[WaitUntilSlot] :: Slot -> Waiting Slot
waitUntilSlot :: forall effs_a3eOA. Member Waiting effs_a3eOA => Slot -> Eff effs_a3eOA Slot

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot
handleWaiting :: forall effs effs2. Member (Yield (EmSystemCall effs2 EmulatorMessage) (Maybe EmulatorMessage)) effs => Waiting ~> Eff effs


-- | A trace is a sequence of actions by simulated wallets that can be run
--   on the mockchain. This module contains the functions needed to build
--   traces.
module Plutus.Contract.Trace

-- | Error produced while running a trace. Either a contract-specific error
--   (of type <tt>e</tt>), or an <a>AssertionError</a> from the emulator.
data TraceError e
TraceAssertionError :: AssertionError -> TraceError e
TContractError :: e -> TraceError e
HookError :: EndpointError -> TraceError e
data EndpointError
EndpointNotActive :: Maybe Wallet -> EndpointDescription -> EndpointError
class AsTraceError r_a3fva e_a3f48 | r_a3fva -> e_a3f48
_TraceError :: AsTraceError r_a3fva e_a3f48 => Prism' r_a3fva (TraceError e_a3f48)
_TraceAssertionError :: AsTraceError r_a3fva e_a3f48 => Prism' r_a3fva AssertionError
_TContractError :: AsTraceError r_a3fva e_a3f48 => Prism' r_a3fva e_a3f48
_HookError :: AsTraceError r_a3fva e_a3f48 => Prism' r_a3fva EndpointError
toNotifyError :: ContractInstanceId -> EndpointError -> NotificationError

-- | Look at the "utxo-at" requests of the contract and respond to all of
--   them with the current UTXO set at the given address.
handleUtxoQueries :: (HasUtxoAt s, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member ChainIndexEffect effs) => RequestHandler effs (Handlers s) (Event s)
handleAddressChangedAtQueries :: (HasWatchAddress s, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member WalletEffect effs, Member ChainIndexEffect effs) => RequestHandler effs (Handlers s) (Event s)
handleBlockchainQueries :: (HasWriteTx s, HasUtxoAt s, HasTxConfirmation s, HasOwnPubKey s, HasWatchAddress s, HasOwnId s, HasAwaitSlot s) => RequestHandler (Reader ContractInstanceId : (ContractRuntimeEffect : EmulatedWalletEffects)) (Handlers s) (Event s)
handleSlotNotifications :: (HasAwaitSlot s, Member (LogObserve (LogMessage Text)) effs, Member (LogMsg RequestHandlerLogMsg) effs, Member WalletEffect effs) => RequestHandler effs (Handlers s) (Event s)
type InitialDistribution = Map Wallet Value
defaultDist :: InitialDistribution
defaultDistFor :: [Wallet] -> InitialDistribution

-- | A wallet in the emulator model.
newtype Wallet
Wallet :: Integer -> Wallet
[getWallet] :: Wallet -> Integer

-- | Get a wallet's public key.
walletPubKey :: Wallet -> PubKey

-- | Get a wallet's private key by looking it up in the list of private
--   keys in <a>knownPrivateKeys</a>
walletPrivKey :: Wallet -> PrivateKey

-- | The wallets used in mockchain simulations by default. There are ten
--   wallets because the emulator comes with ten private keys.
allWallets :: [Wallet]
makeTimed :: Member (State EmulatorState) effs => EmulatorNotifyLogMsg -> Eff effs EmulatorEvent
instance Plutus.Contract.Trace.AsTraceError (Plutus.Contract.Trace.TraceError e) e
instance Wallet.Types.AsAssertionError (Plutus.Contract.Trace.TraceError e)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.Trace.EndpointError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.Trace.EndpointError
instance GHC.Generics.Generic Plutus.Contract.Trace.EndpointError
instance GHC.Show.Show Plutus.Contract.Trace.EndpointError
instance GHC.Classes.Eq Plutus.Contract.Trace.EndpointError
instance GHC.Show.Show e => GHC.Show.Show (Plutus.Contract.Trace.TraceError e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Plutus.Contract.Trace.TraceError e)
instance Prettyprinter.Internal.Pretty Plutus.Contract.Trace.EndpointError

module Plutus.Trace.Emulator.ContractInstance

-- | Start a new thread for a contract. Most of the work happens in
--   <a>runInstance</a>.
contractThread :: forall w s e effs. (Member (State EmulatorThreads) effs, Member (Error EmulatorRuntimeError) effs, ContractConstraints s, HasBlockchainActions s, Show e, ToJSON e, ToJSON w, Monoid w) => ContractHandle w s e -> Eff (EmulatorAgentThreadEffs effs) ()
getThread :: forall effs. (Member (State EmulatorThreads) effs, Member (Error EmulatorRuntimeError) effs) => ContractInstanceId -> Eff effs ThreadId
data EmulatorRuntimeError

-- | Run an instance of a contract
runInstance :: forall w s e effs. (ContractConstraints s, HasBlockchainActions s, Member (Error EmulatorRuntimeError) effs, Show e, ToJSON e, ToJSON w, Monoid w) => Contract w s e () -> Maybe EmulatorMessage -> Eff (ContractInstanceThreadEffs w s e effs) ()

-- | The state of a running contract instance with schema <tt>s</tt> and
--   error type <tt>e</tt> Serialisable to JSON.
data ContractInstanceState w s e a
ContractInstanceState :: ResumableResult w e (Event s) (Handlers s) a -> Seq (Response (Event s)) -> Seq [Request (Handlers s)] -> ContractInstanceState w s e a
[instContractState] :: ContractInstanceState w s e a -> ResumableResult w e (Event s) (Handlers s) a

-- | Events received by the contract instance. (Used for debugging
--   purposes)
[instEvents] :: ContractInstanceState w s e a -> Seq (Response (Event s))

-- | Requests issued by the contract instance (Used for debugging purposes)
[instHandlersHistory] :: ContractInstanceState w s e a -> Seq [Request (Handlers s)]
emptyInstanceState :: Monoid w => Contract w s e a -> ContractInstanceStateInternal w s e a
addEventInstanceState :: forall w s e a. Monoid w => Response (Event s) -> ContractInstanceStateInternal w s e a -> Maybe (ContractInstanceStateInternal w s e a)
getHooks :: forall w s e effs. Member (State (ContractInstanceStateInternal w s e ())) effs => Eff effs [Request (Handlers s)]

-- | Add a <a>Response</a> to the contract instance state
addResponse :: forall w s e effs. (Member (State (ContractInstanceStateInternal w s e ())) effs, Member (LogMsg ContractInstanceMsg) effs, Monoid w) => Response (Event s) -> Eff effs ()


-- | Running emulator actions that produce streams of events
module Wallet.Emulator.Stream
data EmulatorConfig
EmulatorConfig :: InitialChainState -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState
data EmulatorErr
WalletErr :: WalletAPIError -> EmulatorErr
AssertionErr :: AssertionError -> EmulatorErr
InstanceErr :: EmulatorRuntimeError -> EmulatorErr
type InitialChainState = Either InitialDistribution TxPool
initialChainState :: Iso' EmulatorConfig InitialChainState

-- | The wallets' initial funds
initialDist :: InitialChainState -> InitialDistribution
initialState :: EmulatorConfig -> EmulatorState

-- | Turn an emulator action into a <a>Stream</a> of emulator log messages,
--   returning the final state of the emulator.
runTraceStream :: forall effs. EmulatorConfig -> Eff '[State EmulatorState, LogMsg EmulatorEvent', MultiAgentEffect, MultiAgentControlEffect, ChainEffect, ChainControlEffect, Error EmulatorRuntimeError] () -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Maybe EmulatorErr, EmulatorState)

-- | Finish the stream at the end of the given slot.
takeUntilSlot :: forall effs a. Slot -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) ()

-- | Remove from the stream all log messages whose log level is lower than
--   the the given level.
filterLogLevel :: forall effs a. LogLevel -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a

-- | Apply a fold to an effectful stream of events.
foldStreamM :: forall m a b c. Monad m => FoldM m a b -> Stream (Of a) m c -> m (Of b c)

-- | Consume an emulator event stream.
foldEmulatorStreamM :: forall effs a b. FoldM (Eff effs) EmulatorEvent b -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) a -> Eff effs (Of b a)
instance GHC.Show.Show Wallet.Emulator.Stream.EmulatorConfig
instance GHC.Classes.Eq Wallet.Emulator.Stream.EmulatorConfig
instance GHC.Show.Show Wallet.Emulator.Stream.EmulatorErr
instance Data.Default.Class.Default Wallet.Emulator.Stream.EmulatorConfig

module Wallet.Emulator.Folds
type EmulatorEventFold a = Fold EmulatorEvent a

-- | A fold over emulator events that can fail with <a>EmulatorFoldErr</a>
type EmulatorEventFoldM effs a = FoldM (Eff effs) EmulatorEvent a
data EmulatorFoldErr
InstanceStateJSONDecodingError :: String -> Response Value -> EmulatorFoldErr

-- | A human-readable explanation of the error, to be included in the logs.
describeError :: EmulatorFoldErr -> String

-- | The state of a contract instance, recovered from the emulator log.
instanceState :: forall w s e a effs. (ContractConstraints s, Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs (Maybe (ContractInstanceState w s e a))

-- | The list of open requests of the contract instance at its latest
--   iteration
instanceRequests :: forall w s e a effs. (ContractConstraints s, Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [Request (Handlers s)]

-- | The reponses received by the contract instance
instanceResponses :: forall w s e a effs. (ContractConstraints s, Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [Response (Event s)]

-- | The final state of the instance
instanceOutcome :: forall w s e a effs. (ContractConstraints s, Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs (Outcome e a)

-- | The unbalanced transactions generated by the contract instance.
instanceTransactions :: forall w s e a effs. (ContractConstraints s, HasWriteTx s, Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs [UnbalancedTx]
data Outcome e a

-- | The contract finished without errors and produced a result
Done :: a -> Outcome e a

-- | The contract is waiting for more input.
NotDone :: Outcome e a

-- | The contract failed with an error.
Failed :: e -> Outcome e a

-- | The log messages produced by the contract instance.
instanceLog :: ContractInstanceTag -> EmulatorEventFold [EmulatorTimeEvent ContractInstanceLog]

-- | Accumulated state of the contract instance
instanceAccumState :: forall w s e a effs. (ContractConstraints s, Member (Error EmulatorFoldErr) effs, Monoid w) => Contract w s e a -> ContractInstanceTag -> EmulatorEventFoldM effs w

-- | All chain events emitted by the node
chainEvents :: EmulatorEventFold [ChainEvent]

-- | Transactions that failed to validate, in the given validation phase
--   (if specified).
failedTransactions :: Maybe ValidationPhase -> EmulatorEventFold [(TxId, Tx, ValidationError, [ScriptValidationEvent])]

-- | Transactions that were validated
validatedTransactions :: EmulatorEventFold [(TxId, Tx, [ScriptValidationEvent])]

-- | All scripts that are run during transaction validation
scriptEvents :: EmulatorEventFold [ScriptValidationEvent]

-- | Unspent outputs at an address
utxoAtAddress :: Address -> EmulatorEventFold UtxoMap

-- | The total value of unspent outputs at an address
valueAtAddress :: Address -> EmulatorEventFold Value

-- | Whether the wallet is watching an address
walletWatchingAddress :: Wallet -> Address -> EmulatorEventFold Bool

-- | The funds belonging to a wallet
walletFunds :: Wallet -> EmulatorEventFold Value

-- | The fees paid by a wallet
walletFees :: Wallet -> EmulatorEventFold Value

-- | Annotate the transactions that were validated by the node
annotatedBlockchain :: EmulatorEventFold [[AnnotatedTx]]

-- | All transactions that happened during the simulation
blockchain :: EmulatorEventFold [Block]

-- | The list of all emulator events
emulatorLog :: EmulatorEventFold [EmulatorEvent]

-- | Log and error messages produced by the main (user) thread in the
--   emulator
userLog :: EmulatorEventFold [EmulatorTimeEvent UserThreadMsg]

-- | Pretty-print each element into a new line.
renderLines :: forall a. Pretty a => Fold a Text

-- | An effectful <a>mapMaybe</a> for <a>FoldM</a>.
preMapMaybeM :: Monad m => (a -> m (Maybe b)) -> FoldM m b r -> FoldM m a r

-- | <a>mapMaybe</a> for <a>Fold</a>.
preMapMaybe :: (a -> Maybe b) -> Fold b r -> Fold a r

-- | Effectfully map the result of a <a>FoldM</a>
postMapM :: Monad m => (b -> m c) -> FoldM m a b -> FoldM m a c
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (Wallet.Emulator.Folds.Outcome e a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (Wallet.Emulator.Folds.Outcome e a)
instance GHC.Show.Show Wallet.Emulator.Folds.EmulatorFoldErr
instance GHC.Classes.Ord Wallet.Emulator.Folds.EmulatorFoldErr
instance GHC.Classes.Eq Wallet.Emulator.Folds.EmulatorFoldErr

module Wallet.Rollup.Render
showBlockchain :: [(PubKeyHash, Wallet)] -> Blockchain -> Either Text Text
showBlockchainFold :: [(PubKeyHash, Wallet)] -> EmulatorEventFold (Either Text Text)
instance Wallet.Rollup.Render.Render PlutusTx.Data.Data
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.Value
instance Wallet.Rollup.Render.Render Data.Text.Internal.Text
instance Wallet.Rollup.Render.Render GHC.Base.String
instance Wallet.Rollup.Render.Render GHC.Integer.Type.Integer
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Address.Address
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.TxId.TxId
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.ValidatorHash
instance Prettyprinter.Internal.Pretty a => Wallet.Rollup.Render.Render (Wallet.Rollup.Render.RenderPretty a)
instance Wallet.Rollup.Render.Render [[Wallet.Rollup.Types.AnnotatedTx]]
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.AnnotatedTx
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.SequenceId
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.CurrencySymbol
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Value.TokenName
instance Wallet.Rollup.Render.Render Data.ByteString.Internal.ByteString
instance (Wallet.Rollup.Render.Render k, Wallet.Rollup.Render.Render v) => Wallet.Rollup.Render.Render (PlutusTx.AssocMap.Map k v)
instance Wallet.Rollup.Render.Render (Data.Map.Internal.Map Wallet.Rollup.Types.BeneficialOwner Plutus.V1.Ledger.Value.Value)
instance Wallet.Rollup.Render.Render (Data.Map.Internal.Map Plutus.V1.Ledger.Crypto.PubKey Plutus.V1.Ledger.Crypto.Signature)
instance Wallet.Rollup.Render.Render Wallet.Emulator.Wallet.Wallet
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.BeneficialOwner
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Ada.Ada
instance Wallet.Rollup.Render.Render (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Crypto.PubKey
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Crypto.PubKeyHash
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Crypto.Signature
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Script
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Validator
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Scripts.Datum
instance Wallet.Rollup.Render.Render a => Wallet.Rollup.Render.Render (Data.Set.Internal.Set a)
instance Wallet.Rollup.Render.Render Wallet.Rollup.Types.DereferencedInput
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxIn
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxInType
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxOutRef
instance Wallet.Rollup.Render.Render Plutus.V1.Ledger.Tx.TxOut

module Plutus.Trace.Effects.RunContract

-- | Run a Plutus contract (client side)
data RunContract r
[ActivateContract] :: (ContractConstraints s, HasBlockchainActions s, Show e, FromJSON e, ToJSON e, ToJSON w, Monoid w, FromJSON w) => Wallet -> Contract w s e a -> ContractInstanceTag -> RunContract (ContractHandle w s e)
[CallEndpointP] :: forall l ep w s e. (ContractConstraints s, HasEndpoint l ep s) => Proxy l -> ContractHandle w s e -> ep -> RunContract ()
[GetContractState] :: forall w s e. (ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> RunContract (ContractInstanceState w s e ())
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), AllUniqueLabels (Output s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
activateContract :: forall (s_X3vkM :: Row Type) e_X3vkO w_X3vkQ a_X3vkS. (ContractConstraints s_X3vkM, HasBlockchainActions s_X3vkM, Show e_X3vkO, FromJSON e_X3vkO, ToJSON e_X3vkO, ToJSON w_X3vkQ, Monoid w_X3vkQ, FromJSON w_X3vkQ) => forall effs_a3vt3. Member RunContract effs_a3vt3 => Wallet -> Contract w_X3vkQ s_X3vkM e_X3vkO a_X3vkS -> ContractInstanceTag -> Eff effs_a3vt3 (ContractHandle w_X3vkQ s_X3vkM e_X3vkO)

-- | Like <a>activateContract</a>, but using <a>walletInstanceTag</a> for
--   the tag.
activateContractWallet :: forall w s e effs. (HasBlockchainActions s, ContractConstraints s, Show e, ToJSON e, FromJSON e, ToJSON w, FromJSON w, Member RunContract effs, Monoid w) => Wallet -> Contract w s e () -> Eff effs (ContractHandle w s e)

-- | Call an endpoint on a contract instance.
callEndpoint :: forall l ep w s e effs. (ContractConstraints s, HasEndpoint l ep s, Member RunContract effs) => ContractHandle w s e -> ep -> Eff effs ()
getContractState :: forall w_X3vkV (s_X3vkX :: Row Type) e_X3vkZ. (ContractConstraints s_X3vkX, FromJSON e_X3vkZ, FromJSON w_X3vkV, ToJSON w_X3vkV) => forall effs_a3vt5. Member RunContract effs_a3vt5 => ContractHandle w_X3vkV s_X3vkX e_X3vkZ -> Eff effs_a3vt5 (ContractInstanceState w_X3vkV s_X3vkX e_X3vkZ ())

-- | Get the active endpoints of a contract instance.
activeEndpoints :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs [ActiveEndpoint]

-- | Get the observable state <tt>w</tt> of a contract instance.
observableState :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs w

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   Useful if there is only a single contract instance for this wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | Handle the <a>RunContract</a> effect by running each contract instance
--   in an emulator thread.
handleRunContract :: forall effs effs2. (Member (State EmulatorThreads) effs2, Member (Error EmulatorRuntimeError) effs2, Member (Error EmulatorRuntimeError) effs, Member MultiAgentEffect effs2, Member (LogMsg EmulatorEvent') effs2, Member (LogMsg EmulatorEvent') effs, Member ContractInstanceIdEff effs, Member (State EmulatorThreads) effs, Member (Reader ThreadId) effs, Member (Yield (EmSystemCall effs2 EmulatorMessage) (Maybe EmulatorMessage)) effs) => RunContract ~> Eff effs

-- | Start a new thread for a contract instance (given by the handle). The
--   thread runs in the context of the wallet.
startContractThread :: forall w s e effs effs2. (Member (Yield (EmSystemCall effs2 EmulatorMessage) (Maybe EmulatorMessage)) effs, Member (State EmulatorThreads) effs2, Member MultiAgentEffect effs2, Member (Error EmulatorRuntimeError) effs2, Member (LogMsg EmulatorEvent') effs2, HasBlockchainActions s, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => Wallet -> ContractHandle w s e -> Eff effs (Maybe EmulatorMessage)


-- | A version of <a>RunContract</a> for use in the playground.
module Plutus.Trace.Effects.RunContractPlayground
data RunContractPlayground r
callEndpoint :: forall effs_a3yg4. Member RunContractPlayground effs_a3yg4 => Wallet -> String -> Value -> Eff effs_a3yg4 ()
launchContract :: forall effs_a3yg3. Member RunContractPlayground effs_a3yg3 => Wallet -> Eff effs_a3yg3 ()

-- | Handle the <a>RunContractPlayground</a> effect.
handleRunContractPlayground :: forall w s e effs effs2. (HasBlockchainActions s, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w, Member ContractInstanceIdEff effs, Member (Yield (EmSystemCall effs2 EmulatorMessage) (Maybe EmulatorMessage)) effs, Member (LogMsg EmulatorEvent') effs2, Member (Error EmulatorRuntimeError) effs2, Member (State EmulatorThreads) effs2, Member MultiAgentEffect effs2, Member (State (Map Wallet ContractInstanceId)) effs2, Member (State (Map Wallet ContractInstanceId)) effs) => Contract w s e () -> RunContractPlayground ~> Eff effs

module Plutus.Trace.Playground
type PlaygroundTrace a = Eff '[RunContractPlayground, Error EmulatorRuntimeError, Waiting, EmulatedWalletAPI] a
waitUntilSlot :: forall effs_a3eOA. Member Waiting effs_a3eOA => Slot -> Eff effs_a3eOA Slot

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId
callEndpoint :: forall effs_a3yg4. Member RunContractPlayground effs_a3yg4 => Wallet -> String -> Value -> Eff effs_a3yg4 ()
data EmulatorConfig
EmulatorConfig :: InitialChainState -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState
initialChainState :: Iso' EmulatorConfig InitialChainState

-- | Run a 'Trace Playground', streaming the log messages as they arrive
runPlaygroundStream :: forall w s e effs a. (HasBlockchainActions s, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => EmulatorConfig -> Contract w s e () -> PlaygroundTrace a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Maybe EmulatorErr, EmulatorState)
interpretPlaygroundTrace :: forall w s e effs a. (Member MultiAgentEffect effs, Member MultiAgentControlEffect effs, Member (Error EmulatorRuntimeError) effs, Member ChainControlEffect effs, Member (LogMsg EmulatorEvent') effs, HasBlockchainActions s, ContractConstraints s, Show e, ToJSON e, ToJSON w, Monoid w) => Contract w s e () -> [Wallet] -> PlaygroundTrace a -> Eff effs ()

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

module Plutus.Trace.Effects.EmulatorControl
data EmulatorControl r
[SetSigningProcess] :: Wallet -> SigningProcess -> EmulatorControl ()
[AgentState] :: Wallet -> EmulatorControl WalletState
[FreezeContractInstance] :: ContractInstanceId -> EmulatorControl ()
[ThawContractInstance] :: ContractInstanceId -> EmulatorControl ()
[ChainState] :: EmulatorControl ChainState
setSigningProcess :: forall effs_a3zTo. Member EmulatorControl effs_a3zTo => Wallet -> SigningProcess -> Eff effs_a3zTo ()
agentState :: forall effs_a3zTp. Member EmulatorControl effs_a3zTp => Wallet -> Eff effs_a3zTp WalletState
freezeContractInstance :: forall effs_a3zTq. Member EmulatorControl effs_a3zTq => ContractInstanceId -> Eff effs_a3zTq ()
thawContractInstance :: forall effs_a3zTr. Member EmulatorControl effs_a3zTr => ContractInstanceId -> Eff effs_a3zTr ()
chainState :: forall effs_a3zTs. Member EmulatorControl effs_a3zTs => Eff effs_a3zTs ChainState

-- | Interpret the <a>EmulatorControl</a> effect in the
--   <tt>MultiAgentEffect</tt> and scheduler system calls.
handleEmulatorControl :: forall effs effs2. (Member (State EmulatorThreads) effs, Member (State EmulatorState) effs, Member (Error EmulatorRuntimeError) effs, Member MultiAgentControlEffect effs, Member (Yield (EmSystemCall effs2 EmulatorMessage) (Maybe EmulatorMessage)) effs) => EmulatorControl ~> Eff effs

module Plutus.Trace.Emulator
data Emulator
type EmulatorTrace a = Eff '[RunContract, Waiting, EmulatorControl, EmulatedWalletAPI, LogMsg String, Error EmulatorRuntimeError] a
data EmulatorErr
WalletErr :: WalletAPIError -> EmulatorErr
AssertionErr :: AssertionError -> EmulatorErr
InstanceErr :: EmulatorRuntimeError -> EmulatorErr

-- | A reference to a running contract in the emulator.
data ContractHandle w s e
ContractHandle :: Contract w s e () -> ContractInstanceId -> ContractInstanceTag -> ContractHandle w s e
[chContract] :: ContractHandle w s e -> Contract w s e ()
[chInstanceId] :: ContractHandle w s e -> ContractInstanceId
[chInstanceTag] :: ContractHandle w s e -> ContractInstanceTag

-- | A user-defined tag for a contract instance. Used to find the
--   instance's log messages in the emulator log.
data ContractInstanceTag
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)
activateContract :: forall (s_X3vkM :: Row Type) e_X3vkO w_X3vkQ a_X3vkS. (ContractConstraints s_X3vkM, HasBlockchainActions s_X3vkM, Show e_X3vkO, FromJSON e_X3vkO, ToJSON e_X3vkO, ToJSON w_X3vkQ, Monoid w_X3vkQ, FromJSON w_X3vkQ) => forall effs_a3vt3. Member RunContract effs_a3vt3 => Wallet -> Contract w_X3vkQ s_X3vkM e_X3vkO a_X3vkS -> ContractInstanceTag -> Eff effs_a3vt3 (ContractHandle w_X3vkQ s_X3vkM e_X3vkO)

-- | Like <a>activateContract</a>, but using <a>walletInstanceTag</a> for
--   the tag.
activateContractWallet :: forall w s e effs. (HasBlockchainActions s, ContractConstraints s, Show e, ToJSON e, FromJSON e, ToJSON w, FromJSON w, Member RunContract effs, Monoid w) => Wallet -> Contract w s e () -> Eff effs (ContractHandle w s e)

-- | The <a>ContractInstanceTag</a> for the contract instance of a wallet.
--   Useful if there is only a single contract instance for this wallet.
--   See note [Wallet contract instances]
walletInstanceTag :: Wallet -> ContractInstanceTag

-- | Call an endpoint on a contract instance.
callEndpoint :: forall l ep w s e effs. (ContractConstraints s, HasEndpoint l ep s, Member RunContract effs) => ContractHandle w s e -> ep -> Eff effs ()
getContractState :: forall w_X3vkV (s_X3vkX :: Row Type) e_X3vkZ. (ContractConstraints s_X3vkX, FromJSON e_X3vkZ, FromJSON w_X3vkV, ToJSON w_X3vkV) => forall effs_a3vt5. Member RunContract effs_a3vt5 => ContractHandle w_X3vkV s_X3vkX e_X3vkZ -> Eff effs_a3vt5 (ContractInstanceState w_X3vkV s_X3vkX e_X3vkZ ())

-- | Get the observable state <tt>w</tt> of a contract instance.
observableState :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs w

-- | Get the active endpoints of a contract instance.
activeEndpoints :: forall w s e effs. (Member RunContract effs, ContractConstraints s, FromJSON e, FromJSON w, ToJSON w) => ContractHandle w s e -> Eff effs [ActiveEndpoint]
liftWallet :: forall a_a3dMS. forall effs_a3dNr. Member EmulatedWalletAPI effs_a3dNr => Wallet -> Eff ('(:) WalletEffect ('[] :: [Type -> Type])) a_a3dMS -> Eff effs_a3dNr a_a3dMS

-- | Make a payment from one wallet to another
payToWallet :: forall effs. Member EmulatedWalletAPI effs => Wallet -> Wallet -> Value -> Eff effs TxId

-- | Wait until the beginning of the next slot, returning the new slot
--   number.
nextSlot :: Member Waiting effs => Eff effs Slot
waitUntilSlot :: forall effs_a3eOA. Member Waiting effs_a3eOA => Slot -> Eff effs_a3eOA Slot

-- | Wait for a number of slots
waitNSlots :: forall effs. Member Waiting effs => Natural -> Eff effs Slot
freezeContractInstance :: forall effs_a3zTq. Member EmulatorControl effs_a3zTq => ContractInstanceId -> Eff effs_a3zTq ()
thawContractInstance :: forall effs_a3zTr. Member EmulatorControl effs_a3zTr => ContractInstanceId -> Eff effs_a3zTr ()
setSigningProcess :: forall effs_a3zTo. Member EmulatorControl effs_a3zTo => Wallet -> SigningProcess -> Eff effs_a3zTo ()
chainState :: forall effs_a3zTs. Member EmulatorControl effs_a3zTs => Eff effs_a3zTs ChainState
chainNewestFirst :: Lens' ChainState Blockchain
txPool :: Lens' ChainState TxPool
index :: Lens' ChainState UtxoIndex
currentSlot :: Lens' ChainState Slot
agentState :: forall effs_a3zTp. Member EmulatorControl effs_a3zTp => Wallet -> Eff effs_a3zTp WalletState
ownPrivateKey :: Lens' WalletState PrivateKey
nodeClient :: Lens' WalletState NodeClientState
chainIndex :: Lens' WalletState ChainIndexState
signingProcess :: Lens' WalletState SigningProcess
throwError :: forall e (effs :: [Type -> Type]) a. Member (Error e) effs => e -> Eff effs a
data EmulatorRuntimeError
ThreadIdNotFound :: ContractInstanceId -> EmulatorRuntimeError
InstanceIdNotFound :: Wallet -> EmulatorRuntimeError
JSONDecodingError :: String -> EmulatorRuntimeError
GenericError :: String -> EmulatorRuntimeError
data EmulatorConfig
EmulatorConfig :: InitialChainState -> EmulatorConfig

-- | State of the blockchain at the beginning of the simulation. Can be
--   given as a map of funds to wallets, or as a block of transactions.
[_initialChainState] :: EmulatorConfig -> InitialChainState
initialChainState :: Iso' EmulatorConfig InitialChainState

-- | Run a 'Trace Emulator', streaming the log messages as they arrive
runEmulatorStream :: forall effs a. EmulatorConfig -> EmulatorTrace a -> Stream (Of (LogMessage EmulatorEvent)) (Eff effs) (Maybe EmulatorErr, EmulatorState)

-- | Options for how to set up and print the trace.
data TraceConfig
TraceConfig :: (EmulatorEvent' -> Maybe String) -> Handle -> TraceConfig

-- | Function to decide how to print the particular events.
[showEvent] :: TraceConfig -> EmulatorEvent' -> Maybe String

-- | Where to print the outputs to. Default: <a>stdout</a>
[outputHandle] :: TraceConfig -> Handle

-- | Run an emulator trace to completion, returning a tuple of the final
--   state of the emulator, the events, and any error, if any.
runEmulatorTrace :: EmulatorConfig -> EmulatorTrace () -> ([EmulatorEvent], Maybe EmulatorErr, EmulatorState)

-- | A very simple effect for interpreting the output printing done by the
--   trace printing functions:
--   
--   <ul>
--   <li><a>runEmulatorTraceEff</a></li>
--   <li><a>runEmulatorTraceIO</a></li>
--   <li><a>runEmulatorTraceIO'</a></li>
--   </ul>
data PrintEffect r
[PrintLn] :: String -> PrintEffect ()

-- | Run the emulator trace returning an effect that can be evaluated by
--   interpreting the <a>PrintEffect</a>s.
runEmulatorTraceEff :: forall effs. Member PrintEffect effs => TraceConfig -> EmulatorConfig -> EmulatorTrace () -> Eff effs ()

-- | Runs the trace with <a>runEmulatorTrace</a>, with default
--   configuration that prints a selection of events to stdout.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; runEmulatorTraceIO (void $ Trace.waitNSlots 1)
--   </pre>
runEmulatorTraceIO :: EmulatorTrace () -> IO ()
runEmulatorTraceIO' :: TraceConfig -> EmulatorConfig -> EmulatorTrace () -> IO ()

-- | Interpret a 'Trace Emulator' action in the multi agent and emulated
--   blockchain effects.
interpretEmulatorTrace :: forall effs a. (Member MultiAgentEffect effs, Member MultiAgentControlEffect effs, Member (Error EmulatorRuntimeError) effs, Member ChainControlEffect effs, Member (LogMsg EmulatorEvent') effs, Member (State EmulatorState) effs) => EmulatorConfig -> EmulatorTrace a -> Eff effs ()
instance Data.Default.Class.Default Plutus.Trace.Emulator.TraceConfig

module Plutus.Trace
data SchedulerLog
data ThreadEvent


-- | Testing contracts with HUnit and Tasty
module Plutus.Contract.Test
type TracePredicate = FoldM (Eff '[Reader InitialDistribution, Error EmulatorFoldErr, Writer (Doc Void)]) EmulatorEvent Bool
type ContractConstraints s = (Forall (Output s) Unconstrained1, Forall (Input s) Unconstrained1, AllUniqueLabels (Input s), Forall (Input s) FromJSON, Forall (Input s) ToJSON, Forall (Output s) FromJSON, Forall (Output s) ToJSON)
not :: TracePredicate -> TracePredicate
(.&&.) :: TracePredicate -> TracePredicate -> TracePredicate
infixl 3 .&&.
endpointAvailable :: forall (l :: Symbol) w s e a. (HasType l ActiveEndpoint (Output s), KnownSymbol l, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> TracePredicate
interestingAddress :: forall w s e a. (HasWatchAddress s, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> Address -> TracePredicate
queryingUtxoAt :: forall w s e a. (HasUtxoAt s, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> Address -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   finished without errors.
assertDone :: forall w s e a. (ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> (a -> Bool) -> String -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   is waiting for input.
assertNotDone :: forall w s e a. (ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> String -> TracePredicate

-- | A <a>TracePredicate</a> checking that the wallet's contract instance
--   failed with an error.
assertContractError :: forall w s e a. (ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> (e -> Bool) -> String -> TracePredicate
data Outcome e a

-- | The contract finished without errors and produced a result
Done :: a -> Outcome e a

-- | The contract is waiting for more input.
NotDone :: Outcome e a

-- | The contract failed with an error.
Failed :: e -> Outcome e a
assertOutcome :: forall w s e a. (ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> (Outcome e a -> Bool) -> String -> TracePredicate
assertInstanceLog :: ContractInstanceTag -> ([EmulatorTimeEvent ContractInstanceLog] -> Bool) -> TracePredicate

-- | Assert that no transaction failed to validate.
assertNoFailedTransactions :: TracePredicate

-- | Assert that at least one transaction failed to validate, and that all
--   transactions that failed meet the predicate.
assertFailedTransaction :: (Tx -> ValidationError -> [ScriptValidationEvent] -> Bool) -> TracePredicate
assertHooks :: forall w s e a. (Forall (Output s) Pretty, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> ([Handlers s] -> Bool) -> String -> TracePredicate

-- | Make an assertion about the responses provided to the contract
--   instance.
assertResponses :: forall w s e a. (Forall (Input s) Pretty, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> ([Response (Event s)] -> Bool) -> String -> TracePredicate
assertUserLog :: ([EmulatorTimeEvent UserThreadMsg] -> Bool) -> TracePredicate

-- | An assertion about the blockchain
assertBlockchain :: ([Block] -> Bool) -> TracePredicate

-- | An assertion about the chain events
assertChainEvents :: ([ChainEvent] -> Bool) -> TracePredicate

-- | Make an assertion about the accumulated state <tt>w</tt> of a contract
--   instance.
assertAccumState :: forall w s e a. (ContractConstraints s, Monoid w, Show w) => Contract w s e a -> ContractInstanceTag -> (w -> Bool) -> String -> TracePredicate
data Shrinking
DoShrink :: Shrinking
DontShrink :: Shrinking

-- | make an assertion about the <a>ContractInstanceState</a> of a contract
--   instance
assertResumableResult :: forall w s e a. (ContractConstraints s, Monoid w, Forall (Input s) Show, Forall (Output s) Show, Show e, Show a, Show w) => Contract w s e a -> ContractInstanceTag -> Shrinking -> (ResumableResult w e (Event s) (Handlers s) a -> Bool) -> String -> TracePredicate
tx :: forall w s e a. (HasWriteTx s, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> (UnbalancedTx -> Bool) -> String -> TracePredicate
anyTx :: forall w s e a. (HasWriteTx s, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> TracePredicate
assertEvents :: forall w s e a. (Forall (Input s) Pretty, ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> ([Event s] -> Bool) -> String -> TracePredicate

-- | Check that the funds in the wallet have changed by the given amount,
--   exluding fees.
walletFundsChange :: Wallet -> Value -> TracePredicate

-- | Check that the funds in the wallet have changed by the given amount,
--   including fees.
walletFundsExactChange :: Wallet -> Value -> TracePredicate
walletPaidFees :: Wallet -> Value -> TracePredicate
waitingForSlot :: forall w s e a. (HasType SlotSymbol WaitingForSlot (Output s), ContractConstraints s, Monoid w) => Contract w s e a -> ContractInstanceTag -> Slot -> TracePredicate
walletWatchingAddress :: Wallet -> Address -> TracePredicate

-- | Check that the funds at an address meet some condition.
valueAtAddress :: Address -> (Value -> Bool) -> TracePredicate
dataAtAddress :: IsData a => Address -> (a -> Bool) -> TracePredicate

-- | Assert that the size of a <a>Validator</a> is below the maximum.
reasonable :: Validator -> Integer -> Assertion
reasonable' :: (String -> IO ()) -> Validator -> Integer -> Assertion

-- | Check if the emulator trace meets the condition
checkPredicate :: String -> TracePredicate -> EmulatorTrace () -> TestTree

-- | A version of <a>checkPredicate</a> with configurable
--   <a>CheckOptions</a>
checkPredicateOptions :: CheckOptions -> String -> TracePredicate -> EmulatorTrace () -> TestTree

-- | Check if the emulator trace meets the condition, using the
--   <a>GeneratorModel</a> to generate initial transactions for the
--   blockchain
checkPredicateGen :: GeneratorModel -> TracePredicate -> EmulatorTrace () -> Property

-- | A version of <a>checkPredicateGen</a> with configurable
--   <a>CheckOptions</a>
checkPredicateGenOptions :: CheckOptions -> GeneratorModel -> TracePredicate -> EmulatorTrace () -> Property

-- | Evaluate a trace predicate on an emulator trace, printing out debug
--   information and making assertions as we go.
checkPredicateInner :: forall m. Monad m => CheckOptions -> TracePredicate -> EmulatorTrace () -> (String -> m ()) -> (Bool -> m ()) -> m ()

-- | Options for running the
data CheckOptions
defaultCheckOptions :: CheckOptions
minLogLevel :: Lens' CheckOptions LogLevel
maxSlot :: Lens' CheckOptions Slot
emulatorConfig :: Lens' CheckOptions EmulatorConfig

-- | Compare a golden PIR file to the provided <a>CompiledCode</a>.
goldenPir :: FilePath -> CompiledCode a -> TestTree
instance GHC.Show.Show Plutus.Contract.Test.Shrinking
instance GHC.Classes.Ord Plutus.Contract.Test.Shrinking
instance GHC.Classes.Eq Plutus.Contract.Test.Shrinking
instance GHC.Show.Show Plutus.Contract.Test.CheckOptions
instance GHC.Classes.Eq Plutus.Contract.Test.CheckOptions


-- | This module provides a framework for testing Plutus contracts built on
--   <a>Test.QuickCheck</a>. The testing is model based, so to test a
--   contract you define a type modelling the state of the contract (or set
--   of contracts) and provide an instance of the <a>ContractModel</a>
--   class. This instance specifies what operations (<a>Action</a>s) the
--   contract supports, how they interact with the model state, and how to
--   execute them in the blockchain emulator
--   (<a>Plutus.Trace.Emulator</a>). Tests are evaluated by running
--   sequences of actions (random or user-specified) in the emulator and
--   comparing the state of the blockchain to the model state at the end.
--   
--   Test cases are written in the <a>DL</a> monad, which supports mixing
--   fixed sequences of actions with random actions, making it easy to
--   write properties like <i>it is always possible to get all funds out of
--   the contract</i>.
module Plutus.Contract.Test.ContractModel

-- | A <a>ContractModel</a> instance captures everything that is needed to
--   generate and run tests of a contract or set of contracts. It specifies
--   among other things
--   
--   <ul>
--   <li>what operations are supported by the contract
--   (<a>Action</a>),</li>
--   <li>when they are valid (<a>precondition</a>),</li>
--   <li>how to generate random actions (<a>arbitraryAction</a>),</li>
--   <li>how the operations affect the state (<a>nextState</a>), and</li>
--   <li>how to run the operations in the emulator (<a>perform</a>)</li>
--   </ul>
class (Typeable state, Show state, Show (Action state), Eq (Action state), (forall w s e. Eq (ContractInstanceKey state w s e)), (forall w s e. Show (ContractInstanceKey state w s e))) => ContractModel state where {
    
    -- | The type of actions that are supported by the contract. An action
    --   usually represents a single <a>callEndpoint</a> or a transfer of
    --   tokens, but it can be anything that can be interpreted in the
    --   <a>EmulatorTrace</a> monad.
    data family Action state;
    
    -- | To be able to call a contract endpoint from a wallet a
    --   <a>ContractHandle</a> is required. These are managed by the test
    --   framework and all the user needs to do is provide this contract
    --   instance key type representing the different contract instances that a
    --   test needs to work with, and when creating a property (see
    --   <a>propRunActions_</a>) provide a list of contract instance keys
    --   together with their wallets and contracts (a
    --   <a>ContractInstanceSpec</a>). Contract instance keys are indexed by
    --   the observable state, schema, and error type of the contract and
    --   should be defined as a GADT. For example, a handle type for a contract
    --   with one seller and multiple buyers could look like this.
    --   
    --   <pre>
    --   data ContractInstanceKey MyModel w s e where
    --       Buyer  :: Wallet -&gt; ContractInstanceKey MyModel MyObsState MySchema MyError
    --       Seller :: ContractInstanceKey MyModel MyObsState MySchema MyError
    --   </pre>
    data family ContractInstanceKey state :: * -> Row * -> * -> *;
}

-- | The <a>ContractInstanceTag</a> of an instance key for a wallet.
--   Defaults to <a>walletInstanceTag</a>. You must override this if you
--   have multiple instances per wallet.
instanceTag :: forall a b c. ContractModel state => ContractInstanceKey state a b c -> Wallet -> ContractInstanceTag

-- | Given the current model state, provide a QuickCheck generator for a
--   random next action. This is used in the <a>Arbitrary</a> instance for
--   <a>Actions</a>s as well as by <a>anyAction</a> and <a>anyActions</a>.
arbitraryAction :: ContractModel state => ModelState state -> Gen (Action state)

-- | The initial state, before any actions have been performed.
initialState :: ContractModel state => state

-- | The <a>precondition</a> function decides if a given action is valid in
--   a given state. Typically actions generated by <a>arbitraryAction</a>
--   will satisfy the precondition, but if they don't they will be
--   discarded and another action will be generated. More importantly, the
--   preconditions are used when shrinking (see <a>shrinkAction</a>) to
--   ensure that shrunk test cases still make sense.
--   
--   If an explicit <a>action</a> in a <a>DL</a> scenario violates the
--   precondition an error is raised.
precondition :: ContractModel state => ModelState state -> Action state -> Bool

-- | This is where the model logic is defined. Given an action,
--   <a>nextState</a> specifies the effects running that action has on the
--   model state. It runs in the <a>Spec</a> monad, which is a state monad
--   over the <a>ModelState</a>.
nextState :: ContractModel state => Action state -> Spec state ()

-- | While <a>nextState</a> models the behaviour of the actions,
--   <a>perform</a> contains the code for running the actions in the
--   emulator (see <a>Plutus.Trace.Emulator</a>). It gets access to the
--   wallet contract handles, the current model state, and the action to be
--   performed.
perform :: ContractModel state => HandleFun state -> ModelState state -> Action state -> EmulatorTrace ()

-- | When a test involving random sequences of actions fails, the framework
--   tries to find a minimal failing test case by shrinking the original
--   failure. Action sequences are shrunk by removing individual actions,
--   or by replacing an action by one of the (simpler) actions returned by
--   <a>shrinkAction</a>.
--   
--   See <a>shrink</a> for more information on shrinking.
shrinkAction :: ContractModel state => ModelState state -> Action state -> [Action state]

-- | The <a>monitoring</a> function allows you to collect statistics of
--   your testing using QuickCheck functions like <a>label</a>,
--   <a>collect</a>, <a>classify</a>, and <a>tabulate</a>. This function is
--   called by <a>propRunActions</a> (and friends) for any actions in the
--   given <a>Actions</a>.
--   
--   Statistics on which actions are executed are always collected.
monitoring :: ContractModel state => (ModelState state, ModelState state) -> Action state -> Property -> Property

-- | In some scenarios it's useful to have actions that are never generated
--   randomly, but only used explicitly in <a>DL</a> scenario
--   <a>action</a>s. To avoid these actions matching an <a>anyAction</a>
--   when shrinking, they can be marked <a>restricted</a>.
restricted :: ContractModel state => Action state -> Bool

-- | The <a>ModelState</a> models the state of the blockchain. It contains,
--   
--   <ul>
--   <li>the contract-specific state (<a>contractState</a>)</li>
--   <li>the current slot (<a>currentSlot</a>)</li>
--   <li>the wallet balances (<tt>balances</tt>)</li>
--   <li>the amount that has been forged (<a>forged</a>)</li>
--   </ul>
data ModelState state

-- | Lens for the contract-specific part of the model state.
--   
--   <a>Spec</a> monad update functions: <a>$=</a> and <a>$~</a>.
contractState :: forall state_a3NU5 state_a3Orr. Lens (ModelState state_a3NU5) (ModelState state_a3Orr) state_a3NU5 state_a3Orr

-- | Get the current slot.
--   
--   <a>Spec</a> monad update functions: <a>wait</a> and <a>waitUntil</a>.
currentSlot :: Getter (ModelState state) Slot

-- | Get the current wallet balance changes. These are delta balances, so
--   they start out at zero and can be negative. The absolute balances used
--   by the emulator can be set in the <a>CheckOptions</a> argument to
--   <a>propRunActionsWithOptions</a>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChanges :: Getter (ModelState state) (Map Wallet Value)

-- | Get the current balance change for a wallet. This is the delta
--   balance, so it starts out at zero and can be negative. The absolute
--   balance used by the emulator can be set in the <a>CheckOptions</a>
--   argument to <a>propRunActionsWithOptions</a>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChange :: Wallet -> Getter (ModelState state) Value

-- | Get the amount of tokens forged so far. This is used to compute
--   <a>lockedValue</a>.
--   
--   <a>Spec</a> monad update functions: <a>forge</a> and <a>burn</a>.
forged :: Getter (ModelState state) Value

-- | How much value is currently locked by contracts. This computed by
--   subtracting the wallet <tt>balances</tt> from the <a>forged</a> value.
lockedValue :: ModelState s -> Value

-- | Monads with read access to the model state: the <a>Spec</a> monad used
--   in <a>nextState</a>, and the <a>DL</a> monad used to construct test
--   scenarios.
class Monad m => GetModelState m where {
    
    -- | The contract state type of the monad. For both <a>Spec</a> and
    --   <a>DL</a> this is simply the <tt>state</tt> parameter of the
    --   respective monad.
    type family StateType m :: *;
}

-- | Get the current model state.
getModelState :: GetModelState m => m (ModelState (StateType m))

-- | Get the contract state part of the model state.
getContractState :: GetModelState m => m (StateType m)

-- | Get a component of the model state.
askModelState :: GetModelState m => (ModelState (StateType m) -> a) -> m a

-- | Get a component of the contract state.
askContractState :: GetModelState m => (StateType m -> a) -> m a

-- | Get a component of the model state using a lens.
viewModelState :: GetModelState m => Getting a (ModelState (StateType m)) a -> m a

-- | Get a component of the contract state using a lens.
viewContractState :: GetModelState m => Getting a (StateType m) a -> m a

-- | The <a>Spec</a> monad is a state monad over the <a>ModelState</a>. It
--   is used exclusively by the <a>nextState</a> function to model the
--   effects of an action on the blockchain.
data Spec state a

-- | Wait the given number of slots. Updates the <a>currentSlot</a> of the
--   model state.
wait :: Integer -> Spec state ()

-- | Wait until the given slot. Has no effect if <a>currentSlot</a> is
--   greater than the given slot.
waitUntil :: Slot -> Spec state ()

-- | Forge tokens. Forged tokens start out as <a>lockedValue</a> (i.e.
--   owned by the contract) and can be transferred to wallets using
--   <a>deposit</a>.
forge :: Value -> Spec state ()

-- | Burn tokens. Equivalent to <tt><a>forge</a> . <a>inv</a></tt>.
burn :: Value -> Spec state ()

-- | Add tokens to the <a>balanceChange</a> of a wallet. The added tokens
--   are subtracted from the <a>lockedValue</a> of tokens held by
--   contracts.
deposit :: Wallet -> Value -> Spec state ()

-- | Withdraw tokens from a wallet. The withdrawn tokens are added to the
--   <a>lockedValue</a> of tokens held by contracts.
withdraw :: Wallet -> Value -> Spec state ()

-- | Transfer tokens between wallets, updating their <tt>balances</tt>.
transfer :: Wallet -> Wallet -> Value -> Spec state ()

-- | Modify the contract state.
modifyContractState :: (state -> state) -> Spec state ()

-- | Set a specific field of the contract state.
($=) :: Setter' state a -> a -> Spec state ()

-- | Modify a specific field of the contract state.
($~) :: Setter' state a -> (a -> a) -> Spec state ()

-- | The monad for writing test scenarios. It supports non-deterministic
--   choice through <a>Alternative</a>, failure with <a>MonadFail</a>, and
--   access to the model state through <a>GetModelState</a>. It is lazy, so
--   scenarios can be potentially infinite, although the probability of
--   termination needs to be high enough that concrete test cases are
--   always finite. See <a>stopping</a> for more information on
--   termination.
type DL state = DL (ModelState state)

-- | Generate a specific action. Fails if the action's <a>precondition</a>
--   is not satisfied.
action :: ContractModel state => Action state -> DL state ()

-- | Generate a random action using <a>arbitraryAction</a>. The generated
--   action is guaranteed to satisfy its <a>precondition</a>. Fails with
--   <a>Stuck</a> if no action satisfying the precondition can be found
--   after 100 attempts.
anyAction :: DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. The argument is the
--   expected number of actions in the sequence chosen from a geometric
--   distribution, unless in the <a>stopping</a> stage, in which case as
--   few actions as possible are generated.
anyActions :: Int -> DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. Actions are generated
--   until the <a>stopping</a> stage is reached.
anyActions_ :: DL state ()
assert :: String -> Bool -> DL s ()

-- | Fail unless the given predicate holds of the model state.
--   
--   Equivalent to
--   
--   <pre>
--   assertModel msg p = do
--     s &lt;- <a>getModelState</a>
--     <a>assert</a> msg (p s)
--   </pre>
assertModel :: String -> (ModelState state -> Bool) -> DL state ()

-- | Test case generation from <a>DL</a> scenarios have a target length of
--   the action sequence to be generated that is based on the QuickCheck
--   size parameter (see <a>sized</a>). However, given that scenarios can
--   contain explicit <a>action</a>s it might not be possible to stop the
--   scenario once the target length has been reached.
--   
--   Instead, once the target number of actions have been reached,
--   generation goes into the <i>stopping</i> phase. In this phase branches
--   starting with <a>stopping</a> are preferred, if possible. Conversely,
--   before the stopping phase, branches starting with <a>stopping</a> are
--   avoided unless there are no other possible choices.
--   
--   For example, here is the definition of <a>anyActions_</a>:
--   
--   <pre>
--   <a>anyActions_</a> = <a>stopping</a> <a>&lt;|&gt;</a> (<a>anyAction</a> &gt;&gt; <a>anyActions_</a>)
--   </pre>
--   
--   The effect of this definition is that the second branch will be taken
--   until the desired number of actions have been generated, at which
--   point the <a>stopping</a> branch will be taken and generation stops
--   (or continues with whatever comes after the <a>anyActions_</a> call).
--   
--   Now, it might not be possible, or too hard, to find a way to terminate
--   a scenario. For instance, this scenario has no finite test cases:
--   
--   <pre>
--   looping = <a>anyAction</a> &gt;&gt; looping
--   </pre>
--   
--   To prevent test case generation from looping, if a scenario has not
--   terminated after generating <tt>2 * n + 20</tt> actions, where
--   <tt>n</tt> is when the stopping phase kicks in, generation fails with
--   a <a>Looping</a> error.
stopping :: DL state ()

-- | By default, <a>Alternative</a> choice (<a>&lt;|&gt;</a>) picks among
--   the next actions with equal probability. So, for instance, this code
--   chooses between the actions <tt>a</tt>, <tt>b</tt> and <tt>c</tt>,
--   with a probability <tt>1/3</tt> of choosing each:
--   
--   <pre>
--   unbiasedChoice a b c = <a>action</a> a <a>&lt;|&gt;</a> <a>action</a> b <a>&lt;|&gt;</a> <a>action</a> c
--   </pre>
--   
--   To change this you can use <a>weight</a>, which multiplies the
--   relative probability of picking a branch by the given number.
--   
--   For instance, the following scenario picks the action <tt>a</tt> with
--   probability <tt>2/3</tt> and the action <tt>b</tt> with probability
--   <tt>1/3</tt>:
--   
--   <pre>
--   biasedChoice a b = <a>weight</a> 2 (<a>action</a> a) <a>&lt;|&gt;</a> <a>weight</a> (<a>action</a> b)
--   </pre>
--   
--   Calls to <a>weight</a> need to appear at the top-level after a choice,
--   preceding any actions (<a>action</a>/<a>anyAction</a>) or random
--   generation (<tt>forAllQ</tt>), or they will have no effect.
weight :: Double -> DL state ()

-- | The <a>monitor</a> function allows you to collect statistics of your
--   testing using QuickCheck functions like <a>label</a>, <a>collect</a>,
--   <a>classify</a>, and <a>tabulate</a>. See also the <a>monitoring</a>
--   method of <a>ContractModel</a> which is called for all actions in a
--   test case (regardless of whether they are generated by an explicit
--   <a>action</a> or an <a>anyAction</a>).
monitor :: (Property -> Property) -> DL state ()
forAllQ :: Quantifiable q => q -> DL s (Quantifies q)
arbitraryQ :: Arbitrary a => Quantification a
chooseQ :: (Arbitrary a, Random a, Ord a) => (a, a) -> Quantification a
elementsQ :: Eq a => [a] -> Quantification a
exactlyQ :: Eq a => a -> Quantification a
frequencyQ :: [(Int, Quantification a)] -> Quantification a
mapQ :: (a -> b, b -> a) -> Quantification a -> Quantification b
oneofQ :: [Quantification a] -> Quantification a
whereQ :: Quantification a -> (a -> Bool) -> Quantification a
class (Eq Quantifies q, Show Quantifies q, Typeable Quantifies q) => Quantifiable q where {
    type family Quantifies q;
}
quantify :: Quantifiable q => q -> Quantification (Quantifies q)
type family Quantifies q
data Quantification a

-- | A <a>Actions</a> is a list of <a>Action</a>s.
newtype Actions s
Actions :: [Action s] -> Actions s

-- | The constraints required on contract schemas and error types to enable
--   calling contract endpoints (<a>callEndpoint</a>).
type SchemaConstraints w schema err = (Typeable w, Monoid w, ToJSON w, Typeable schema, HasBlockchainActions schema, ContractConstraints schema, Show err, Typeable err, ToJSON err, FromJSON err, ToJSON w, FromJSON w)

-- | A <a>ContractInstanceSpec</a> associates a <a>ContractInstanceKey</a>
--   with a concrete <a>Wallet</a> and <a>Contract</a>. The contract type
--   parameters are hidden from the outside.
data ContractInstanceSpec state
[ContractInstanceSpec] :: SchemaConstraints w schema err => ContractInstanceKey state w schema err -> Wallet -> Contract w schema err () -> ContractInstanceSpec state

-- | A function returning the <a>ContractHandle</a> corresponding to a
--   <a>ContractInstanceKey</a>. A <a>HandleFun</a> is provided to the
--   <a>perform</a> function to enable calling contract endpoints with
--   <a>callEndpoint</a>.
type HandleFun state = forall w schema err. (Typeable w, Typeable schema, Typeable err) => ContractInstanceKey state w schema err -> ContractHandle w schema err

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes. Equivalent to
--   
--   <pre>
--   propRunActions_ hs actions = <a>propRunActions</a> hs (<a>const</a> <a>$</a> <a>pure</a> <a>True</a>) actions
--   </pre>
propRunActions_ :: ContractModel state => [ContractInstanceSpec state] -> Actions state -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, and that the given
--   <a>TracePredicate</a> holds at the end. Equivalent to:
--   
--   <pre>
--   propRunActions = <a>propRunActionsWithOptions</a> <a>defaultCheckOptions</a>
--   </pre>
propRunActions :: ContractModel state => [ContractInstanceSpec state] -> (ModelState state -> TracePredicate) -> Actions state -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, that no off-chain
--   contract instance crashed, and that the given <a>TracePredicate</a>
--   holds at the end. The predicate has access to the final model state.
--   
--   The <a>ContractInstanceSpec</a> argument lists the contract instances
--   that should be created for the wallets involved in the test. Before
--   the actions are run, contracts are activated using
--   <tt>activateContractWallet</tt> and a mapping from
--   <a>ContractInstanceKey</a>s to the resulting <a>ContractHandle</a>s is
--   provided to the <a>perform</a> function.
--   
--   The <a>Actions</a> argument can be generated by a <a>forAllDL</a> from
--   a <a>DL</a> scenario, or using the <a>Arbitrary</a> instance for
--   actions which generates random actions using <a>arbitraryAction</a>:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck $ propRunActions_ handles
--   +++ OK, passed 100 tests
--   
--   &gt;&gt;&gt; quickCheck $ forAllDL dl $ propRunActions_ handles
--   +++ OK, passed 100 tests
--   </pre>
--   
--   The options argument can be used to configure the emulator--setting
--   initial wallet balances, the maximum number of slots to run for, and
--   the log level for the emulator trace printed on failing tests:
--   
--   <pre>
--   options :: <a>Map</a> <a>Wallet</a> <a>Value</a> -&gt; <a>Slot</a> -&gt; <a>LogLevel</a> -&gt; <a>CheckOptions</a>
--   options dist slot logLevel =
--       <a>defaultCheckOptions</a> <a>&amp;</a> <a>emulatorConfig</a> . <a>initialChainState</a> <a>.~</a> <a>Left</a> dist
--                           <a>&amp;</a> <a>maxSlot</a>                            <a>.~</a> slot
--                           <a>&amp;</a> <a>minLogLevel</a>                        <a>.~</a> logLevel
--   </pre>
propRunActionsWithOptions :: ContractModel state => CheckOptions -> [ContractInstanceSpec state] -> (ModelState state -> TracePredicate) -> Actions state -> Property

-- | Turn a <a>DL</a> scenario into a QuickCheck property. Generates a
--   random <a>Actions</a> matching the scenario and feeds it to the given
--   property. The property can be a full property running the emulator and
--   checking the results, defined using <a>propRunActions_</a>,
--   <a>propRunActions</a>, or <a>propRunActionsWithOptions</a>. Assuming a
--   model for an auction contract and <a>DL</a> scenario that checks that
--   you can always complete the auction, you can write:
--   
--   <pre>
--   finishAuction :: <a>DL</a> AuctionState ()
--   prop_Auction  = <a>propRunActions_</a> handles
--     where handles = ...
--   prop_Finish = <a>forAllDL</a> finishAuction prop_Auction
--   </pre>
--   
--   However, there is also value in a property that does not run the
--   emulator at all:
--   
--   <pre>
--   prop_FinishModel = <a>forAllDL</a> finishAuction $ const True
--   </pre>
--   
--   This will check all the assertions and other failure conditions of the
--   <a>DL</a> scenario very quickly. Once this property passes a large
--   number of tests, you can run the full property checking that the model
--   agrees with reality.
forAllDL :: (ContractModel state, Testable p) => DL state () -> (Actions state -> p) -> Property

-- | An instance of a <a>DL</a> scenario generated by <a>forAllDL</a>. It
--   is turned into a <a>Actions</a> before being passed to the property
--   argument of <a>forAllDL</a>, but in case of a failure the generated
--   <a>DLTest</a> is printed. This test can then be rerun using
--   <a>withDLTest</a>.
data DLTest state

-- | An explicit <a>action</a> failed its precondition
--   (<tt><a>Action</a></tt>), or an assertion failed (<a>Assert</a>).
--   There is a list of <a>FailedStep</a>s because there may be multiple
--   branches (<a>&lt;|&gt;</a>) in the scenario that fail. Contains the
--   contract state at the point of failure.
BadPrecondition :: [TestStep state] -> [FailedStep state] -> state -> DLTest state

-- | Test case generation from the <a>DL</a> scenario failed to terminate.
--   See <a>stopping</a> for more information.
Looping :: [TestStep state] -> DLTest state

-- | There are no possible next steps in the scenario. Corresponds to a
--   call to <a>empty</a>. Contains the contract state at the point where
--   the scenario got stuck.
Stuck :: [TestStep state] -> state -> DLTest state

-- | A successfully generated test case.
DLScript :: [TestStep state] -> DLTest state

-- | One step of a test case. Either an <a>Action</a> (<a>Do</a>) or a
--   value generated by a <a>forAllQ</a> (<a>Witness</a>). When a
--   <a>DLTest</a> is turned into a <a>Actions</a> to be executed the
--   witnesses are stripped away.
data TestStep s
Do :: Action s -> TestStep s
Witness :: a -> TestStep s

-- | This type captures the two different kinds of <a>BadPrecondition</a>s
--   that can occur.
data FailedStep state

-- | A call to <a>action</a> that does not satisfy its <a>precondition</a>.
Action :: Action state -> FailedStep state

-- | A call to <a>assert</a> or <a>assertModel</a> failed, or a <a>fail</a>
--   in the <a>DL</a> monad. Stores the string argument of the
--   corresponding call.
Assert :: String -> FailedStep state

-- | Run a specific <a>DLTest</a>. Typically this test comes from a failed
--   run of <a>forAllDL</a> applied to the given <a>DL</a> scenario and
--   property. Useful to check if a particular problem has been fixed after
--   updating the code or the model.
withDLTest :: (ContractModel state, Testable prop) => DL state () -> (Actions state -> prop) -> DLTest state -> Property
instance Plutus.Contract.Test.ContractModel.ContractModel state => GHC.Classes.Eq (Test.QuickCheck.StateModel.Action (Plutus.Contract.Test.ContractModel.ModelState state) a)
instance Plutus.Contract.Test.ContractModel.ContractModel s => GHC.Show.Show (Plutus.Contract.Test.ContractModel.FailedStep s)
instance Plutus.Contract.Test.ContractModel.ContractModel s => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.FailedStep s)
instance Plutus.Contract.Test.ContractModel.GetModelState (Plutus.Contract.Test.ContractModel.DL state)
instance Plutus.Contract.Test.ContractModel.ContractModel s => GHC.Show.Show (Plutus.Contract.Test.ContractModel.DLTest s)
instance Plutus.Contract.Test.ContractModel.ContractModel s => GHC.Show.Show (Plutus.Contract.Test.ContractModel.TestStep s)
instance Plutus.Contract.Test.ContractModel.ContractModel state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Actions state)
instance Plutus.Contract.Test.ContractModel.ContractModel s => Test.QuickCheck.Arbitrary.Arbitrary (Plutus.Contract.Test.ContractModel.Actions s)
instance Plutus.Contract.Test.ContractModel.ContractModel state => Test.QuickCheck.StateModel.StateModel (Plutus.Contract.Test.ContractModel.ModelState state)
instance GHC.Base.Semigroup (Plutus.Contract.Test.ContractModel.EmulatorAction state)
instance GHC.Base.Monoid (Plutus.Contract.Test.ContractModel.EmulatorAction state)
instance Plutus.Contract.Test.ContractModel.GetModelState (Plutus.Contract.Test.ContractModel.Spec state)
instance Plutus.Contract.Test.ContractModel.ContractModel state => GHC.Show.Show (Test.QuickCheck.StateModel.Action (Plutus.Contract.Test.ContractModel.ModelState state) a)
instance Plutus.Contract.Test.ContractModel.ContractModel s => Test.QuickCheck.DynamicLogic.DynLogicModel (Plutus.Contract.Test.ContractModel.ModelState s)
instance GHC.Show.Show state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.ModelState state)
instance Control.Monad.State.Class.MonadState (Plutus.Contract.Test.ContractModel.ModelState state) (Plutus.Contract.Test.ContractModel.Spec state)
instance GHC.Base.Monad (Plutus.Contract.Test.ContractModel.Spec state)
instance GHC.Base.Applicative (Plutus.Contract.Test.ContractModel.Spec state)
instance GHC.Base.Functor (Plutus.Contract.Test.ContractModel.Spec state)

module Plutus.Contract.StateMachine

-- | Client-side definition of a state machine.
data StateMachineClient s i
StateMachineClient :: StateMachineInstance s i -> ([OnChainState s i] -> Either SMContractError (OnChainState s i)) -> StateMachineClient s i

-- | The instance of the state machine, defining the machine's transitions,
--   its final states and its check function.
[scInstance] :: StateMachineClient s i -> StateMachineInstance s i

-- | A function that chooses the relevant on-chain state, given a list of
--   all potential on-chain states found at the contract address.
[scChooser] :: StateMachineClient s i -> [OnChainState s i] -> Either SMContractError (OnChainState s i)
data TxConstraints i o
data SMContractError
ChooserError :: Text -> SMContractError
SMCContractError :: ContractError -> SMContractError
class AsSMContractError r_a3WN5
_SMContractError :: AsSMContractError r_a3WN5 => Prism' r_a3WN5 SMContractError
_ChooserError :: AsSMContractError r_a3WN5 => Prism' r_a3WN5 Text
_SMCContractError :: AsSMContractError r_a3WN5 => Prism' r_a3WN5 ContractError

-- | Specification of a state machine, consisting of a transition function
--   that determines the next state from the current state and an input,
--   and a checking function that checks the validity of the transition in
--   the context of the current transaction.
data StateMachine s i
StateMachine :: (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> (s -> i -> ScriptContext -> Bool) -> Maybe AssetClass -> StateMachine s i

-- | The transition function of the state machine. <a>Nothing</a> indicates
--   an invalid transition from the current state.
[smTransition] :: StateMachine s i -> State s -> i -> Maybe (TxConstraints Void Void, State s)

-- | Check whether a state is the final state
[smFinal] :: StateMachine s i -> s -> Bool

-- | The condition checking function. Can be used to perform checks on the
--   pending transaction that aren't covered by the constraints.
--   <a>smCheck</a> is always run in addition to checking the constraints,
--   so the default implementation always returns true.
[smCheck] :: StateMachine s i -> s -> i -> ScriptContext -> Bool

-- | The <a>AssetClass</a> of the thread token that identifies the contract
--   instance.
[smThreadToken] :: StateMachine s i -> Maybe AssetClass
data StateMachineInstance s i
StateMachineInstance :: StateMachine s i -> TypedValidator (StateMachine s i) -> StateMachineInstance s i

-- | The state machine specification.
[stateMachine] :: StateMachineInstance s i -> StateMachine s i

-- | The validator code for this state machine.
[typedValidator] :: StateMachineInstance s i -> TypedValidator (StateMachine s i)
data State s
State :: s -> Value -> State s
[stateData] :: State s -> s
[stateValue] :: State s -> Value
type OnChainState s i = (TypedScriptTxOut (StateMachine s i), TypedScriptTxOutRef (StateMachine s i))
data WaitingResult a
Timeout :: Slot -> WaitingResult a
ContractEnded :: WaitingResult a
WaitingResult :: a -> WaitingResult a

-- | An invalid transition
data InvalidTransition s i
InvalidTransition :: Maybe (State s) -> i -> InvalidTransition s i

-- | Current state. <a>Nothing</a> indicates that there is no current
--   state.
[tfState] :: InvalidTransition s i -> Maybe (State s)

-- | Transition that was attempted but failed
[tfInput] :: InvalidTransition s i -> i

-- | Result of an attempted transition
data TransitionResult s i

-- | The transition is not allowed
TransitionFailure :: InvalidTransition s i -> TransitionResult s i

-- | The transition is allowed and results in a new state
TransitionSuccess :: s -> TransitionResult s i

-- | Turn a state machine into a validator script.
mkValidator :: forall s i. IsData s => StateMachine s i -> ValidatorType (StateMachine s i)

-- | A state machine that does not perform any additional checks on the
--   <a>ScriptContext</a> (beyond enforcing the constraints)
mkStateMachine :: Maybe AssetClass -> (State s -> i -> Maybe (TxConstraints Void Void, State s)) -> (s -> Bool) -> StateMachine s i

-- | A state machine client with the <a>defaultChooser</a> function
mkStateMachineClient :: forall state input. StateMachineInstance state input -> StateMachineClient state input

-- | A state chooser function that fails if confronted with anything other
--   than exactly one output
defaultChooser :: forall state input. [OnChainState state input] -> Either SMContractError (OnChainState state input)
getStates :: forall s i. IsData s => StateMachineInstance s i -> Map TxOutRef TxOutTx -> [OnChainState s i]

-- | Tries to run one step of a state machine: If the <i>guard</i> (the
--   last argument) returns <tt><a>Nothing</a></tt> when given the
--   unbalanced transaction to be submitted, the old state and the new
--   step, the step is run and <tt><a>Right</a></tt> the new state is
--   returned. If the guard returns <tt><a>Just</a> a</tt>, <tt><a>Left</a>
--   a</tt> is returned instead.
runGuardedStep :: forall w a e state schema input. (AsSMContractError e, IsData state, IsData input, HasUtxoAt schema, HasWriteTx schema, HasOwnPubKey schema, HasTxConfirmation schema) => StateMachineClient state input -> input -> (UnbalancedTx -> state -> state -> Maybe a) -> Contract w schema e (Either a (TransitionResult state input))

-- | Run one step of a state machine, returning the new state.
runStep :: forall w e state schema input. (AsSMContractError e, IsData state, IsData input, HasUtxoAt schema, HasWriteTx schema, HasOwnPubKey schema, HasTxConfirmation schema) => StateMachineClient state input -> input -> Contract w schema e (TransitionResult state input)

-- | Initialise a state machine
runInitialise :: forall w e state schema input. (IsData state, IsData input, HasTxConfirmation schema, HasWriteTx schema, AsSMContractError e) => StateMachineClient state input -> state -> Value -> Contract w schema e state

-- | Get the current on-chain state of the state machine instance. Return
--   Nothing if there is no state on chain. Throws an
--   <tt>SMContractError</tt> if the number of outputs at the machine
--   address is greater than one.
getOnChainState :: (AsSMContractError e, IsData state, HasUtxoAt schema) => StateMachineClient state i -> Contract w schema e (Maybe (OnChainState state i, UtxoMap))

-- | Wait until the on-chain state of the state machine instance has
--   changed, and return the new state, or return <a>Nothing</a> if the
--   instance has been terminated. If <a>waitForUpdate</a> is called before
--   the instance has even started then it returns the first state of the
--   instance as soon as it has started.
waitForUpdate :: (AsSMContractError e, AsContractError e, IsData state, HasAwaitSlot schema, HasWatchAddress schema) => StateMachineClient state i -> Contract w schema e (Maybe (OnChainState state i))

-- | Wait for the on-chain state of the state machine instance to change
--   until timeoutSlot, and return the new state, or return
--   <a>ContractEnded</a> if the instance has been terminated. If
--   <a>waitForUpdate</a> is called before the instance has even started
--   then it returns the first state of the instance as soon as it has
--   started.
waitForUpdateUntil :: (AsSMContractError e, AsContractError e, IsData state, HasAwaitSlot schema, HasWatchAddress schema) => StateMachineClient state i -> Slot -> Contract w schema e (WaitingResult state)

-- | Constraints &amp; lookups needed to transition a state machine
--   instance
data StateMachineTransition state input
StateMachineTransition :: TxConstraints (RedeemerType (StateMachine state input)) (DatumType (StateMachine state input)) -> State state -> State state -> ScriptLookups (StateMachine state input) -> StateMachineTransition state input
[smtConstraints] :: StateMachineTransition state input -> TxConstraints (RedeemerType (StateMachine state input)) (DatumType (StateMachine state input))
[smtOldState] :: StateMachineTransition state input -> State state
[smtNewState] :: StateMachineTransition state input -> State state
[smtLookups] :: StateMachineTransition state input -> ScriptLookups (StateMachine state input)

-- | Given a state machine client and an input to apply to the client's
--   state machine instance, compute the <a>StateMachineTransition</a> that
--   can produce an actual transaction performing the transition
mkStep :: forall w e state schema input. (AsSMContractError e, HasUtxoAt schema, IsData state) => StateMachineClient state input -> input -> Contract w schema e (Either (InvalidTransition state input) (StateMachineTransition state input))

-- | Uninhabited data type
data Void
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.WaitingResult a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.WaitingResult a)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.WaitingResult a)
instance GHC.Show.Show a => GHC.Show.Show (Plutus.Contract.StateMachine.WaitingResult a)
instance Plutus.Contract.StateMachine.AsSMContractError Plutus.Contract.StateMachine.SMContractError
instance Wallet.Types.AsContractError Plutus.Contract.StateMachine.SMContractError
instance (Data.Aeson.Types.FromJSON.FromJSON s, Data.Aeson.Types.FromJSON.FromJSON i) => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (Data.Aeson.Types.ToJSON.ToJSON i, Data.Aeson.Types.ToJSON.ToJSON s) => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Contract.StateMachine.InvalidTransition s i)
instance GHC.Generics.Generic (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (GHC.Show.Show s, GHC.Show.Show i) => GHC.Show.Show (Plutus.Contract.StateMachine.InvalidTransition s i)
instance (GHC.Classes.Eq s, GHC.Classes.Eq i) => GHC.Classes.Eq (Plutus.Contract.StateMachine.InvalidTransition s i)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Contract.StateMachine.SMContractError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Contract.StateMachine.SMContractError
instance GHC.Generics.Generic Plutus.Contract.StateMachine.SMContractError
instance GHC.Classes.Eq Plutus.Contract.StateMachine.SMContractError
instance GHC.Show.Show Plutus.Contract.StateMachine.SMContractError
